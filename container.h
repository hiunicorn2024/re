#ifndef RE_DEFINED_CONTAINER_H
#define RE_DEFINED_CONTAINER_H

#include "base.h"
#include "range.h"
#include "allocator.h"
#include "dynamic.h"
#include "algorithm.h"

// basic_string
// sso_string
// string_reference
namespace re {

namespace inner::fns {

template <class C, class R>
typename C::iterator
seq_container_replace_impl(C &c, typename C::iterator i1,
                           typename C::iterator i2, R &&r) {
  if constexpr (is_frng<R>) {
    const auto d1 = distance(i1, i2);
    const auto d2 = ssize(r);
    if (d2 > d1)
      return prev(c.insert(i2, rng(copy_from(rng(i1, i2), begin(r)), end(r))),
                  d1);
    else {
      c.erase(copy(r, i1), i2);
      return i1;
    }
  }
  else {
    const auto df = i1 - begin(c);
    c.insert(c.erase(i1, i2), r);
    return begin(c) + df;
  }
}

}

template <class T>
class string_reference;
template <class T>
using string_view = string_reference<const T>;
using sref = string_reference<char>;
using sview = string_reference<const char>;
using wsref = string_reference<wchar_t>;
using wsview = string_reference<const wchar_t>;
using u16sref = string_reference<char16_t>;
using u16sview = string_reference<const char16_t>;
using u32sref = string_reference<char32_t>;
using u32sview = string_reference<const char32_t>;

// utf8-utf16-utf32 conversion
namespace inner::fns {

template <class R>
auto unicode_sprint_impl_get_iter_pair(R &r) {
  auto v = rng(r);
  if (!v.empty() && to_unsigned(back(v)) == 0u)
    --v.second;
  return v;
}
template <class R>
auto unicode_sprint_impl_get_iter_pair(R &r)
  requires is_pointer_v<remove_reference_t<R>> {
  const auto p = r;
  auto pp = p;
  for (; to_unsigned(*pp) != 0u; ++pp)
    ;
  return rng(p, pp);
}

template <class T>
bool unicode_sprint_impl_utf16_check(T &sv) {
  const auto ed = sv.end();
  auto it = sv.begin();
  while (it != ed) {
    if (to_unsigned(*it) == 0u)
      return false;
    else if (to_unsigned(*it) >= 0xd800u) {
      if (*it <= 0xdbff) {
        if (next(it) == ed)
          return false;
        else {
          if (!(to_unsigned(*next(it)) >= 0xdc00u
                && to_unsigned(*next(it)) <= 0xdfffu))
            return false;
          ++it;
          ++it;
        }
      }
      else if (*it >= 0xe000u)
        ++it;
      else
        return false;
    }
    else
      ++it;
  }
  return true;
}
template <class T>
optional<uint32_t> unicode_sprint_impl_utf16_sscan_single(T &sv) {
  const auto ed = sv.end();
  auto it = sv.begin();
  for (;;) {
    if (it == ed)
      return optional<uint32_t>(in_place, 0u);
    else if (to_unsigned(*it) == 0u)
      return {};
    else if (to_unsigned(*it) >= 0xd800u) {
      if (*it <= 0xdbff) {
        if (next(it) == ed)
          return {};
        else {
          if (!(to_unsigned(*next(it)) >= 0xdc00u
                && to_unsigned(*next(it)) <= 0xdfffu))
            return {};
          const uint32_t h = to_unsigned(*it) - 0xd800u;
          const uint32_t l = to_unsigned(*next(it)) - 0xdc00u;
          const uint32_t z = ((uint32_t)(h << (uint32_t)10u) + l) + 0x10000u;
          sv.first = next(it, 2);
          return optional<uint32_t>(in_place, z);
        }
      }
      else if (to_unsigned(*it) >= 0xe000u) {
        sv.first = next(it);
        return optional<uint32_t>(in_place, to_unsigned(*it));
      }
      else
        return {};
    }
    else {
      sv.first = next(it);
      return optional<uint32_t>(in_place, to_unsigned(*it));
    }
  }
}
template <class T>
optional<uint32_t> unicode_sprint_impl_utf8_sscan_single(T &sv) {
  using char_t = rng_vt<T>;
  using uchar_t = make_unsigned_t<rng_vt<T>>;
  const uchar_t take_7bits = 0b0111'1111u;
  const uchar_t take_6bits = 0b11'1111u;
  const uchar_t take_5bits = 0b1'1111u;
  const uchar_t take_4bits = 0b1111u;
  const uchar_t take_3bits = 0b111u;
  const auto ed = sv.end();
  auto it = sv.begin();
  const auto take_next_6bits = [&](uint32_t &x)->bool {
    // pre-condition: the leading byte is loaded
    ++it;
    if (it == ed)
      return false;
    if ((uchar_t)(to_unsigned(*it) >> (uchar_t)6u) != 0b10u)
      return false;
    x <<= (uint32_t)6u;
    x += (uchar_t)(to_unsigned(*it) & take_6bits);
    return true;
  };
  for (;;) {
    if (it == ed) {
      sv.first = it;
      return optional<uint32_t>(in_place, 0u);
    }
    else if (to_unsigned(*it) == 0u)
      return {};
    else if ((uchar_t)(to_unsigned(*it) >> (uchar_t)7u) == 0u) {
      const uint32_t x = to_unsigned(*it) & take_7bits;
      sv.first = next(it);
      return optional<uint32_t>(in_place, x);
    }
    else if ((uchar_t)(to_unsigned(*it) >> (uchar_t)5u) == 0b110u) {
      uint32_t x = to_unsigned(*it) & take_5bits;
      if (!take_next_6bits(x))
        return {};
      sv.first = next(it);
      return optional<uint32_t>(in_place, x);
    }
    else if ((uchar_t)(to_unsigned(*it) >> (uchar_t)4u) == 0b1110u) {
      uint32_t x = to_unsigned(*it) & take_4bits;
      if (!take_next_6bits(x))
        return {};
      if (!take_next_6bits(x))
        return {};
      sv.first = next(it);
      return optional<uint32_t>(in_place, x);
    }
    else if ((uchar_t)(to_unsigned(*it) >> (uchar_t)3u) == 0b11110u) {
      uint32_t x = to_unsigned(*it) & take_3bits;
      if (!take_next_6bits(x))
        return {};
      if (!take_next_6bits(x))
        return {};
      if (!take_next_6bits(x))
        return {};
      if (x > 0x10ffffu)
        return {};
      sv.first = next(it);
      return optional<uint32_t>(in_place, x);
    }
    else
      return {};
  }
}

template <class S>
bool utf8sprint_single_uint32(S &s, uint32_t c) {
  // 0___'____                                    7bits
  // 110_'____  10__'____                        11bits
  // 1110'____  10__'____  10__'____             16bits
  // 1111'0___  10__'____  10__'____  10__'____  21bits
  using char_t = rng_vt<S>;
  const uint32_t last_6bits = (numeric_limits<uint32_t>::max()
                               >> (uint32_t)26u);
  if (c == 0u)
    return false;
  else if (c < 0b1000'0000u)
    s.push_back((char_t)c);
  else if (c < 0b1000'0000'0000u) {
    s.push_back((char_t)((uint32_t)(c >> (uint32_t)6u) + 0b110'00000u));
    s.push_back((char_t)((uint32_t)(c & last_6bits) + 0b1000'0000u));
  }
  else if (c < 0b1'0000'0000'0000'0000u) {
    s.push_back((char_t)((uint32_t)(c >> (uint32_t)12u) + 0b111'00000u));
    s.push_back((char_t)
                ((uint32_t)((uint32_t)(c >> (uint32_t)6u) & last_6bits)
                 + 0b1000'0000u));
    s.push_back((char_t)((uint32_t)(c & last_6bits) + 0b1000'0000u));
  }
  else if (c < 0b10'0000'0000'0000'0000'0000u) {
    s.push_back((char_t)((uint32_t)(c >> (uint32_t)18u) + 0b111'10000u));
    s.push_back((char_t)
                ((uint32_t)((uint32_t)(c >> (uint32_t)12u) & last_6bits)
                 + 0b1000'0000u));
    s.push_back((char_t)
                ((uint32_t)((uint32_t)(c >> (uint32_t)6u) & last_6bits)
                 + 0b1000'0000u));
    s.push_back((char_t)((uint32_t)(c & last_6bits) + 0b1000'0000u));
  }
  else
    return false;
  return true;
}

template <class S>
bool utf16sprint_single_uint32(S &s, uint32_t c) {
  using char_t = rng_vt<S>;
  if (c <= 0xd7ffu) {
    s.push_back((char_t)(uint16_t)c);
    return true;
  }
  else if (c <= 0xdfffu)
    return false;
  else if (c <= 0xffffu) {
    s.push_back((char_t)(uint16_t)c);
    return true;
  }
  else if (c <= 0x10ffffu) {
    const uint32_t j = c - 0x10000u;
    const uint32_t h = (uint32_t)(j >> (uint32_t)10u);
    const uint32_t l = (uint32_t)((uint32_t)((uint32_t)(j << (uint32_t)22u))
                                  >> (uint32_t)22u);
    const uint16_t word_1 = h + 0xd800u;
    const uint16_t word_2 = l + 0xdc00u;
    s.push_back((char_t)word_1);
    s.push_back((char_t)word_2);
    return true;
  }
  else
    return false;
}

template <class S, class R>
bool utf8sprint_utf8(S &s, R &&r) {
  const auto v = inner::fns::unicode_sprint_impl_get_iter_pair(r);
  if (!is_array_v<remove_cvref_t<R>> && v.end() != end(r))
    return false;
  s.append_range(v);
  return true;
}
template <class S, class R>
bool utf16sprint_utf8(S &s, R &&r) {
  auto sv = inner::fns::unicode_sprint_impl_get_iter_pair(r);
  if (!is_array_v<remove_cvref_t<R>> && sv.end() != end(r))
    return false;
  for (;;) {
    const auto x = unicode_sprint_impl_utf8_sscan_single(sv);
    if (x.empty())
      return false;
    else {
      if (*x == 0u)
        return sv.empty();
      else {
        if (!utf16sprint_single_uint32(s, *x))
          return false;
      }
    }
  }
  return true;
}
template <class S, class R>
bool utf32sprint_utf8(S &s, R &&r) {
  auto sv = inner::fns::unicode_sprint_impl_get_iter_pair(r);
  if (!is_array_v<remove_cvref_t<R>> && sv.end() != end(r))
    return false;
  for (;;) {
    const auto x = unicode_sprint_impl_utf8_sscan_single(sv);
    if (x.empty())
      return false;
    else {
      if (*x == 0u)
        return sv.empty();
      else
        s.push_back(*x);
    }
  }
  return true;
}

template <class S, class R>
bool utf8sprint_utf16(S &s, R &&r) {
  auto sv = inner::fns::unicode_sprint_impl_get_iter_pair(r);
  if (!is_array_v<remove_cvref_t<R>> && sv.end() != end(r))
    return false;
  using char_t = typename S::value_type;
  for (;;) {
    const auto x = inner::fns::unicode_sprint_impl_utf16_sscan_single(sv);
    if (x.empty())
      return false;
    else {
      const uint32_t c = *x;
      if (c == 0u)
        return sv.empty();
      if (!inner::fns::utf8sprint_single_uint32(s, c))
        return false;
    }
  }
}
template <class S, class R>
bool utf16sprint_utf16(S &s, R &&r) {
  auto sv = inner::fns::unicode_sprint_impl_get_iter_pair(r);
  if (!is_array_v<remove_cvref_t<R>> && sv.end() != end(r))
    return false;
  if (!inner::fns::unicode_sprint_impl_utf16_check(sv))
    return false;
  s.append_range(bind_rng(sv, to_unsigned));
  return true;
}
template <class S, class R>
bool utf32sprint_utf16(S &s, R &&r) {
  auto sv = inner::fns::unicode_sprint_impl_get_iter_pair(r);
  if (!is_array_v<remove_cvref_t<R>> && sv.end() != end(r))
    return false;
  using char_t = typename S::value_type;
  for (;;) {
    auto x = inner::fns::unicode_sprint_impl_utf16_sscan_single(sv);
    if (x.empty())
      return false;
    else {
      if (*x == 0u)
        return sv.empty();
      else
        s.push_back(*x);
    }
  }
}

template <class S, class R>
bool utf8sprint_utf32(S &s, R &&r) {
  auto sv = unicode_sprint_impl_get_iter_pair(r);
  if (!is_array_v<remove_cvref_t<R>> && sv.end() != end(r))
    return false;
  using char_t = typename S::value_type;
  for (auto x0 : sv) {
    const uint32_t x(x0);
    if (!inner::fns::utf8sprint_single_uint32(s, x))
      return false;
  }
  return true;
}
template <class S, class R>
bool utf16sprint_utf32(S &s, R &&r) {
  auto sv = unicode_sprint_impl_get_iter_pair(r);
  if (!is_array_v<remove_cvref_t<R>> && sv.end() != end(r))
    return false;
  for (auto x0 : sv)
    if (!inner::fns::utf16sprint_single_uint32(s, (uint32_t)x0))
      return false;
  return true;
}
template <class S, class R>
bool utf32sprint_utf32(S &s, R &&r) {
  auto sv = unicode_sprint_impl_get_iter_pair(r);
  if (!is_array_v<remove_cvref_t<R>> && sv.end() != end(r))
    return false;
  const auto f = [](uint32_t c) {
    return c > 0x10ffffu || (c >= 0xd800u && c <= 0xdfffu);
  };
  if (any_of(r, f))
    return false;    
  s.append_range(r);
  return true;
}

}
// arg_can_be_utf[8/16/32]string
namespace inner {

template <class R>
concept arg_can_be_utf8string_pointer
  = is_pointer_v<remove_reference_t<R>>
  && is_integral_v<itr_vt<remove_reference_t<R>>>
  && !is_same_v<itr_vt<remove_reference_t<R>>, bool>
  && sizeof(itr_vt<remove_reference_t<R>>) == 1u;
template <class R>
concept arg_can_be_utf8string_range
  = is_frng<R>
  && is_integral_v<rng_vt<R>> && !is_same_v<rng_vt<R>, bool>
  && sizeof(rng_vt<R>) == 1u;
template <class R>
concept arg_can_be_utf8string
  = arg_can_be_utf8string_pointer<R> || arg_can_be_utf8string_range<R>;

template <class R>
concept arg_can_be_utf16string_pointer
  = is_pointer_v<remove_reference_t<R>>
  && is_integral_v<itr_vt<remove_reference_t<R>>>
  && sizeof(itr_vt<remove_reference_t<R>>) == 2u;
template <class R>
concept arg_can_be_utf16string_range
  = is_frng<R> && is_integral_v<rng_vt<R>> && sizeof(rng_vt<R>) == 2u;
template <class R>
concept arg_can_be_utf16string
  = arg_can_be_utf16string_pointer<R> || arg_can_be_utf16string_range<R>;

template <class R>
concept arg_can_be_utf32string_pointer
  = is_pointer_v<remove_reference_t<R>>
  && is_integral_v<itr_vt<remove_reference_t<R>>>
  && sizeof(itr_vt<remove_reference_t<R>>) == 4u;
template <class R>
concept arg_can_be_utf32string_range
  = is_frng<R> && is_integral_v<rng_vt<R>> && sizeof(rng_vt<R>) == 4u;
template <class R>
concept arg_can_be_utf32string
  = arg_can_be_utf32string_pointer<R> || arg_can_be_utf32string_range<R>;

}

namespace inner::fns {

template <class T>
T &get_static_empty_string_placeholder() {
  static T value[1] = {0};
  return value[0];
};

template <class CHAR, class R>
enable_if_t<!(is_array_v<remove_reference_t<R>> && is_same_v<rng_vt<R>, CHAR>),
            R &>
basic_string_select_range(R &&r) {
  return r;
}
template <class CHAR, class R>
enable_if_t<is_array_v<remove_reference_t<R>> && is_same_v<rng_vt<R>, CHAR>,
            iter_pair<rng_itr<R>>>
basic_string_select_range(R &&r) {
  const auto ed = end(r);
  const auto p = ed - 1;
  return rng(begin(r), *p != 0 ? ed : p);
}

}
namespace inner {

template <class AL>
struct string_data {
  alloc_ptr<AL> op;
  alloc_ptr<AL> now;
  alloc_ptr<AL> ed;

  static alloc_ptr<AL> epts() noexcept {
    return pointer_to<alloc_ptr<AL>>
      (inner::fns::get_static_empty_string_placeholder<alloc_vt<AL>>());
  }
};

}
template <class T, class AL = default_allocator<T>>
class basic_string : inner::string_data<AL>, allocator_wrapper<AL> {
  static_assert(is_same_v<T, alloc_vt<AL>>);

  using this_t = basic_string;

  using data_t = inner::string_data<AL>;
  using data_t::op;
  using data_t::ed;
  using data_t::now;

  using alw_t = allocator_wrapper<AL>;
  using alw_t::allocate;
  using alw_t::construct;
  using alw_t::destroy;
  using alw_t::deallocate;
  using alw_t::destroy_fn;
  using alw_t::new_1;
  using alw_t::new_n;
  using alw_t::delete_1;
  using alw_t::delete_n;
  using alw_t::make_temporary;
  using alw_t::uninitialized_fill;
  using alw_t::uninitialized_copy;
  using alw_t::uninitialized_move;
  using alw_t::uninitialized_fully_move;
  using alw_t::fully_move;

  template <class R>
  static auto begin(R &&r) {return re::begin(r);}
  template <class R>
  static auto end(R &&r) {return re::end(r);}
  template <class R>
  static auto rbegin(R &&r) {return re::rbegin(r);}
  template <class R>
  static auto rend(R &&r) {return re::rend(r);}
  template <class R>
  static auto size(R &&r) {return re::size(r);}
  template <class R>
  static auto empty(R &&r) {return re::empty(r);}

public:
  using pointer = alloc_ptr<AL>;
  using const_pointer = alloc_cptr<AL>;

  // container

  using value_type = T;
  using reference = value_type &;
  using const_reference = const value_type &;

  using iterator = pointer;
  using const_iterator = const_pointer;
  using difference_type = alloc_dft<AL>;
  using size_type = alloc_szt<AL>;

  iterator begin() noexcept {
    return op;
  }
  iterator end() noexcept {
    return now;
  }
  const_iterator begin() const noexcept {
    return op;
  }
  const_iterator end() const noexcept {
    return now;
  }
  const_iterator cbegin() const noexcept {
    return begin();
  }
  const_iterator cend() const noexcept {
    return end();
  }

  size_type max_size() const noexcept {
    return container_regular_max_size<this_t>() - 1u;
  }
  size_type size() const noexcept {
    return now - op;
  }
  bool empty() const noexcept {
    return now == op;
  }

private:
  // inner implements

  friend class allocator_aware_container_ownership<this_t>;
  const AL &alloc_ref() const noexcept {
    return alw_t::get();
  }
  AL &alloc_ref() noexcept {
    return alw_t::get();
  }
  void new_data() noexcept {
    op = ed = now = inner::string_data<AL>::epts();
  }
  void delete_data() noexcept {
    if (op != inner::string_data<AL>::epts()) {
      destroy(rng(op, ed + 1));
      deallocate(op, ed - op + 1);
    }
  }
  void new_data(const this_t &v) {
    construct_from_range_impl(v);
  }
  void assign_data(const this_t &v) {
    assign_range_impl(v);
  }
  void new_data(this_t &&v) noexcept {
    data_t::operator =(static_cast<data_t &&>(v));
    v.new_data();
  }
  void new_data_individually(this_t &&v) {
    construct_from_range_impl(v);
    v.delete_data();
    v.new_data();
  }
  void assign_data_individually(this_t &&v) {
    assign_range_impl(v);
    v.delete_data();
    v.new_data();
  }
  void swap_data(this_t &v) noexcept {
    adl_swap(op, v.op);
    adl_swap(now, v.now);
    adl_swap(ed, v.ed);
  }
  void swap_data_individually(this_t &v) {
    const size_type n = size();
    const size_type nn = ed - op;
    const size_type v_n = v.size();
    const size_type v_nn = v.ed - v.op;
    if (nn < v_n)
      reallocate_impl(v_n);
    else if (v_nn < n)
      v.reallocate_impl(n);
    if (n < v_n)
      swap_ranges(v, op);
    else
      swap_ranges(*this, v.op);
    v.now = v.op + n;
    now = op + v_n;
  }

  // reallocate_impl(n):
  //   requires: max_size() >= n >= now - op && n > 0
  void reallocate_impl(size_type n) {
    const auto p = allocate(n + 1u);
    const auto pp = uninitialized_copy(rng(op, now), p);
    uninitialized_fill(rng(pp, p + n + 1u), 0);
    delete_data();
    op = p;
    now = pp;
    ed = p + n;
  }

  template <class UINT>
  void reserve_space_at_least(UINT n) {
    static_assert(is_integral_v<UINT> && is_unsigned_v<UINT>);

    const size_type rest_n = ed - now;
    if (n > rest_n) {
      n -= rest_n;
      const size_type cp = ed - op;
      const size_type cp_rest = max_size() - cp;
      if (cp_rest >= n)
        reallocate_impl((n < cp && cp_rest >= cp) ? (cp + cp) : (cp + n));
      else
        throw_or_terminate<length_error>
          ("re::basic_string::reserve_space_at_least(n): size overflow\n");
    }
  }
  // increase_capacity_at_least_1() requires: the capacity is just full
  void increase_capacity_at_least_1() {
    size_type n;
    if (op == ed)
      n = 1;
    else {
      const size_type cp = ed - op;
      const size_type cp_rest = max_size() - cp;
      if (cp_rest >= cp)
        n = cp + cp;
      else {
        if (cp_rest == 0u)
          throw_or_terminate<length_error>
            ("re::basic_string::increase_capacity_at_least_1(): "
             "size overflow\n");
        n = max_size();
      }
    }
    reallocate_impl(n);
  }

  void push_back_impl(T x) {
    if (now == ed)
      increase_capacity_at_least_1();
    *now = x;
    ++now;
  }
  void pop_back_impl() noexcept {
    *--now = 0;
  }
  void pop_back_n_impl(size_type n) noexcept {
    for (; n != 0; --n)
      *--now = 0;
  }

  pointer insert_impl(const_pointer cpos, T x) {
    auto pos = cpos - op + op;
    if (now == ed) {
      const auto dif = pos - op;
      increase_capacity_at_least_1();
      pos = op + dif;
    }
    copy_backward(rng(pos, now), now + 1);
    ++now;
    *pos = x;
    return pos;
  }

  pointer erase_impl(const_pointer cpos) noexcept {
    const auto pos = cpos - op + op;
    copy(rng(pos + 1, now), pos);
    *--now = 0;
    return pos;
  }
  pointer erase_range_impl(const_pointer cfrom,
                           const_pointer cto) noexcept {
    const auto from = cfrom - op + op;
    const auto to = cto - op + op;
    if (from != to) {
      const auto p = copy(rng(to, now), from);
      fill_zero(rng(p, now));
      now = p;
    }
    return from;
  }

  template <class IITR_RANGE>
  enable_if_t<rng_is_sized<IITR_RANGE>>
  append_range_impl(IITR_RANGE &&r) {
    reserve_space_at_least(size(r));
#ifndef RE_NOEXCEPT
    try {
#endif
      now = copy(r, now);
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      fill_zero(rng(now, ed));
      throw;
    }
#endif
  }
  template <class IITR_RANGE>
  enable_if_t<!rng_is_sized<IITR_RANGE>>
  append_range_impl(IITR_RANGE &&r) {
    for (auto &p : iters(r))
      push_back_impl(*p);
  }

  template <class IITR_RANGE, class TT = value_type>
  enable_if_t<rng_is_sized<IITR_RANGE> || is_fitr<rng_itr<IITR_RANGE>>, pointer>
  insert_range_impl(const_pointer cpos, IITR_RANGE &&r) {
    auto pos = cpos - op + op;
    const auto pos_dif = pos - op;
    if (pos == now) {
      append_range_impl(r);
      return op + pos_dif;
    }
    else {
      const auto n = size(r);
      reserve_space_at_least(n);
      pos = op + pos_dif;
      copy_backward(rng(pos, now), now + n);
      now += n;
      copy(r, pos);
      return pos;
    }
  }
  template <class IITR_RANGE, class TT = value_type>
  enable_if_t<!(rng_is_sized<IITR_RANGE> || is_fitr<rng_itr<IITR_RANGE>>),
              pointer>
  insert_range_impl(const_pointer cpos, IITR_RANGE &&r) {
    auto pos = cpos - op + op;
    const auto dif_pos = pos - op;
    if (pos == now) {
      append_range_impl(r);
      return op + dif_pos;
    }
    else {
      const auto dif_now = now - op;
      append_range_impl(r);
      pos = op + dif_pos;
      rotate(rng(pos, now), op + dif_now);
      return pos;
    }
  }

  template <class SZT>
  void size_check(SZT n) {
    static_assert(is_integral_v<SZT> && is_unsigned_v<SZT>);
    if (to_unsigned(n) > max_size())
      throw_or_terminate<length_error>
        ("re::basic_string: size overflow in size_check(n)\n");
  }

  template <class IITR_RANGE>
  enable_if_t<rng_is_sized<IITR_RANGE>>
  construct_from_range_impl(IITR_RANGE &&r) {
    const auto n = size(r);
    if (n == 0u) {
      new_data();
      return;
    }
    size_check(n);
    op = allocate(n + 1u);
    now = ed = op + n;
#ifndef RE_NOEXCEPT
    try {
#endif
      uninitialized_copy(r, op);
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      deallocate(op, n + 1u);
      throw;
    }
#endif
    construct(to_address(now), value_type(0));
  }
  template <class IITR_RANGE>
  enable_if_t<!rng_is_sized<IITR_RANGE>>
  construct_from_range_impl(IITR_RANGE &&r) {
    new_data();
    for (auto &p : iters(r))
      push_back_impl(*p);
  }

  void construct_n_impl(size_type n) {
    if (n == 0u) {
      new_data();
      return;
    }
    size_check(n);
    op = allocate(n + 1u);
#ifndef RE_NOEXCEPT
    try {
#endif
      uninitialized_fill(rng(op, n + 1u), 0);
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      deallocate(op, n + 1u);
      throw;
    }
#endif
    ed = now = op + n;
  }

  template <class IITR_RANGE>
  enable_if_t<rng_is_sized<IITR_RANGE>>
  assign_range_impl(IITR_RANGE &&r) {
    const auto n = size(r);
    if (n == 0u) {
      delete_data();
      new_data();
    }
    else if (n > to_unsigned(ed - op)) {
      delete_data();
#ifndef RE_NOEXCEPT
      new_data();
#endif
      size_check(n);
      op = allocate(n + 1u);
      now = ed = op + n;
#ifndef RE_NOEXCEPT
      try {
#endif
        uninitialized_copy(r, op);
#ifndef RE_NOEXCEPT
      }
      catch (...) {
        deallocate(op, n + 1u);
        new_data();
        throw;
      }
#endif
      construct(to_address(ed), 0);
    }
    else if (n < to_unsigned(now - op)) {
      const pointer mid = copy(r, op);
      fill_zero(rng(mid, now));
      now = mid;
    }
    else
      now = copy(r, op);
  }
  template <class IITR_RANGE>
  enable_if_t<!rng_is_sized<IITR_RANGE>>
  assign_range_impl(IITR_RANGE &&r) {
    auto r1 = rng(*this);
    auto r2 = rng(r);
    for (;;) {
      if (empty(r1)) {
        append_range_impl(r2);
        return;
      }
      if (empty(r2)) {
        erase_range_impl(r1.first, r1.second);
        return;
      }
      *r1.first = *r2.first;
      ++r1.first;
      ++r2.first;
    }
  }

  void resize_impl(size_type n) {
    const size_type sz = size();
    if (n < sz)
      erase_range_impl(now - (sz - n), now);
    else {
      reserve_space_at_least(n -= sz);
      now += n;
    }
  }
  void resize_impl(size_type n, value_type x) {
    const size_type sz = size();
    if (n < sz) {
      fill_zero(rng(op + n, now));
      now = op + n;
    }
    else {
      reserve_space_at_least(n -= sz);
      fill(rng(now, n), x);
      now += n;
    }
  }
  void reserve_impl(size_type n) {
    if (n > to_unsigned(ed - op)) {
      if (n > max_size())
        throw_or_terminate<length_error>
          ("re::basic_string: size overflow in reserve_impl(n)\n");
      reallocate_impl(n);
    }
  }
  void shrink_to_fit_impl() {
    if (op == now) {
      delete_data();
      new_data();
    }
    else if (now < ed)
      reallocate_impl(now - op);
  }

public:
  // container (continued)

  basic_string() noexcept(noexcept(AL())) : basic_string(AL()) {}
  ~basic_string() {
    delete_data();
  }
  basic_string(const basic_string &v)
    : alw_t(alw_t::traits
            ::select_on_container_copy_construction(v.alloc_ref())) {
    new_data(v);
  }
  basic_string &operator =(const basic_string &v) {
    allocator_aware_container_ownership<this_t>::copy_assign(*this, v);
    return *this;
  }
  basic_string(basic_string &&v) noexcept : alw_t(move(v.alloc_ref())) {
    new_data(move(v));
  }
  basic_string &operator =(basic_string &&v)
    noexcept(alloc_move_prpg<AL> || alloc_always_equal<AL>) {
    allocator_aware_container_ownership<this_t>::move_assign(*this, v);
    return *this;
  }
  friend void swap(basic_string &x, basic_string &y)
    noexcept(alloc_swap_prpg<AL> || alloc_always_equal<AL>) {
    allocator_aware_container_ownership<this_t>::swap(x, y);
  }

  // optional container operations

  // reversible container

  using reverse_iterator = re::reverse_iterator<iterator>;
  using const_reverse_iterator = re::reverse_iterator<const_iterator>;

  reverse_iterator rbegin() noexcept {
    return reverse_iterator(now);
  }
  reverse_iterator rend() noexcept {
    return reverse_iterator(op);
  }
  const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator(now);
  }
  const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator(op);
  }
  const_reverse_iterator crbegin() const noexcept {
    return rbegin();
  }
  const_reverse_iterator crend() const noexcept {
    return rend();
  }

  // allocator-aware container

  using allocator_type = AL;
  allocator_type get_allocator() const noexcept {
    return alw_t::get();
  }

  explicit basic_string(const AL &al) noexcept : alw_t(al) {
    new_data();
  }
  basic_string(const basic_string &v, const AL &al) : alw_t(al) {
    new_data(v);
  }
  basic_string(basic_string &&v, const AL &al) : alw_t(al) {
    allocator_aware_container_ownership<this_t>::move_construct(*this, v);
  }

  // sequence container

  explicit basic_string(size_type n, const AL &al = AL{}) : alw_t(al) {
    construct_n_impl(n);
  }
  basic_string(size_type n, value_type t, const AL &al = AL{}) : alw_t(al) {
    construct_from_range_impl(rng(n, ref(t)));
  }
  void assign(size_type n, value_type t) {
    assign_range_impl(rng(n, ref(t)));
  }

  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  basic_string(IITR from, IITR to, const AL &al = AL{}) : alw_t(al) {
    construct_from_range_impl(rng(from, to));
  }
  template <class IITR>
  enable_if_t<is_itr<IITR>> assign(IITR from, IITR to) {
    assign_range_impl(rng(from, to));
  }

  basic_string(initializer_list<value_type> l,
               const AL &al = AL{}) : alw_t(al) {
    construct_from_range_impl(l);
  }
  basic_string &operator =(initializer_list<value_type> l) {
    assign_range_impl(l);
    return *this;
  }
  void assign(initializer_list<value_type> l) {
    assign_range_impl(l);
  }

  iterator insert(const_iterator pos, value_type t) {
    return insert_impl(pos, t);
  }

  iterator insert(const_iterator pos, size_type n, value_type t) {
    return insert_range_impl(pos, rng(n, ref(t)));
  }
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  iterator insert(const_iterator pos, IITR from, IITR to) {
    return insert_range_impl(pos, rng(from, to));
  }
  iterator insert(const_iterator pos, initializer_list<value_type> l) {
    return insert_range_impl(pos, l);
  }

  iterator erase(const_iterator pos) {
    return erase_impl(pos);
  }
  iterator erase(const_iterator from, const_iterator to) {
    return erase_range_impl(from, to);
  }

  void clear() noexcept {
    fill_zero(rng(op, now));
    now = op;
  }

  // optional sequence container operations

  reference front() {
    return *op;
  }
  reference back() {
    return *(now - 1);
  }
  const_reference front() const {
    return *op;
  }
  const_reference back() const {
    return *(now - 1);
  }

  void push_back(value_type t) {
    push_back_impl(t);
  }
  void pop_back() {
    pop_back_impl();
  }

  reference operator [](size_type n) {
    return op[n];
  }
  const_reference operator [](size_type n) const {
    return op[n];
  }
  reference at(size_type n) {
    if (n >= size())
      throw_or_terminate<out_of_range>("re::basic_string: at(n) failed\n");
    return op[n];
  }
  const_reference at(size_type n) const {
    if (n >= size())
      throw_or_terminate<out_of_range>("re::basic_string: at(n) failed\n");
    return op[n];
  }

  // specialized operations

  value_type *data() noexcept {
    return to_address(op);
  }
  const value_type *data() const noexcept {
    return to_address(op);
  }
  size_type capacity() const noexcept {
    return ed - op;
  }
  void resize(size_type n) {
    resize_impl(n);
  }
  void resize(size_type n, value_type t) {
    resize_impl(n, t);
  }
  void reserve(size_type n) {
    reserve_impl(n);
  }
  void shrink_to_fit() {
    shrink_to_fit_impl();
  }

  // extensions

  template <class UF>
  size_type remove_if(UF eq) {
    const auto i = re::remove_if(*this, eq);
    const auto z = end();
    const size_type ret = z - i;
    erase(i, z);
    return ret;
  }
  template <class X>
  size_type remove(const X &x) {
    return remove_if(bind(equal_to<>{}, _1, ref(x)));
  }

  bool full() const noexcept {
    return size() == capacity();
  }

  void reallocate(size_type n) {
    if (const auto z = size(); n < z)
      n = z;
    else
      size_check(n);
    if (n == 0u) {
      delete_data();
      new_data();
    }
    else
      reallocate_impl(n);
  }
  void reallocate() {
    reallocate(size());
  }

  void reserve_more(size_type n) {
    reserve_space_at_least(n);
  }

  template <class R>
  iterator replace(const_iterator i1, const_iterator i2, R &&r) {
    return inner::fns::seq_container_replace_impl
      (*this, i1 - begin() + begin(), i2 - begin() + begin(), r);
  }

  template <class R>
  bool assign_unicode(R &&r)
    requires (inner::arg_can_be_utf8string<R>
              && inner::arg_can_be_utf8string_range<this_t>) {
    this_t tmp(get_allocator());
    if (!inner::fns::utf8sprint_utf8(tmp, r))
      return false;
    *this = move(tmp);
    return true;
  }
  template <class R>
  bool assign_unicode(R &&r)
    requires (inner::arg_can_be_utf8string<R>
              && inner::arg_can_be_utf16string_range<this_t>) {
    this_t tmp(get_allocator());
    if (!inner::fns::utf16sprint_utf8(tmp, r))
      return false;
    *this = move(tmp);
    return true;
  }
  template <class R>
  bool assign_unicode(R &&r)
    requires (inner::arg_can_be_utf8string<R>
              && inner::arg_can_be_utf32string_range<this_t>) {
    this_t tmp(get_allocator());
    if (!inner::fns::utf32sprint_utf8(tmp, r))
      return false;
    *this = move(tmp);
    return true;
  }

  template <class R>
  bool assign_unicode(R &&r)
    requires (inner::arg_can_be_utf16string<R>
              && inner::arg_can_be_utf8string_range<this_t>) {
    this_t tmp(get_allocator());
    if (!inner::fns::utf8sprint_utf16(tmp, r))
      return false;
    *this = move(tmp);
    return true;
  }
  template <class R>
  bool assign_unicode(R &&r)
    requires (inner::arg_can_be_utf16string<R>
              && inner::arg_can_be_utf16string_range<this_t>) {
    this_t tmp(get_allocator());
    if (!inner::fns::utf16sprint_utf16(tmp, r))
      return false;
    *this = move(tmp);
    return true;
  }
  template <class R>
  bool assign_unicode(R &&r)
    requires (inner::arg_can_be_utf16string<R>
              && inner::arg_can_be_utf32string_range<this_t>) {
    this_t tmp(get_allocator());
    if (!inner::fns::utf32sprint_utf16(tmp, r))
      return false;
    *this = move(tmp);
    return true;
  }

  template <class R>
  bool assign_unicode(R &&r)
    requires (inner::arg_can_be_utf32string<R>
              && inner::arg_can_be_utf8string_range<this_t>) {
    this_t tmp(get_allocator());
    if (!inner::fns::utf8sprint_utf32(tmp, r))
      return false;
    *this = move(tmp);
    return true;
  }
  template <class R>
  bool assign_unicode(R &&r)
    requires (inner::arg_can_be_utf32string<R>
              && inner::arg_can_be_utf16string_range<this_t>) {
    this_t tmp(get_allocator());
    if (!inner::fns::utf16sprint_utf32(tmp, r))
      return false;
    *this = move(tmp);
    return true;
  }
  template <class R>
  bool assign_unicode(R &&r)
    requires (inner::arg_can_be_utf32string<R>
              && inner::arg_can_be_utf32string_range<this_t>) {
    this_t tmp(get_allocator());
    if (!inner::fns::utf32sprint_utf32(tmp, r))
      return false;
    *this = move(tmp);
    return true;
  }

  template <class R>
  basic_string(from_range_t, R &&r, const allocator_type &a = allocator_type{})
    requires (is_rng<R> && is_constructible_v<value_type, rng_ref<R>>)
    : alw_t(a) {
    construct_from_range_impl(inner::fns::basic_string_select_range<T>(r));
  }
  template <class R, class = enable_if_t
            <!is_same_v<decay_t<R>, this_t>
             && !is_convertible_v<R, const allocator_type &>
             && is_rng<R> && is_constructible_v<value_type, rng_ref<R>>
             && (is_array_v<remove_reference_t<R>>
                 && is_same_v<decay_t<rng_vt<R>>, decay_t<T>>)>>
  basic_string(R &&r) : basic_string(r, allocator_type{}) {}
  template <class R, class = enable_if_t
            <!is_same_v<decay_t<R>, this_t>
             && !is_convertible_v<R, allocator_type>
             && is_rng<R> && is_constructible_v<value_type, rng_ref<R>>
             && !(is_array_v<remove_reference_t<R>>
                  && is_same_v<decay_t<rng_vt<R>>, decay_t<T>>)>,
            class = void>
  explicit basic_string(R &&r) : basic_string(r, allocator_type{}) {}
  template <class R, class = enable_if_t
            <!is_same_v<decay_t<R>, this_t>
             && is_rng<R> && is_constructible_v<value_type, rng_ref<R>>>>
  basic_string(R &&r, const allocator_type &al) : alw_t(al) {
    construct_from_range_impl(inner::fns::basic_string_select_range<T>(r));
  }
  template <class IITR_RANGE>
  enable_if_t<!is_same_v<decay_t<IITR_RANGE>, this_t>
              && is_rng<IITR_RANGE>
              && is_constructible_v<value_type, rng_ref<IITR_RANGE>>, this_t &>
  operator =(IITR_RANGE &&r) {
    assign_range_impl(inner::fns::basic_string_select_range<T>(r));
    return *this;
  }
  template <class IITR_RANGE>
  void assign(IITR_RANGE &&r) {
    assign_range_impl(inner::fns::basic_string_select_range<T>(r));
  }
  template <class IITR_RANGE>
  void assign_range(IITR_RANGE &&r) {
    assign_range_impl(inner::fns::basic_string_select_range<T>(r));
  }

  template <class IITR_RANGE>
  enable_if_t<!is_convertible_v<IITR_RANGE &&, value_type>, iterator>
  insert(const_iterator pos, IITR_RANGE &&r) {
    return insert_range_impl(pos, inner::fns::basic_string_select_range<T>(r));
  }
  template <class IITR_RANGE>
  iterator insert_range(const_iterator pos, IITR_RANGE &&r) {
    return insert_range_impl(pos, inner::fns::basic_string_select_range<T>(r));
  }

  template <class IITR_RANGE>
  enable_if_t<!is_convertible_v<IITR_RANGE &&, value_type>>
  push_back(IITR_RANGE &&r) {
    append_range_impl(inner::fns::basic_string_select_range<T>(r));
  }
  template <class IITR_RANGE>
  void append_range(IITR_RANGE &&r) {
    append_range_impl(inner::fns::basic_string_select_range<T>(r));
  }
  void pop_back(size_type n) {
    pop_back_n_impl(n);
  }

  this_t &append() {
    return *this;
  }
  template <class X, class...S>
  this_t &append(X &&x, S &&...s) {
    push_back(forward<X>(x));
    return append(forward<S>(s)...);
  }
};
template <class T, class AL>
bool operator ==(const basic_string<T, AL> &x,
                 const basic_string<T, AL> &y) {
  return equal(x, y);
}
template <class T, class AL>
synth_3way_result<T> operator <=>(const basic_string<T, AL> &x,
                                  const basic_string<T, AL> &y) {
  return lexicographical_synth_3way(x, y);
}
template <class T, class AL, size_t N>
bool operator ==(const basic_string<T, AL> &x, const T (&y)[N]) {
  return equal(x, inner::fns::basic_string_select_range<T>(y));
}
template <class T, class AL, size_t N>
bool operator ==(const T (&x)[N], const basic_string<T, AL> &y) {
  return equal(inner::fns::basic_string_select_range<T>(x), y);
}
template <class T, class AL, size_t N>
synth_3way_result<T> operator <=>(const basic_string<T, AL> &x,
                                  const T (&y)[N]) {
  return lexicographical_synth_3way
    (x, inner::fns::basic_string_select_range<T>(y));
}
template <class T, class AL, size_t N>
synth_3way_result<T> operator <=>(const T (&x)[N],
                                  const basic_string<T, AL> &y) {
  return lexicographical_synth_3way
    (inner::fns::basic_string_select_range<T>(x), y);
}

namespace inner {

template <class T, size_t N, class AL>
struct sso_string_data {
  alloc_ptr<AL> p;
  alloc_szt<AL> sz;
  union shared_t {
    alloc_szt<AL> cp;
    T buf[N + 1u];

    shared_t() {}
    ~shared_t() {}
    shared_t(const shared_t &) = delete;
    shared_t &operator =(const shared_t &) = delete;
    shared_t(shared_t &&) = delete;
    shared_t &operator =(shared_t &&) = delete;
  } shared;

  void set_cp(alloc_szt<AL> x) {
    using t = alloc_szt<AL>;
    new(addressof(shared.cp)) t(x);
  }
  auto in_object_data() noexcept {
    return pointer_to<alloc_ptr<AL>>(shared.buf[0]);
  }
  auto in_object_data() const noexcept {
    return pointer_to<alloc_cptr<AL>>(shared.buf[0]);
  }
};

}
template <class T, size_t N, class AL = default_allocator<T>>
class sso_string
  : inner::sso_string_data<T, N, AL>, allocator_wrapper<AL> {
  static_assert(N > 0);
  static_assert(is_trivially_copyable_v<T>);
  static_assert(is_trivially_destructible_v<T>);
  static_assert(is_same_v<T, alloc_vt<AL>>);

  using this_t = sso_string;

  using data_t = inner::sso_string_data<T, N, AL>;
  using data_t::p;
  using data_t::sz;
  using data_t::shared;
  using data_t::set_cp;
  using data_t::in_object_data;

  using alw_t = allocator_wrapper<AL>;
  using alw_t::allocate;
  using alw_t::construct;
  using alw_t::destroy;
  using alw_t::deallocate;
  using alw_t::destroy_fn;
  using alw_t::new_1;
  using alw_t::new_n;
  using alw_t::delete_1;
  using alw_t::delete_n;
  using alw_t::make_temporary;
  using alw_t::uninitialized_fill;
  using alw_t::uninitialized_copy;
  using alw_t::uninitialized_move;
  using alw_t::uninitialized_fully_move;
  using alw_t::fully_move;

  template <class R>
  static auto begin(R &&r) {return re::begin(r);}
  template <class R>
  static auto end(R &&r) {return re::end(r);}
  template <class R>
  static auto rbegin(R &&r) {return re::rbegin(r);}
  template <class R>
  static auto rend(R &&r) {return re::rend(r);}
  template <class R>
  static auto size(R &&r) {return re::size(r);}
  template <class R>
  static auto empty(R &&r) {return re::empty(r);}

public:
  using pointer = alloc_ptr<AL>;
  using const_pointer = alloc_cptr<AL>;

  // container

  using value_type = T;
  using reference = value_type &;
  using const_reference = const value_type &;

  using iterator = pointer;
  using const_iterator = const_pointer;
  using difference_type = alloc_dft<AL>;
  using size_type = alloc_szt<AL>;

  iterator begin() noexcept {
    return p;
  }
  iterator end() noexcept {
    return p + sz;
  }
  const_iterator begin() const noexcept {
    return p;
  }
  const_iterator end() const noexcept {
    return p + sz;
  }
  const_iterator cbegin() const noexcept {
    return begin();
  }
  const_iterator cend() const noexcept {
    return end();
  }

  size_type max_size() const noexcept {
    return container_regular_max_size<this_t>() - 1u;
  }
  size_type size() const noexcept {
    return sz;
  }
  bool empty() const noexcept {
    return sz == 0u;
  }

private:
  auto buf_rng() noexcept {
    return rng(in_object_data(), N + 1u);
  }
  auto buf_rng() const noexcept {
    return rng(in_object_data(), N + 1u);
  }
public:
  bool local() const noexcept {
    return p == in_object_data();
  }
private:

  // inner implements
  friend class allocator_aware_container_ownership<this_t>;
  const AL &alloc_ref() const noexcept {
    return alw_t::get();
  }
  AL &alloc_ref() noexcept {
    return alw_t::get();
  }
  void new_data() noexcept {
    p = in_object_data();
    sz = 0;
    uninitialized_fill(buf_rng(), 0);
  }
  void delete_data() noexcept {
    if (!local())
      delete_n(p, shared.cp + 1u);
    else
      destroy(buf_rng());
  }
  void new_data(const this_t &v) {
    construct_from_range_impl(v);
  }
  void assign_data(const this_t &v) {
    assign_range_impl(v);
  }
  void new_data(this_t &&v) noexcept {
    if (v.local()) {
      p = in_object_data();
      uninitialized_fill(buf_rng(), 0);
      copy(v, p);
      sz = v.sz;
      fill_zero(v.buf_rng());
      v.sz = 0;
    }
    else {
      p = v.p;
      sz = v.sz;
      set_cp(v.shared.cp);
      v.new_data();
    }
  }
  void new_data_individually(this_t &&v) {
    construct_from_range_impl(v);
    if (v.local()) {
      fill_zero(v.buf_rng());
      v.sz = 0;
    }
    else {
      v.delete_n(v.p, v.shared.cp + 1u);
      v.new_data();
    }
  }
  void assign_data_individually(this_t &&v) {
    assign_range_impl(v);
    if (v.local()) {
      fill_zero(v.buf_rng());
      v.sz = 0;
    }
    else {
      v.delete_n(v.p, v.shared.cp + 1u);
      v.new_data();
    }
  }
  void swap_data(this_t &v) noexcept {
    swap_data_impl(v);
  }

  template <bool Y = is_trivially_copyable_v<data_t>>
  enable_if_t<Y> swap_data_impl(this_t &v) noexcept {
    if (this != addressof(v)) {
      alignas(data_t) byte tmp[sizeof(data_t)];
      void *const p1 = static_cast<void *>(addressof(tmp));
      void *const p2 = static_cast<void *>(addressof(static_cast<data_t &>
                                                     (*this)));
      void *const p3 = static_cast<void *>(addressof(static_cast<data_t &>(v)));
      memcpy(p1, p2, sizeof(data_t));
      memcpy(p2, p3, sizeof(data_t));
      memcpy(p3, p1, sizeof(data_t));
      if (p == v.in_object_data())
        p = in_object_data();
      if (v.p == in_object_data())
        v.p = v.in_object_data();
    }
  }
  template <bool Y = is_trivially_copyable_v<data_t>>
  enable_if_t<!Y> swap_data_impl(this_t &v) noexcept {
    if (this == addressof(v))
      return;
    if (local()) {
      if (v.local()) {
        alignas(value_type) byte tmp_buf[sizeof(value_type) * (N + 1u)];
        uninitialized_fully_move
          (buf_rng(), reinterpret_cast<value_type *>(addressof(tmp_buf)));
        v.uninitialized_fully_move(v.buf_rng(), in_object_data());
        uninitialized_fully_move
          (rng(reinterpret_cast<value_type *>(addressof(tmp_buf)),
               N + 1u),
           v.in_object_data());
        adl_swap(sz, v.sz);
      }
      else {
        p = v.p;
        v.p = v.in_object_data();

        adl_swap(sz, v.sz);

        const auto tmp = v.shared.cp;
        uninitialized_fully_move(buf_rng(), v.p);
        set_cp(tmp);
      }
    }
    else {
      if (!v.local()) {
        adl_swap(p, v.p);
        adl_swap(sz, v.sz);
        adl_swap(shared.cp, v.shared.cp);
      }
      else {
        v.p = p;
        p = in_object_data();

        adl_swap(sz, v.sz);

        const auto tmp = shared.cp;
        v.uninitialized_fully_move(v.buf_rng(), p);
        v.set_cp(tmp);
      }
    }
  }

  // reallocate_impl(n):
  //   requires: max_size() >= n >= size()
  void reallocate_impl(size_type n) {
    if (n <= N) {
      if (!local()) {
        const auto cp_bk = shared.cp;
        uninitialized_fill(buf_rng(), 0);
        copy(*this, in_object_data());
        delete_n(p, cp_bk + 1u);
        p = in_object_data();
      }
    }
    else {
      const auto new_p = allocate(n + 1u);
      uninitialized_fill(rng(uninitialized_copy(*this, new_p),
                             new_p + (n + 1u)),
                         0);
      delete_data();
      p = new_p;
      set_cp(n);
    }
  }

  void reserve_space_at_least_1() {
    const size_type cap = local() ? N : shared.cp;
    const size_type rest_n = cap - sz;
    if (rest_n == 0u) {
      if (const size_type cap_rest = max_size() - cap;
          cap_rest != 0u)
        reallocate_impl(cap + ((cap_rest >= cap) ? cap : 1u));
      else
        throw_or_terminate<length_error>("re::sso_string: size overflow "
                                         "in reserve_space_at_least_1()\n");
    }
  }
  template <class UINT>
  void reserve_space_at_least(UINT n) {
    static_assert(is_integral_v<UINT> && is_unsigned_v<UINT>);

    const size_type cap = local() ? N : shared.cp;
    const size_type rest_n = cap - sz;
    if (n > rest_n) {
      n -= rest_n;
      const size_type cap_rest = max_size() - cap;
      if (cap_rest >= n)
        reallocate_impl(cap
                        + ((n < cap && cap_rest >= cap)
                           ? cap : static_cast<size_type>(n)));
      else
        throw_or_terminate<length_error>("re::sso_string: size overflow "
                                         "in reserve_space_at_least(n)\n");
    }
  }

  void push_back_impl(value_type x) {
    if (sz == capacity())
      reserve_space_at_least_1();
    *end() = x;
    ++sz;
  }
  void pop_back_impl() noexcept {
    --sz;
    *end() = 0;
  }
  void pop_back_n_impl(size_type n) noexcept {
    for (; n != 0; --n)
      pop_back_impl();
  }

  pointer insert_impl(const_pointer cpos, value_type x) {
    const auto dif = cpos - p;
    if (sz == capacity())
      reserve_space_at_least_1();
    const auto pos = p + dif;
    const auto i = p + sz;
    copy_backward(rng(pos, i), i + 1);
    ++sz;
    *pos = x;
    return pos;
  }

  pointer erase_impl(const_pointer cpos) noexcept {
    const pointer pos = cpos - p + p;
    copy(rng(pos + 1, end()), pos);
    *(p + --sz) = 0;
    return pos;
  }
  pointer erase_range_impl(const_pointer cfrom,
                           const_pointer cto) noexcept {
    const auto from = cfrom - p + p;
    const auto to = cto - p + p;
    if (from != to) {
      const auto ed = end();
      fill_zero(rng(copy(rng(to, ed), from), ed));
      sz -= (to - from);
    }
    return from;
  }

  template <class IITR_RANGE>
  enable_if_t<rng_is_sized<IITR_RANGE>>
  append_range_impl(IITR_RANGE &&r) {
    reserve_space_at_least(size(r));
    for (auto &i : iters(r))
      push_back(*i);
  }
  template <class IITR_RANGE>
  enable_if_t<!rng_is_sized<IITR_RANGE>>
  append_range_impl(IITR_RANGE &&r) {
    for (auto &i : iters(r))
      push_back(*i);
  }

  template <class IITR_RANGE, class TT = value_type>
  enable_if_t<rng_is_sized<IITR_RANGE> || is_fitr<rng_itr<IITR_RANGE>>, pointer>
  insert_range_impl(const_pointer cpos, IITR_RANGE &&r) {
    const auto k = size(r);
    const auto dif = cpos - p;
    reserve_space_at_least(k);
    const auto pos = p + dif;
    const auto ed = end();
    copy_backward(rng(pos, ed), ed + k);
    sz += k;
    copy(r, pos);
    return pos;
  }
  template <class IITR_RANGE, class TT = value_type>
  enable_if_t<!(rng_is_sized<IITR_RANGE> || is_fitr<rng_itr<IITR_RANGE>>),
              pointer>
  insert_range_impl(const_pointer cpos, IITR_RANGE &&r) {
    const auto dif = cpos - p;
    const auto ed_dif = sz;
    append_range(r);
    const auto pos = p + dif;
    rotate(rng(pos, end()), p + ed_dif);
    return pos;
  }

  template <class SZT>
  void size_check(SZT n) {
    static_assert(is_integral_v<SZT> && is_unsigned_v<SZT>);
    if (to_unsigned(n) > max_size())
      throw_or_terminate<length_error>
        ("re::sso_string: size overflow in size_check(n)\n");
  }

  template <class IITR_RANGE>
  enable_if_t<rng_is_sized<IITR_RANGE>>
  construct_from_range_impl(IITR_RANGE &&r) {
    const auto n = size(r);
    size_check(n);
    if (n <= N) {
      p = in_object_data();
      uninitialized_fill(buf_rng(), 0);
#ifndef RE_NOEXCEPT
      try {
#endif
        copy(r, p);
#ifndef RE_NOEXCEPT
      }
      catch (...) {
        destroy(buf_rng());  
        throw;
      }
#endif
    }
    else {
      set_cp(n);
      p = allocate(shared.cp + 1u);
#ifndef RE_NOEXCEPT
      try {
#endif
      uninitialized_fill(rng(uninitialized_copy(r, p), p + (shared.cp + 1u)),
                         0);
#ifndef RE_NOEXCEPT
      }
      catch (...) {
        deallocate(p, n + 1u);
        throw;
      }
#endif
    }
    sz = n;
  }
  template <class IITR_RANGE>
  enable_if_t<!rng_is_sized<IITR_RANGE>>
  construct_from_range_impl(IITR_RANGE &&r) {
    new_data();
    append_range(r);
  }

  void construct_n_impl(size_type n) {
    if (n <= N) {
      p = in_object_data();
      uninitialized_fill(buf_rng(), 0);
    }
    else {
      set_cp(n);
      p = allocate(shared.cp + 1u);
      uninitialized_fill(rng(p, shared.cp + 1u), 0);
    }
    sz = n;
  }

  template <class IITR_RANGE>
  enable_if_t<rng_is_sized<IITR_RANGE>>
  assign_range_impl(IITR_RANGE &&r) {
    const auto n = size(r);
    size_check(n);
    const size_type cap = capacity();
    if (n > cap) {
      const auto new_p = allocate(n + 1u);
#ifndef RE_NOEXCEPT
      try {
#endif
        uninitialized_fill(rng(uninitialized_copy(r, new_p),
                               new_p + (n + 1u)),
                           0);
#ifndef RE_NOEXCEPT
      }
      catch (...) {
        deallocate(new_p, n + 1u);
        throw;
      }
#endif
      delete_data();
      p = new_p;
      set_cp(n);
    }
    else if (n < sz)
      fill_zero(rng(copy(r, p), end()));
    else
      copy(r, p);
    sz = n;
  }
  template <class IITR_RANGE>
  enable_if_t<!rng_is_sized<IITR_RANGE>>
  assign_range_impl(IITR_RANGE &&r) {
    auto r1 = rng(*this);
    auto r2 = rng(r);
    for (;;) {
      if (empty(r1)) {
        append_range_impl(r2);
        return;
      }
      if (empty(r2)) {
        erase_range_impl(r1.first, r1.second);
        return;
      }
      *r1.first = *r2.first;
      ++r1.first;
      ++r2.first;
    }
  }

  void resize_impl(size_type n) {
    if (n > sz)
      reserve_space_at_least(n - sz);
    else
      fill_zero(rng(p + n, end()));
    sz = n;
  }
  void resize_impl(size_type n, value_type x) {
    if (n > sz) {
      reserve_space_at_least(n - sz);
      fill(rng(end(), p + n), x);
    }
    else
      fill_zero(rng(p + n, end()));
    sz = n;
  }
  void reserve_impl(size_type n) {
    if (n > capacity()) {
      size_check(n);
      reallocate_impl(n);
    }
  }
  void shrink_to_fit_impl() {
    if (capacity() != sz)
      reallocate_impl(sz);
  }

public:
  // container (continued)

  sso_string() noexcept(noexcept(AL())) : sso_string(AL()) {}
  ~sso_string() {
    delete_data();
  }
  sso_string(const sso_string &v)
    : alw_t(alw_t::traits
            ::select_on_container_copy_construction(v.alloc_ref())) {
    new_data(v);
  }
  sso_string &operator =(const sso_string &v) {
    allocator_aware_container_ownership<this_t>::copy_assign(*this, v);
    return *this;
  }
  sso_string(sso_string &&v) noexcept : alw_t(move(v.alloc_ref())) {
    new_data(move(v));
  }
  sso_string &operator =(sso_string &&v)
    noexcept(alloc_move_prpg<AL> || alloc_always_equal<AL>) {
    allocator_aware_container_ownership<this_t>::move_assign(*this, v);
    return *this;
  }
  friend void swap(sso_string &x, sso_string &y)
    noexcept(alloc_swap_prpg<AL> || alloc_always_equal<AL>) {
    allocator_aware_container_ownership<this_t>::swap(x, y);
  }

  // optional container operations

  // reversible container

  using reverse_iterator = re::reverse_iterator<iterator>;
  using const_reverse_iterator = re::reverse_iterator<const_iterator>;

  reverse_iterator rbegin() noexcept {
    return reverse_iterator(end());
  }
  reverse_iterator rend() noexcept {
    return reverse_iterator(begin());
  }
  const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator(begin());
  }
  const_reverse_iterator crbegin() const noexcept {
    return rbegin();
  }
  const_reverse_iterator crend() const noexcept {
    return rend();
  }

  // allocator-aware container

  using allocator_type = AL;
  allocator_type get_allocator() const noexcept {
    return alw_t::get();
  }

  explicit sso_string(const AL &al) noexcept : alw_t(al) {
    new_data();
  }
  sso_string(const sso_string &v, const AL &al) : alw_t(al) {
    new_data(v);
  }
  sso_string(sso_string &&v, const AL &al) : alw_t(al) {
    allocator_aware_container_ownership<this_t>::move_construct(*this, v);
  }

  // sequence container

  explicit sso_string(size_type n, const AL &al = AL{}) : alw_t(al) {
    construct_n_impl(n);
  }
  sso_string(size_type n, value_type t, const AL &al = AL{}) : alw_t(al) {
    construct_from_range_impl(rng(n, ref(t)));
  }
  void assign(size_type n, value_type t) {
    assign_range_impl(rng(n, ref(t)));
  }

  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  sso_string(IITR from, IITR to, const AL &al = AL{}) : alw_t(al) {
    construct_from_range_impl(rng(from, to));
  }
  template <class IITR>
  enable_if_t<is_itr<IITR>> assign(IITR from, IITR to) {
    assign_range_impl(rng(from, to));
  }

  sso_string(initializer_list<value_type> l,
             const AL &al = AL{}) : alw_t(al) {
    construct_from_range_impl(l);
  }
  sso_string &operator =(initializer_list<value_type> l) {
    assign_range_impl(l);
    return *this;
  }
  void assign(initializer_list<value_type> l) {
    assign_range_impl(l);
  }

  iterator insert(const_iterator pos, value_type t) {
    return insert_impl(pos, t);
  }

  iterator insert(const_iterator pos, size_type n, value_type t) {
    return insert_range_impl(pos, rng(n, ref(t)));
  }
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  iterator insert(const_iterator pos, IITR from, IITR to) {
    return insert_range_impl(pos, rng(from, to));
  }
  iterator insert(const_iterator pos, initializer_list<value_type> l) {
    return insert_range_impl(pos, l);
  }

  iterator erase(const_iterator pos) {
    return erase_impl(pos);
  }
  iterator erase(const_iterator from, const_iterator to) {
    return erase_range_impl(from, to);
  }

  void clear() noexcept {
    fill_zero(*this);
    sz = 0;
  }

  // optional sequence container operations

  reference front() {
    return *begin();
  }
  reference back() {
    return *(begin() + sz - 1);
  }
  const_reference front() const {
    return *begin();
  }
  const_reference back() const {
    return *(begin() + sz - 1);
  }

  void push_back(value_type t) {
    push_back_impl(t);
  }
  void pop_back() {
    pop_back_impl();
  }

  reference operator [](size_type n) {
    return begin()[n];
  }
  const_reference operator [](size_type n) const {
    return begin()[n];
  }
  reference at(size_type n) {
    if (n >= size())
      throw_or_terminate<out_of_range>("re::sso_string: at(n) failed\n");
    return begin()[n];
  }
  const_reference at(size_type n) const {
    if (n >= size())
      throw_or_terminate<out_of_range>("re::sso_string: at(n) failed\n");
    return begin()[n];
  }

  // specialized operations

  value_type *data() noexcept {
    return to_address(begin());
  }
  const value_type *data() const noexcept {
    return to_address(begin());
  }
  size_type capacity() const noexcept {
    return local() ? N : shared.cp;
  }
  void resize(size_type n) {
    resize_impl(n);
  }
  void resize(size_type n, value_type t) {
    resize_impl(n, t);
  }
  void reserve(size_type n) {
    reserve_impl(n);
  }
  void shrink_to_fit() {
    shrink_to_fit_impl();
  }

  // extensions

  template <class UF>
  size_type remove_if(UF eq) {
    const auto i = re::remove_if(*this, eq);
    const auto z = end();
    const size_type ret = z - i;
    erase(i, z);
    return ret;
  }
  template <class X>
  size_type remove(const X &x) {
    return remove_if(bind(equal_to<>(), _1, ref(x)));
  }

  bool full() const noexcept {
    return size() == capacity();
  }

  void reallocate(size_type n) {
    if (const auto z = size(); n < z)
      n = z;
    else
      size_check(n);
    reallocate_impl(n);
  }
  void reallocate() {
    reallocate(size());
  }

  void reserve_more(size_type n) {
    reserve_space_at_least(n);
  }

  template <class R>
  iterator replace(const_iterator i1, const_iterator i2, R &&r) {
    return inner::fns::seq_container_replace_impl
      (*this, i1 - begin() + begin(), i2 - begin() + begin(), r);
  }

  template <class R>
  bool assign_unicode(R &&r)
    requires (inner::arg_can_be_utf8string<R>
              && inner::arg_can_be_utf8string_range<this_t>) {
    this_t tmp(get_allocator());
    if (!inner::fns::utf8sprint_utf8(tmp, r))
      return false;
    *this = move(tmp);
    return true;
  }
  template <class R>
  bool assign_unicode(R &&r)
    requires (inner::arg_can_be_utf8string<R>
              && inner::arg_can_be_utf16string_range<this_t>) {
    this_t tmp(get_allocator());
    if (!inner::fns::utf16sprint_utf8(tmp, r))
      return false;
    *this = move(tmp);
    return true;
  }
  template <class R>
  bool assign_unicode(R &&r)
    requires (inner::arg_can_be_utf8string<R>
              && inner::arg_can_be_utf32string_range<this_t>) {
    this_t tmp(get_allocator());
    if (!inner::fns::utf32sprint_utf8(tmp, r))
      return false;
    *this = move(tmp);
    return true;
  }

  template <class R>
  bool assign_unicode(R &&r)
    requires (inner::arg_can_be_utf16string<R>
              && inner::arg_can_be_utf8string_range<this_t>) {
    this_t tmp(get_allocator());
    if (!inner::fns::utf8sprint_utf16(tmp, r))
      return false;
    *this = move(tmp);
    return true;
  }
  template <class R>
  bool assign_unicode(R &&r)
    requires (inner::arg_can_be_utf16string<R>
              && inner::arg_can_be_utf16string_range<this_t>) {
    this_t tmp(get_allocator());
    if (!inner::fns::utf16sprint_utf16(tmp, r))
      return false;
    *this = move(tmp);
    return true;
  }
  template <class R>
  bool assign_unicode(R &&r)
    requires (inner::arg_can_be_utf16string<R>
              && inner::arg_can_be_utf32string_range<this_t>) {
    this_t tmp(get_allocator());
    if (!inner::fns::utf32sprint_utf16(tmp, r))
      return false;
    *this = move(tmp);
    return true;
  }

  template <class R>
  bool assign_unicode(R &&r)
    requires (inner::arg_can_be_utf32string<R>
              && inner::arg_can_be_utf8string_range<this_t>) {
    this_t tmp(get_allocator());
    if (!inner::fns::utf8sprint_utf32(tmp, r))
      return false;
    *this = move(tmp);
    return true;
  }
  template <class R>
  bool assign_unicode(R &&r)
    requires (inner::arg_can_be_utf32string<R>
              && inner::arg_can_be_utf16string_range<this_t>) {
    this_t tmp(get_allocator());
    if (!inner::fns::utf16sprint_utf32(tmp, r))
      return false;
    *this = move(tmp);
    return true;
  }
  template <class R>
  bool assign_unicode(R &&r)
    requires (inner::arg_can_be_utf32string<R>
              && inner::arg_can_be_utf32string_range<this_t>) {
    this_t tmp(get_allocator());
    if (!inner::fns::utf32sprint_utf32(tmp, r))
      return false;
    *this = move(tmp);
    return true;
  }

  template <class R>
  sso_string(from_range_t, R &&r, const allocator_type &a = allocator_type{})
    requires (is_rng<R> && is_constructible_v<value_type, rng_ref<R>>)
    : alw_t(a) {
    construct_from_range_impl(inner::fns::basic_string_select_range<T>(r));
  }
  template <class R, class = enable_if_t
            <!is_same_v<decay_t<R>, this_t>
             && !is_convertible_v<R, const allocator_type &>
             && is_rng<R> && is_constructible_v<value_type, rng_ref<R>>
             && (is_array_v<remove_reference_t<R>>
                 && is_same_v<decay_t<rng_vt<R>>, decay_t<T>>)>>
  sso_string(R &&r) : sso_string(r, allocator_type{}) {}
  template <class R, class = enable_if_t
            <!is_same_v<decay_t<R>, this_t>
             && !is_convertible_v<R, allocator_type>
             && is_rng<R> && is_constructible_v<value_type, rng_ref<R>>
             && !(is_array_v<remove_reference_t<R>>
                  && is_same_v<decay_t<rng_vt<R>>, decay_t<T>>)>,
            class = void>
  explicit sso_string(R &&r) : sso_string(r, allocator_type{}) {}
  template <class R, class = enable_if_t
            <!is_same_v<decay_t<R>, this_t>
             && is_rng<R> && is_constructible_v<value_type, rng_ref<R>>>>
  sso_string(R &&r, const allocator_type &al) : alw_t(al) {
    construct_from_range_impl(inner::fns::basic_string_select_range<T>(r));
  }
  template <class IITR_RANGE>
  enable_if_t<!is_same_v<decay_t<IITR_RANGE>, this_t>
              && is_rng<IITR_RANGE>
              && is_constructible_v<value_type, rng_ref<IITR_RANGE>>, this_t &>
  operator =(IITR_RANGE &&r) {
    assign_range_impl(inner::fns::basic_string_select_range<T>(r));
    return *this;
  }
  template <class IITR_RANGE>
  void assign(IITR_RANGE &&r) {
    assign_range_impl(inner::fns::basic_string_select_range<T>(r));
  }
  template <class IITR_RANGE>
  void assign_range(IITR_RANGE &&r) {
    assign_range_impl(inner::fns::basic_string_select_range<T>(r));
  }

  template <class IITR_RANGE>
  enable_if_t<!is_convertible_v<IITR_RANGE &&, value_type>, iterator>
  insert(const_iterator pos, IITR_RANGE &&r) {
    return insert_range_impl(pos, inner::fns::basic_string_select_range<T>(r));
  }
  template <class IITR_RANGE>
  iterator insert_range(const_iterator pos, IITR_RANGE &&r) {
    return insert_range_impl(pos, inner::fns::basic_string_select_range<T>(r));
  }

  template <class IITR_RANGE>
  enable_if_t<!is_convertible_v<IITR_RANGE &&, value_type>>
  push_back(IITR_RANGE &&r) {
    append_range_impl(inner::fns::basic_string_select_range<T>(r));
  }
  template <class IITR_RANGE>
  void append_range(IITR_RANGE &&r) {
    append_range_impl(inner::fns::basic_string_select_range<T>(r));
  }
  void pop_back(size_type n) {
    pop_back_n_impl(n);
  }

  this_t &append() {
    return *this;
  }
  template <class X, class...S>
  this_t &append(X &&x, S &&...s) {
    push_back(forward<X>(x));
    return append(forward<S>(s)...);
  }
};
template <class T, size_t N, class AL>
bool operator ==(const sso_string<T, N, AL> &x,
                 const sso_string<T, N, AL> &y) {
  return equal(x, y);
}
template <class T, size_t N, class AL>
synth_3way_result<T> operator <=>(const sso_string<T, N, AL> &x,
                                  const sso_string<T, N, AL> &y) {
  return lexicographical_synth_3way(x, y);
}
template <class T, class AL, size_t N, size_t N2>
bool operator ==(const sso_string<T, N, AL> &x, const T (&y)[N2]) {
  return equal(x, inner::fns::basic_string_select_range<T>(y));
}
template <class T, class AL, size_t N, size_t N2>
bool operator ==(const T (&x)[N2], const sso_string<T, N, AL> &y) {
  return equal(inner::fns::basic_string_select_range<T>(x), y);
}
template <class T, class AL, size_t N, size_t N2>
synth_3way_result<T> operator <=>(const sso_string<T, N, AL> &x,
                                  const T (&y)[N2]) {
  return lexicographical_synth_3way
    (x, inner::fns::basic_string_select_range<T>(y));
}
template <class T, class AL, size_t N, size_t N2>
synth_3way_result<T> operator <=>(const T (&x)[N2],
                                  const sso_string<T, N, AL> &y) {
  return lexicographical_synth_3way
    (inner::fns::basic_string_select_range<T>(x), y);
}

using string = sso_string<char, 15u>;
template <class C, class AL = default_allocator<C>>
using default_sso_string = sso_string<C, 15u, AL>;
using wstring = basic_string<wchar_t>;
using u16string = basic_string<char16_t>;
using u32string = basic_string<char32_t>;
template <class T>
using string_t = conditional_t<(is_same_v<T, char>
                                || is_same_v<T, signed char>
                                || is_same_v<T, unsigned char>),
                               sso_string<T, 15u>, basic_string<T>>;
  
template <class AL>
bool operator ==(const basic_string<char, AL> &x,
                 const basic_string<char, AL> &y) {
  return strcmp(x.data(), y.data()) == 0;
}
template <size_t N, class AL>
bool operator ==(const sso_string<char, N, AL> &x,
                 const sso_string<char, N, AL> &y) {
  return strcmp(x.data(), y.data()) == 0;
}
template <class AL>
strong_ordering operator <=>(const basic_string<char, AL> &x,
                             const basic_string<char, AL> &y) {
  const auto tmp = strcmp(x.data(), y.data());
  if (tmp < 0)
    return strong_lt;
  else if (tmp > 0)
    return strong_gt;
  else
    return strong_eq;
}
template <size_t N, class AL>
strong_ordering operator <=>(const sso_string<char, N, AL> &x,
                             const sso_string<char, N, AL> &y) {
  const auto tmp = strcmp(x.data(), y.data());
  if (tmp < 0)
    return strong_lt;
  else if (tmp > 0)
    return strong_gt;
  else
    return strong_eq;
}

template <class T>
class string_reference : range_fns {
  using string_view_t = string_reference<add_const_t<T>>;

  T *p = nullptr;
  size_t n = 0u;

  using range_fns::begin;
  using range_fns::end;
  using range_fns::rbegin;
  using range_fns::rend;
  using range_fns::empty;
  using range_fns::size;

public:
  using pointer = T *;
  using const_pointer = const T *;
  using value_type = remove_cv_t<T>;
  using reference = T &;
  using const_reference = const T &;
  using iterator = T *;
  using const_iterator = const T *;
  using difference_type = ptrdiff_t;
  using size_type = size_t;

  string_reference() = default;
  ~string_reference() = default;
  string_reference(const string_reference &) = default;
  string_reference &operator =(const string_reference &) = default;
  string_reference(string_reference &&) = default;
  string_reference &operator =(string_reference &&) = default;

  string_reference(nullptr_t) : p(nullptr), n(0) {}
  string_reference &operator =(nullptr_t) {
    p = nullptr;
    n = 0;
    return *this;
  }
  void clear() {
    *this = nullptr;
  }

  template <class TT, class = enable_if_t
            <is_same_v<TT, T>
             || (is_const_v<T> && is_same_v<TT, remove_const_t<T>>)>>
  string_reference(TT &x) : p(addressof(x)), n(1) {}
  template <class RANGE, class = enable_if_t
            <!is_same_v<decay_t<RANGE>, string_reference>
             && is_rng<RANGE &&> && !is_array_v<remove_reference_t<RANGE>>
             && is_same_v<rng_vt<RANGE>, value_type>
             && is_citr<rng_itr<RANGE>>
             && is_convertible_v<rng_ref<RANGE>, T>
             && is_convertible_v<rng_ptr<RANGE>, T *>>>
  string_reference(RANGE &&r) : string_reference(begin(r), end(r)) {}
  template <class RANGE, class = enable_if_t
            <!is_same_v<decay_t<RANGE>, string_reference>
             && is_rng<RANGE &&> && is_array_v<remove_reference_t<RANGE>>
             && extent_v<remove_reference_t<RANGE>> != 0u
             && is_convertible_v<rng_ptr<RANGE>, T *>>,
            class = void>
  string_reference(RANGE &&r) noexcept
    : string_reference(begin(r), *(end(r) - 1) != 0 ? end(r) : end(r) - 1) {}

  template <class X, class = enable_if_t
            <is_same_v<itr_vt<X>, value_type> && is_citr<X>
             && is_convertible_v<itr_ref<X>, T>
             && is_convertible_v<itr_ptr<X>, T *>>>
  string_reference(X x, X y) : p(to_address(x)), n(y - x) {}
  template <class X, class Y, class = enable_if_t
            <is_same_v<itr_vt<X>, value_type> && is_citr<X>
             && is_convertible_v<itr_ref<X>, T>
             && is_convertible_v<itr_ptr<X>, T *>
             && is_integral_v<Y>>,
            class = void>
  string_reference(X x, Y y) : p(to_address(x)), n(y) {}
  template <class X, class Y, class Z, class = enable_if_t
            <is_rng<X> && is_same_v<rng_vt<X>, value_type>
             && is_convertible_v<rng_ref<X>, T>
             && is_convertible_v<rng_ptr<X>, T *>
             && is_integral_v<Y> && is_integral_v<Z>>>
  string_reference(X &&x, Y y, Z z) : p(to_address(begin(x) + y)), n(z) {}

  template <class TT = T, class = enable_if_t<is_const_v<TT>>>
  string_reference(const string_reference<remove_const_t<T>> &x) noexcept {
    p = x.p;
    n = x.n;
  }

  template <class X, class TT = T, class = enable_if_t
            <is_same_v<remove_cvref_t<X>, TT *>
             || (is_const_v<TT>
                 && is_same_v<remove_reference_t<X>, remove_const_t<TT> *>)>,
            bool = 0>
  string_reference(X &&s) noexcept {
    if constexpr (is_same_v<remove_const_t<T>, char>
                  || is_same_v<remove_const_t<T>, unsigned char>) {
      p = s;
      n = strlen(p);
    }
    else {
      p = s;
      for (; *s != 0; ++s)
        ;
      n = s - p;
    }
  }

  T *begin() const noexcept {
    return p;
  }
  T *end() const noexcept {
    return p + n;
  }
  size_t size() const noexcept {
    return n;
  }
  bool empty() const noexcept {
    return n == 0;
  }

  T *data() const noexcept {
    return p;
  }

  const T *cbegin() const noexcept {
    return begin();
  }
  const T *cend() const noexcept {
    return end();
  }

  reference operator [](size_type nn) noexcept {
    return p[nn];
  }
  const_reference operator [](size_type nn) const noexcept {
    return p[nn];
  }
  reference at(size_type nn) {
    if (nn >= size())
      throw_or_terminate<out_of_range>("re::string_reference: at(n) failed\n");
    return p[nn];
  }
  const_reference at(size_type nn) const {
    if (nn >= size())
      throw_or_terminate<out_of_range>("re::string_reference: at(n) failed\n");
    return p[nn];
  }
  reference front() {
    return *p;
  }
  reference back() {
    return *(p + n - 1);
  }
  const_reference front() const {
    return *p;
  }
  const_reference back() const {
    return *(p + n - 1);
  }

  using reverse_iterator = re::reverse_iterator<iterator>;
  using const_reverse_iterator = re::reverse_iterator<const_iterator>;

  reverse_iterator rbegin() noexcept {
    return reverse_iterator(end());
  }
  reverse_iterator rend() noexcept {
    return reverse_iterator(begin());
  }
  const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator(begin());
  }
  const_reverse_iterator crbegin() const noexcept {
    return rbegin();
  }
  const_reverse_iterator crend() const noexcept {
    return rend();
  }
};
template <class T1, class T2>
enable_if_t<is_same_v<remove_const_t<T1>, remove_const_t<T2>>, bool>
operator ==(const string_reference<T1> &x,
            const string_reference<T2> &y) noexcept {
  if constexpr (!is_same_v<remove_const_t<T1>, char>) {
    return equal(x, y);
  }
  else {
    return x.size() == y.size() && memcmp(x.begin(), y.begin(), x.size()) == 0;
  }
}
template <class T1, class T2>
enable_if_t<is_same_v<remove_const_t<T1>, remove_const_t<T2>>,
            synth_3way_result<T1, T2>>
operator <=>(const string_reference<T1> &x,
             const string_reference<T2> &y) noexcept {
  if constexpr (!is_same_v<remove_const_t<T1>, char>) {
    return lexicographical_synth_3way(x, y);
  }
  else {
    const auto x_sz = x.size();
    const auto y_sz = y.size();
    if (x_sz == y_sz) {
      const auto c = memcmp(x.begin(), y.begin(), x.size());
      if (c < 0)
        return strong_lt;
      else if (c > 0)
        return strong_gt;
      else
        return strong_eq;
    }
    else if (x_sz < y_sz) {
      const auto c = memcmp(x.begin(), y.begin(), x.size());
      return (c <= 0) ? strong_lt : strong_gt;
    }
    else {
      const auto c = memcmp(y.begin(), x.begin(), y.size());
      return (c <= 0) ? strong_gt : strong_lt;
    }
  }
}

template <class T, size_t N>
bool operator ==(const string_reference<const T> &x, const T (&y)[N]) {
  return x == string_reference<const T>(y);
}
template <class T, size_t N>
bool operator ==(const T (&y)[N], const string_reference<const T> &x) {
  return x == y;
}
template <class T, size_t N>
synth_3way_result<T> operator <=>(const string_reference<const T> &x,
                                  const T (&y)[N]) {
  return x <=> string_reference<const T>(y);
}
template <class T, size_t N>
synth_3way_result<T> operator <=>(const T (&x)[N],
                                  const string_reference<const T> &y) {
  return string_reference<const T>(x) <=> y;
}

template <class T, class AL, class T2>
enable_if_t<is_same_v<remove_const_t<T2>, T>, bool>
operator ==(const basic_string<T, AL> &x,
            const string_reference<T2> &y) {
  return string_reference<const T>(x) == y;
}
template <class T, class AL, class T2>
enable_if_t<is_same_v<remove_const_t<T2>, T>, bool>
operator ==(const string_reference<T2> &y,
            const basic_string<T, AL> &x) {
  return x == y;
}
template <class T, class AL, class T2>
enable_if_t<is_same_v<remove_const_t<T2>, T>, synth_3way_result<T, T2>>
operator <=>(const basic_string<T, AL> &x,
             const string_reference<T2> &y) {
  return string_reference<const T>(x) <=> y;
}
template <class T, class AL, class T2>
enable_if_t<is_same_v<remove_const_t<T2>, T>, synth_3way_result<T2, T>>
operator <=>(const string_reference<T2> &x,
             const basic_string<T, AL> &y) {
  return x <=> string_reference<const T>(y);
}

template <class T, size_t N, class AL, class T2>
enable_if_t<is_same_v<remove_const_t<T2>, T>, bool>
operator ==(const sso_string<T, N, AL> &x,
            const string_reference<T2> &y) {
  return string_reference<const T>(x) == y;
}
template <class T, size_t N, class AL, class T2>
enable_if_t<is_same_v<remove_const_t<T2>, T>, bool>
operator ==(const string_reference<T2> &y,
            const sso_string<T, N, AL> &x) {
  return x == y;
}
template <class T, size_t N, class AL, class T2>
enable_if_t<is_same_v<remove_const_t<T2>, T>, synth_3way_result<T, T2>>
operator <=>(const sso_string<T, N, AL> &x,
             const string_reference<T2> &y) {
  return string_reference<const T>(x) <=> y;
}
template <class T, size_t N, class AL, class T2>
enable_if_t<is_same_v<remove_const_t<T2>, T>, synth_3way_result<T2, T>>
operator <=>(const string_reference<T2> &x,
             const sso_string<T, N, AL> &y) {
  return x <=> string_reference<const T>(y);
}

inline string operator ""_s(const char *s, size_t n) {
  return string(sview(s, n));
}
inline wstring operator ""_s(const wchar_t *s, size_t n) {
  return wstring(wsview(s, n));
}
inline u16string operator ""_s(const char16_t *s, size_t n) {
  return u16string(u16sview(s, n));
}
inline u32string operator ""_s(const char32_t *s, size_t n) {
  return u32string(u32sview(s, n));
}

inline sview operator ""_sv(const char *s, size_t n) {
  return sview(s, n);
}
inline wsview operator ""_sv(const wchar_t *s, size_t n) {
  return wsview(s, n);
}
inline u16sview operator ""_sv(const char16_t *s, size_t n) {
  return u16sview(s, n);
}
inline u32sview operator ""_sv(const char32_t *s, size_t n) {
  return u32sview(s, n);
}

template <class T, class AL>
struct less<basic_string<T, AL>> {
  using is_transparent = inner::transparent_tag;

  bool operator ()(const basic_string<T, AL> &x,
                   const basic_string<T, AL> &y) const noexcept {
    return x < y;
  }
  bool operator ()(string_reference<const T> x,
                   string_reference<const T> y) const noexcept {
    return x < y;
  }
  template <class R1, class R2>
  enable_if_t<is_array_v<remove_reference_t<R1>>
              || is_array_v<remove_reference_t<R2>>, bool>
  operator ()(R1 &&x, R2 &&y) const noexcept {
    return string_reference<const T>(x) < string_reference<const T>(y);
  }
};
template <class T, size_t N, class AL>
struct less<sso_string<T, N, AL>> {
  using is_transparent = inner::transparent_tag;

  bool operator ()(const sso_string<T, N, AL> &x,
                   const sso_string<T, N, AL> &y) const noexcept {
    return x < y;
  }
  bool operator ()(string_reference<const T> x,
                   string_reference<const T> y) const noexcept {
    return x < y;
  }
  template <class R1, class R2>
  enable_if_t<is_array_v<remove_reference_t<R1>>
              || is_array_v<remove_reference_t<R2>>, bool>
  operator ()(R1 &&x, R2 &&y) const noexcept {
    return string_reference<const T>(x) < string_reference<const T>(y);
  }
};

template <class T, class AL>
struct equal_to<basic_string<T, AL>> {
  using is_transparent = inner::transparent_tag;

  bool operator ()(const basic_string<T, AL> &x,
                   const basic_string<T, AL> &y) const noexcept {
    return x == y;
  }
  bool operator ()(string_reference<const T> x,
                   string_reference<const T> y) const noexcept {
    return x == y;
  }
  template <class R1, class R2>
  enable_if_t<is_array_v<remove_reference_t<R1>>
              || is_array_v<remove_reference_t<R2>>, bool>
  operator ()(R1 &&x, R2 &&y) const noexcept {
    return string_reference<const T>(x) == string_reference<const T>(y);
  }
};
template <class T, size_t N, class AL>
struct equal_to<sso_string<T, N, AL>> {
  using is_transparent = inner::transparent_tag;

  bool operator ()(const sso_string<T, N, AL> &x,
                   const sso_string<T, N, AL> &y) const noexcept {
    return x == y;
  }
  bool operator ()(string_reference<const T> x,
                   string_reference<const T> y) const noexcept {
    return x == y;
  }
  template <class R1, class R2>
  enable_if_t<is_array_v<remove_reference_t<R1>>
              || is_array_v<remove_reference_t<R2>>, bool>
  operator ()(R1 &&x, R2 &&y) const noexcept {
    return string_reference<const T>(x) == string_reference<const T>(y);
  }
};

template <class T, class AL>
struct hash<basic_string<T, AL>> {
  using is_transparent = inner::transparent_tag;
  using argument_type = basic_string<T, AL>;
  using result_type = size_t;
  size_t operator ()(string_reference<const T> x) const noexcept {
    return inner::fns::byte_array_hash(static_cast<const void *>(x.data()),
                                       x.size() * sizeof(T));
  }
};
template <class T, size_t N, class AL>
struct hash<sso_string<T, N, AL>> {
  using is_transparent = inner::transparent_tag;
  using argument_type = sso_string<T, N, AL>;
  using result_type = size_t;
  size_t operator ()(string_reference<const T> x) const noexcept {
    return inner::fns::byte_array_hash(static_cast<const void *>(x.data()),
                                       x.size() * sizeof(T));
  }
};

template <class T>
struct less<string_reference<T>> {
  using is_transparent = inner::transparent_tag;

  bool operator ()(const string_reference<T> &x,
                   const string_reference<T> &y) const noexcept {
    return x < y;
  }
};
template <class T>
struct equal_to<string_reference<T>> {
  using is_transparent = inner::transparent_tag;

  bool operator ()(const string_reference<T> &x,
                   const string_reference<T> &y) const noexcept {
    return x == y;
  }
};
template <class T>
struct hash<string_reference<T>> {
  using is_transparent = inner::transparent_tag;
  using argument_type = string_reference<T>;
  using result_type = size_t;
  size_t operator ()(string_reference<T> x) const noexcept {
    return inner::fns::byte_array_hash(static_cast<const void *>(x.data()),
                                       x.size() * sizeof(T));
  }
};

}

// bitset
namespace re {

template <size_t>
class bitset;
template <size_t N>
struct hash<bitset<N>> {
  using argument_type = bitset<N>;
  using result_type = size_t;
  size_t operator ()(const bitset<N> &x) const noexcept {
    return inner::fns::byte_array_hash
      (static_cast<const void *>(begin(x.v)),
       size(x.v) * sizeof(rng_vt<decltype(x.v)>));
  }
};
namespace inner {

template <class UINT = unsigned long long>
class bitset_reference {
  template <size_t>
  friend class re::bitset;

  using uint = UINT;

  uint *p;
  uint n;

  bitset_reference() noexcept = default;
public:
  ~bitset_reference() noexcept = default;
  bitset_reference(const bitset_reference &) = default;
  constexpr bitset_reference &operator =(const bitset_reference &x) {
    return operator =(x.operator bool());
  }
  bitset_reference(bitset_reference &&) = default;
  constexpr bitset_reference &operator =(bitset_reference &&x) {
    return operator =(static_cast<const bitset_reference &>(x));
  }
  friend constexpr void swap(bitset_reference x,
                             bitset_reference y) noexcept {
    if (x.operator bool() != y.operator bool()) {
      x.flip();
      y.flip();
    }
  }

  constexpr bitset_reference &operator =(bool x) noexcept {
    if (x)
      *p |= (uint)((uint)1 << n);
    else
      *p &= (uint)~(uint)((uint)1 << n);
    return *this;
  }

  constexpr operator bool() const noexcept {
    return *p & (uint)((uint)1 << n);
  }
  constexpr bool operator ~() const noexcept {
    return !operator bool();
  }

  constexpr bitset_reference &flip() noexcept {
    *p ^= (uint)((uint)1 << n);
    return *this;
  }
};

}
template <size_t N>
class bitset : range_fns {
  friend struct hash<bitset>;

  using range_fns::begin;
  using range_fns::end;
  using range_fns::rbegin;
  using range_fns::rend;
  using range_fns::empty;
  using range_fns::size;

  template <class X>
  using bitset_reference = inner::bitset_reference<X>;

  using uint = unsigned long long;

  static constexpr size_t bits_of_uint = (sizeof(uint) * 8u);

  using sz = size_constant
    <N / bits_of_uint + (size_t)(N % bits_of_uint != 0)>;
  using actual_sz = conditional_t<sz::value == 0u, size_constant<1>, sz>;
  uint v[actual_sz::value];

  constexpr void reset_tail() noexcept {}
  constexpr void reset_tail() noexcept requires (N == 0u) {
    v[0] = 0u;
  }
  constexpr void reset_tail() noexcept requires (N % bits_of_uint != 0u) {
    v[actual_sz::value - 1]
      &= ((uint)(~(uint)0) >> (uint)(bits_of_uint - (N % bits_of_uint)));
  }

  struct fn_binding_const {
    const bitset *p;

    bool operator ()(size_t i) const noexcept {
      return (*p)[i];
    }
  };
  struct fn_binding {
    bitset *p;

    bitset_reference<uint> operator ()(size_t i) const noexcept {
      return (*p)[i];
    }

    operator fn_binding_const() const {
      return {p};
    }
  };

public:
  constexpr bitset() noexcept : v{} {}
  ~bitset() = default;
  bitset(const bitset &) = default;
  bitset &operator =(const bitset &) = default;
  bitset(bitset &&) = default;
  bitset &operator =(bitset &&) = default;
  friend constexpr void swap(bitset &x, bitset &y) noexcept {
    default_swap(x, y);
  }

  constexpr bool operator ==(const bitset &x) const noexcept {
    return memcmp(begin(v), begin(x.v), sizeof(v)) == 0;
  }
  constexpr auto operator <=>(const bitset &x) const noexcept {
    return lexicographical_synth_3way(*this, x);
  }

  constexpr bitset(unsigned long long x) noexcept : v{} {
    v[0] = x;
    if (actual_sz::value == 1)
      reset_tail();
  }
  constexpr bitset &operator =(unsigned long long x) noexcept {
    reset();
    v[0] = x;
    if (actual_sz::value == 1)
      reset_tail();
    return *this;
  }

  template<class STRING>
  constexpr explicit bitset(const STRING &s,
                            typename STRING::size_type pos = 0,
                            typename STRING::size_type n = -1,
                            typename STRING::value_type zero
                            = typename STRING::value_type('0'),
                            typename STRING::value_type one
                            = typename STRING::value_type('1'))
    : bitset(s.data() + pos, n, zero, one) {}
  template <class C>
  constexpr explicit bitset(const C *s, size_t n = -1,
                            C zero = C('0'), C one = C('1')) : v{} {
    if (n == static_cast<size_t>(-1)) {
      n = 0;
      for (auto p = s; *p != 0; ++p)
        ++n;
    }
    for (decltype(auto) x : rrng(begin(), min(n, N))) {
      if (*s == one)
        x = true;
      else if (*s != zero)
        throw_or_terminate<invalid_argument>
          ("re::bitset: invalid string in constructor\n");
      else
        x = false;
      ++s;
    }
  }
  constexpr unsigned long long to_ullong() const {
    if (!all_of_equal(rng(nth(v, 1), end(v)), 0u))
      throw_or_terminate<overflow_error>("re::bitset: to_ullong() failed\n");
    return v[0];
  }
  template <bool Y = (sizeof(unsigned long long) != sizeof(unsigned long))>
  constexpr enable_if_t<Y, unsigned long> to_ulong() const {
    size_t n = (sizeof(unsigned long long) - sizeof(unsigned long)) * 8;
    if (!all_of_equal(rng(v + 1, actual_sz::value - 1), uint(0))
        || (v[0] >> (uint)(sizeof(unsigned long) * 8)) != 0)
      throw_or_terminate<overflow_error>("re::bitset: to_ulong() failed\n");
    return static_cast<unsigned long>(v[0]);
  }
  template <bool Y = (sizeof(unsigned long long) != sizeof(unsigned long))>
  constexpr enable_if_t<!Y, unsigned long> to_ulong() const {
    return to_ullong();
  }
  template <class STRING>
  constexpr STRING to(typename STRING::value_type zero
                      = typename STRING::value_type('0'),
                      typename STRING::value_type one
                      = typename STRING::value_type('1')) const {
    STRING s;
    for (bool x : rrng(*this))
      s.push_back(x ? one : zero);
    return s;
  }
  constexpr auto to_string(char zero = '0', char one = '1') const {
    return to<string>(zero, one);
  }
  template <class OITR>
  void print(OITR o, char zero = '0', char one = '1') const {
    size_t c = 0;
    const size_t cc = sizeof(uint) * 8;
    const uint *p = v;
    uint x = *p;
    for (size_t n = N; n; --n) {
      if (c == cc) {
        c = 0;
        x = *++p;
      }
      *o = (bool)((uint)(x >> (uint)c) & (uint)1) ? '1' : '0';
      ++o;
      ++c;
    }
  }
  void print() const {
    print(output_itr([](int c) {putchar(c);}));
  }

  using pointer = bitset_reference<uint> *;
  using const_pointer = const bitset_reference<uint> *;
  using value_type = bool;
  using reference = bitset_reference<uint>;
  using const_reference = bool;
  using iterator = bind_iterator<iterator_iterator<size_t>, fn_binding>;
  using const_iterator = bind_iterator<iterator_iterator<size_t>,
                                       fn_binding_const>;
  using difference_type = ptrdiff_t;
  using size_type = size_t;

  constexpr bool empty() const noexcept {
    return N == 0u;
  }
  constexpr size_t size() const noexcept {
    return N;
  }
  constexpr size_t max_size() const noexcept {
    return N;
  }

  constexpr bool operator [](size_t pos) const {
    constexpr size_t n = (sizeof(uint) * 8);
    return v[pos / n] & (uint)((uint)1 << (uint)(pos % n));
  }
  constexpr reference operator [](size_t pos) {
    reference r;
    constexpr size_t n = (sizeof(uint) * 8);
    r.p = v + pos / n;
    r.n = pos % n;
    return r;
  }
  constexpr bool at(size_t n) const {
    if (n >= size())
      throw_or_terminate<out_of_range>("re::bitset: at(n) failed\n");
    return operator [](n);
  }
  constexpr reference at(size_t n) {
    if (n >= size())
      throw_or_terminate<out_of_range>("re::bitset: at(n) failed\n");
    return operator [](n);
  }

  constexpr iterator begin() noexcept {
    return iterator(iterator_iterator<size_t>(0), fn_binding{this});
  }
  constexpr iterator end() noexcept {
    return iterator(iterator_iterator<size_t>(N), fn_binding{this});
  }
  constexpr const_iterator begin() const noexcept {
    return const_iterator(iterator_iterator<size_t>(0),
                          fn_binding_const{this});
  }
  constexpr const_iterator end() const noexcept {
    return const_iterator(iterator_iterator<size_t>(N),
                          fn_binding_const{this});
  }
  constexpr const_iterator cbegin() const noexcept {
    return begin();
  }
  constexpr const_iterator cend() const noexcept {
    return end();
  }

  using reverse_iterator = re::reverse_iterator<iterator>;
  using const_reverse_iterator = re::reverse_iterator<const_iterator>;

  constexpr reverse_iterator rbegin() noexcept {
    return reverse_iterator(end());
  }
  constexpr reverse_iterator rend() noexcept {
    return reverse_iterator(begin());
  }
  constexpr const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  constexpr const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator(begin());
  }
  constexpr const_reverse_iterator crbegin() const noexcept {
    return rbegin();
  }
  constexpr const_reverse_iterator crend() const noexcept {
    return rend();
  }

  constexpr bitset<N> &set() noexcept {
    for (uint &x : v)
      x = ~(uint)0;
    reset_tail();
    return *this;
  }
  constexpr bitset<N> &set(size_t pos, bool val = true) {
    if (pos >= N)
      throw_or_terminate<out_of_range>("re::bitset: set(pos, val) failed\n");
    operator [](pos) = val;
    return *this;
  }
  constexpr bitset<N> &reset() noexcept {
    for (uint &x : v)
      x = 0;
    return *this;
  }
  constexpr bitset<N> &reset(size_t pos) {
    if (pos >= N)
      throw_or_terminate<out_of_range>("re::bitset: reset(pos) failed\n");
    operator [](pos) = false;
    return *this;
  }

  constexpr size_t count() const noexcept {
    size_t ret = 0;
    for (uint x : v) {
      for (int c = sizeof(uint) * 8; c != 0; --c) {
        ret += ((uint)(x & (uint)1) != 0);
        x >>= (uint)1;
      }
    }
    return ret;
  }
  constexpr bitset<N> operator ~() const noexcept {
    return copy(*this).flip();
  }
  constexpr bitset<N> &flip() noexcept {
    for (uint &x : v)
      x = ~x;
    reset_tail();
    return *this;
  }
  constexpr bitset<N> &flip(size_t pos) {
    if (pos >= N)
      throw_or_terminate<out_of_range>("re::bitset: flip(pos) failed\n");
    operator [](pos).flip();
    return *this;
  }
  constexpr bool test(size_t pos) const {
    if (pos >= N)
      throw_or_terminate<out_of_range>("re::bitset: test(pos) failed\n");
    return operator [](pos);
  }
  template <bool Y = (N % (sizeof(uint) * 8) == 0u)>
  constexpr enable_if_t<Y, bool> all() const noexcept {
    return all_of_equal(v, (uint)~uint(0));
  }
  template <bool Y = (N % (sizeof(uint) * 8) == 0u)>
  constexpr enable_if_t<!Y, bool> all() const noexcept {
    const uint max_val = (uint)~(uint)0;
    if (!all_of_equal(rng(begin(v), prev(end(v))), max_val))
      return false;
    return (uint)(back(v) | (uint)(max_val << (uint)(N % bits_of_uint)))
      == max_val;
  }
  constexpr bool any() const noexcept {
    return !all_of_equal(v, 0u);
  }
  constexpr bool none() const noexcept {
    return all_of_equal(v, 0u);
  }

  constexpr bitset &operator &=(const bitset &x) noexcept {
    for_each(v, begin(x.v), [](uint &a, const uint &b) {a &= b;});
    return *this;
  }
  constexpr bitset &operator |=(const bitset &x) noexcept {
    for_each(v, begin(x.v), [](uint &a, const uint &b) {a |= b;});
    return *this;
  }
  constexpr bitset &operator ^=(const bitset &x) noexcept {
    for_each(v, begin(x.v), [](uint &a, const uint &b) {a ^= b;});
    return *this;
  }
  constexpr bitset &operator <<=(size_t n) noexcept {
    if (n >= N)
      return reset();
    const size_t d = n / bits_of_uint;
    const size_t r = n % bits_of_uint;
    if (d != 0) {
      for (auto &p : r_iters(begin(v) + d, end(v)))
        *p = *(p - d);
      for (auto &x : rng(begin(v), d))
        x = 0;
    }
    if (r != 0) {
      uint tmp = 0;
      for (uint &x : rng(v + d, end(v))) {
        const uint tmp2 = x >> (uint)(bits_of_uint - r);
        x = (uint)(x << (uint)r) | tmp;
        tmp = tmp2;
      }
    }
    reset_tail();
    return *this;
  }
  constexpr bitset &operator >>=(size_t n) noexcept {
    if (n >= N)
      return reset();
    const size_t d = n / bits_of_uint;
    const size_t r = n % bits_of_uint;
    if (d != 0) {
      for (auto &p : iters(begin(v), end(v) - d))
        *p = *(p + d);
      for (auto &x : rng(end(v) - d, end(v)))
        x = 0;
    }
    if (r != 0) {
      uint tmp = 0;
      for (uint &x : rrng(v, end(v) - d)) {
        const uint tmp2 = x << (uint)(bits_of_uint - r);
        (x >>= (uint)r) |= tmp;
        tmp = tmp2;
      }
    }
    reset_tail();
    return *this;
  }
  constexpr bitset operator <<(size_t n) const noexcept {
    return copy(*this) <<= n;
  }
  constexpr bitset operator >>(size_t n) const noexcept {
    return copy(*this) >>= n;
  }
};

}

// vector
// local_vector
// small_vector
// pointer_vector
namespace re {

template <class, class>
class pointer_vector;

namespace inner {

template <class AL>
struct vector_data {
  alloc_ptr<AL> op;
  alloc_ptr<AL> now;
  alloc_ptr<AL> ed;
};

}
template <class T, class AL = default_allocator<T>>
class vector : inner::vector_data<AL>, allocator_wrapper<AL> {
  static_assert(is_same_v<T, alloc_vt<AL>>);

  template <class, class>
  friend class pointer_vector;

  using this_t = vector;

  using data_t = inner::vector_data<AL>;
  using data_t::op;
  using data_t::ed;
  using data_t::now;

  using alw_t = allocator_wrapper<AL>;
  using alw_t::allocate;
  using alw_t::construct;
  using alw_t::destroy;
  using alw_t::deallocate;
  using alw_t::destroy_fn;
  using alw_t::new_1;
  using alw_t::new_n;
  using alw_t::delete_1;
  using alw_t::delete_n;
  using alw_t::make_temporary;
  using alw_t::uninitialized_fill;
  using alw_t::uninitialized_copy;
  using alw_t::uninitialized_move;
  using alw_t::uninitialized_fully_move;
  using alw_t::fully_move;

  template <class R>
  static auto begin(R &&r) {return re::begin(r);}
  template <class R>
  static auto end(R &&r) {return re::end(r);}
  template <class R>
  static auto rbegin(R &&r) {return re::rbegin(r);}
  template <class R>
  static auto rend(R &&r) {return re::rend(r);}
  template <class R>
  static auto size(R &&r) {return re::size(r);}
  template <class R>
  static auto empty(R &&r) {return re::empty(r);}

public:
  using pointer = alloc_ptr<AL>;
  using const_pointer = alloc_cptr<AL>;

  // container

  using value_type = T;
  using reference = value_type &;
  using const_reference = const value_type &;

  using iterator = pointer;
  using const_iterator = const_pointer;
  using difference_type = alloc_dft<AL>;
  using size_type = alloc_szt<AL>;

  iterator begin() noexcept {
    return op;
  }
  iterator end() noexcept {
    return now;
  }
  const_iterator begin() const noexcept {
    return op;
  }
  const_iterator end() const noexcept {
    return now;
  }
  const_iterator cbegin() const noexcept {
    return begin();
  }
  const_iterator cend() const noexcept {
    return end();
  }

  size_type max_size() const noexcept {
    return container_regular_max_size<this_t>();
  }
  size_type size() const noexcept {
    return now - op;
  }
  bool empty() const noexcept {
    return now == op;
  }

private:
  // inner implements

  friend class allocator_aware_container_ownership<this_t>;
  const AL &alloc_ref() const noexcept {
    return alw_t::get();
  }
  AL &alloc_ref() noexcept {
    return alw_t::get();
  }
  void new_data() noexcept {
    op = ed = now = nullptr;
  }
  void delete_data() noexcept {
    destroy(*this);
    deallocate();
  }
  void new_data(const this_t &v) {
    construct_from_range_impl(v);
  }
  void assign_data(const this_t &v) {
    assign_range_impl(v);
  }
  void new_data(this_t &&v) noexcept {
    data_t::operator =(static_cast<data_t &&>(v));
    v.new_data();
  }
  void new_data_individually(this_t &&v) {
    const size_type v_n = v.size();
    if (v_n == 0u) {
      new_data();
      v.deallocate();
      v.new_data();
      return;
    }
    op = allocate(v_n);
    ed = op + v_n;
#ifndef RE_NOEXCEPT
    try {
#endif
      now = uninitialized_fully_move(v, op, v.destroy_fn());
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      deallocate(op, v_n);
      throw;
    }
#endif
    v.deallocate();
    v.new_data();
  }
  void assign_data_individually(this_t &&v) {
    const size_type v_n = v.size();
    if (v_n == 0u) {
      delete_data();
      new_data();
      v.deallocate();
      v.new_data();
    }
    else if (v_n > to_unsigned(ed - op)) {
      delete_data();
#ifndef RE_NOEXCEPT
      try {
#endif
        new_data_individually(move(v));
#ifndef RE_NOEXCEPT
      }
      catch (...) {
        new_data();
        throw;
      }
#endif
    }
    else {
      const size_type this_n = size();
      if (v_n < this_n) {
        const auto it = fully_move(v, op, v.destroy_fn());
        destroy(rng(it, now));
        now = it;
      }
      else {
        const pointer v_mid = v.op + this_n;
        now = uninitialized_fully_move(rng(v_mid, v.now), now, v.destroy_fn());
        v.now = v_mid;
        fully_move(v, op, v.destroy_fn());
      }
      v.deallocate();
      v.new_data();
    }
  }
  void swap_data(this_t &v) noexcept {
    adl_swap(op, v.op);
    adl_swap(now, v.now);
    adl_swap(ed, v.ed);
  }
  void swap_data_individually(this_t &v) {
    const size_type n = size();
    const size_type nn = ed - op;
    const size_type v_n = v.size();
    const size_type v_nn = v.ed - v.op;
    if (nn < v_n)
      reallocate_impl(v_n);
    else if (v_nn < n)
      v.reallocate_impl(n);
    if (n < v_n) {
      const pointer v_mid = swap_ranges(*this, v.op);
      now = uninitialized_fully_move(rng(v_mid, v.now), now, v.destroy_fn());
      v.now = v_mid;
    }
    else {
      const auto mid = swap_ranges(v, op);
      v.now = v.uninitialized_fully_move(rng(mid, now), v.now, destroy_fn());
      now = mid;
    }
  }

  void deallocate() noexcept {
    if (op != ed)
      deallocate(op, ed - op);
  }

  // reallocate_impl(n):
  //   requires: max_size() >= n >= now - op && n > 0
  void reallocate_impl(size_type n) {
    const auto p = allocate(n);
    pointer pp;
#ifndef RE_NOEXCEPT
    try {
#endif
      pp = uninitialized_fully_move(*this, p);
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      deallocate(p, n);
      throw;
    }
#endif
    deallocate();
    op = p;
    now = pp;
    ed = p + n;
  }

  template <class UINT>
  void reserve_raw_space_at_least(UINT n) {
    static_assert(is_integral_v<UINT> && is_unsigned_v<UINT>);
    const size_type rest_n = ed - now;
    if (n > rest_n) {
      n -= rest_n;
      const size_type cp = ed - op;
      const size_type cp_rest = max_size() - cp;
      if (cp_rest >= n)
        reallocate_impl((n < cp && cp_rest >= cp) ? (cp + cp) : (cp + n));
      else
        throw_or_terminate<length_error>("re::vector: size overflow in "
                                         "reserve_raw_space_at_least(n)\n");
    }
  }
  void increase_capacity_at_least_1() {
    size_type n;
    if (op == ed)
      n = 1;
    else {
      const size_type cp = ed - op;
      const size_type cp_rest = max_size() - cp;
      if (cp_rest >= cp)
        n = cp + cp;
      else {
        if (cp_rest == 0u)
          throw_or_terminate<length_error>("re::vector: size overflow in "
                                           "increase_capacity_at_least_1()\n");
        n = max_size();
      }
    }
    reallocate_impl(n);
  }

  template <class...S>
  reference emplace_back_impl(S &&...s) {
    if (now == ed) {
      auto tmp = make_temporary(forward<S>(s)...);
      increase_capacity_at_least_1();
      construct(to_address(now), move(*tmp));
    }
    else
      construct(to_address(now), forward<S>(s)...);
    auto &ret = *now;
    ++now;
    return ret;
  }
  void pop_back_impl() noexcept {
    destroy(to_address(--now));
  }
  void pop_back_n_impl(size_type n) noexcept {
    for (; n != 0; --n)
      destroy(to_address(--now));
  }

  template <class...S>
  pointer emplace_impl(const_pointer cpos, S &&...s) {
    auto tmp = make_temporary(forward<S>(s)...);
    auto pos = cpos - op + op;
    if (now == ed) {
      const auto dif = pos - op;
      increase_capacity_at_least_1();
      pos = op + dif;
    }
    if (pos == now) {
      construct(to_address(now), move(*tmp));
      ++now;
    }
    else {
      construct(to_address(now), move(*(now - 1)));
      ++now;
      move_backward(rng(pos, now - 2), now - 1);
      *pos = move(*tmp);
    }
    return pos;
  }

  pointer erase_impl(const_pointer cpos) noexcept {
    const auto pos = cpos - op + op;
    move(rng(pos + 1, now), pos);
    destroy(to_address(--now));
    return pos;
  }
  pointer erase_range_impl(const_pointer cfrom,
                           const_pointer cto) noexcept {
    const pointer from = cfrom - op + op;
    const pointer to = cto - op + op;
    if (from != to) {
      const auto mid = move(rng(to, now), from);
      destroy(rng(mid, now));
      now = mid;
    }
    return from;
  }

  template <class IITR_RANGE>
  enable_if_t<rng_is_sized<IITR_RANGE>>
  append_range_impl(IITR_RANGE &&r) {
    reserve_raw_space_at_least(size(r));
    now = uninitialized_copy(r, now);
  }
  template <class IITR_RANGE>
  enable_if_t<!rng_is_sized<IITR_RANGE>>
  append_range_impl(IITR_RANGE &&r) {
    for (auto &p : iters(r))
      emplace_back_impl(*p);
  }

  template <class IITR_RANGE, class TT = value_type>
  enable_if_t<rng_is_sized<IITR_RANGE> || is_fitr<rng_itr<IITR_RANGE>>, pointer>
  insert_range_impl(const_pointer cpos, IITR_RANGE &&r) {
    pointer pos = cpos - op + op;
    const auto pos_dif = pos - op;
    if (pos == now) {
      append_range_impl(r);
      return op + pos_dif;
    }
    else {
      const auto n = size(r);
      reserve_raw_space_at_least(n);
      pos = op + pos_dif;
      const auto pos2 = pos + n;
      const auto old_now = now;
      if (pos2 >= now) {
        now = uninitialized_move(rng(pos, now), pos2);
#ifndef RE_NOEXCEPT
        try {
#endif
          uninitialized_copy(rng(copy_from(rng(pos, old_now), begin(r)),
                                 end(r)),
                             old_now);
#ifndef RE_NOEXCEPT
        }
        catch (...) {
          destroy(rng(pos2, now));
          now = old_now;
          throw;
        }
#endif
      }
      else {
        const auto cut = now - n;
        now = uninitialized_move(rng(cut, now), now);
        move_backward(rng(pos, cut), old_now);
        copy(r, pos);
      }
      return pos;
    }
  }
  template <class IITR_RANGE, class TT = value_type>
  enable_if_t<!(rng_is_sized<IITR_RANGE> || is_fitr<rng_itr<IITR_RANGE>>),
              pointer>
  insert_range_impl(const_pointer cpos, IITR_RANGE &&r) {
    pointer pos = cpos - op + op;
    const auto dif_pos = pos - op;
    if (pos == now) {
      append_range_impl(r);
      return op + dif_pos;
    }
    else {
      const auto dif_old_now = now - op;
      append_range_impl(r);
      pos = op + dif_pos;
      rotate(rng(pos, now), op + dif_old_now);
      return pos;
    }
  }

  template <class SZT>
  void size_check(SZT n) const {
    static_assert(is_integral_v<SZT> && is_unsigned_v<SZT>);
    if (n > max_size())
      throw_or_terminate<length_error>
        ("re::vector: size overflow in size_check(n)\n");
  }

  template <class IITR_RANGE>
  enable_if_t<rng_is_sized<IITR_RANGE>>
  construct_from_range_impl(IITR_RANGE &&r) {
    const auto n = size(r);
    if (n == 0u) {
      new_data();
      return;
    }
    size_check(n);
    op = allocate(n);
    ed = op + n;
#ifndef RE_NOEXCEPT
    try {
#endif
      now = uninitialized_copy(r, op);
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      deallocate(op, n);
      throw;
    }
#endif
  }
  template <class IITR_RANGE>
  enable_if_t<!rng_is_sized<IITR_RANGE>>
  construct_from_range_impl(IITR_RANGE &&r) {
    new_data();
#ifndef RE_NOEXCEPT
    try {
#endif
      for (auto &p : iters(r))
        emplace_back_impl(*p);
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      destroy(*this);
      deallocate();
      throw;
    }
#endif
  }

  void construct_n_impl(size_type n) {
    if (n == 0u) {
      new_data();
      return;
    }
    size_check(n);
    op = allocate(n);
    ed = op + n;
    now = ed;
#ifndef RE_NOEXCEPT
    try {
#endif
      uninitialized_fill(*this);
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      deallocate(op, n);
      throw;
    }
#endif
  }

  template <class IITR_RANGE>
  enable_if_t<rng_is_sized<IITR_RANGE>>
  assign_range_impl(IITR_RANGE &&r) {
    const auto n = size(r);
    if (n == 0u) {
      destroy(*this);
      deallocate();
      new_data();
    }
    else if (n > to_unsigned(ed - op)) {
      destroy(*this);
      deallocate();
#ifndef RE_NOEXCEPT
      new_data();
#endif
      size_check(n);
      op = allocate(n);
      ed = op + n;
#ifndef RE_NOEXCEPT
      try {
#endif
        now = uninitialized_copy(r, op);
#ifndef RE_NOEXCEPT
      }
      catch (...) {
        deallocate(op, n);
        new_data();
        throw;
      }
#endif
    }
    else if (n < size()) {
      const auto mid = copy(r, op);
      destroy(rng(mid, now));
      now = mid;
    }
    else {
      const auto p = copy_from(*this, begin(r));
      now = uninitialized_copy(rng(p, end(r)), now);
    }
  }
  template <class IITR_RANGE>
  enable_if_t<!rng_is_sized<IITR_RANGE>>
  assign_range_impl(IITR_RANGE &&r) {
    auto r1 = rng(*this);
    auto r2 = rng(r);
    for (;; ++r1.first, (void)++r2.first) {
      if (empty(r1)) {
        append_range_impl(r2);
        return;
      }
      if (empty(r2)) {
        erase_range_impl(r1.first, r1.second);
        return;
      }
      *r1.first = *r2.first;
    }
  }

  pointer insert_n_impl(const_pointer p,
                        size_type n, const value_type &x) {
    const auto tmp = make_temporary(x);
    return insert_range_impl(p, rng(n, ref(*tmp)));
  }

  void resize_impl(size_type n) {
    const size_type sz = size();
    if (n < sz)
      erase_range_impl(op + n, now);
    else {
      reserve_raw_space_at_least(n -= sz);
      uninitialized_fill(rng(now, n));
      now += n;
    }
  }
  void resize_impl(size_type n, const value_type &x) {
    const size_type sz = size();
    if (n < sz)
      erase_range_impl(op + n, now);
    else {
      const auto tmp = make_temporary(x);
      reserve_raw_space_at_least(n -= sz);
      uninitialized_fill(rng(now, n), *tmp);
      now += n;
    }
  }
  void reserve_impl(size_type n) {
    if (n > to_unsigned(ed - op)) {
      size_check(n);
      reallocate_impl(n);
    }
  }
  void shrink_to_fit_impl() {
    if (op == now) {
      deallocate();
      new_data();
    }
    else if (now < ed)
      reallocate_impl(now - op);
  }

public:
  // container (continued)

  vector() noexcept(noexcept(AL())) : vector(AL()) {}
  ~vector() {
    delete_data();
  }
  vector(const vector &v)
    : alw_t(alw_t::traits
            ::select_on_container_copy_construction(v.alloc_ref())) {
    new_data(v);
  }
  vector &operator =(const vector &v) {
    allocator_aware_container_ownership<this_t>::copy_assign(*this, v);
    return *this;
  }
  vector(vector &&v) noexcept : alw_t(move(v.alloc_ref())) {
    new_data(move(v));
  }
  vector &operator =(vector &&v)
    noexcept(alloc_move_prpg<AL> || alloc_always_equal<AL>) {
    allocator_aware_container_ownership<this_t>::move_assign(*this, v);
    return *this;
  }
  friend void swap(vector &x, vector &y)
    noexcept(alloc_swap_prpg<AL> || alloc_always_equal<AL>) {
    allocator_aware_container_ownership<this_t>::swap(x, y);
  }

  // optional container operations

  // reversible container

  using reverse_iterator = re::reverse_iterator<iterator>;
  using const_reverse_iterator = re::reverse_iterator<const_iterator>;

  reverse_iterator rbegin() noexcept {
    return reverse_iterator(now);
  }
  reverse_iterator rend() noexcept {
    return reverse_iterator(op);
  }
  const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator(now);
  }
  const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator(op);
  }
  const_reverse_iterator crbegin() const noexcept {
    return rbegin();
  }
  const_reverse_iterator crend() const noexcept {
    return rend();
  }

  // allocator-aware container

  using allocator_type = AL;
  allocator_type get_allocator() const noexcept {
    return alw_t::get();
  }

  explicit vector(const AL &al) noexcept : alw_t(al) {
    new_data();
  }
  vector(const vector &v, const AL &al) : alw_t(al) {
    new_data(v);
  }
  vector(vector &&v, const AL &al) : alw_t(al) {
    allocator_aware_container_ownership<this_t>::move_construct(*this, v);
  }

  // sequence container

  explicit vector(size_type n, const AL &al = AL{}) : alw_t(al) {
    construct_n_impl(n);
  }
  vector(size_type n, const value_type &x,
         const AL &al = AL{}) : alw_t(al) {
    construct_from_range_impl(rng(n, ref(x)));
  }
  void assign(size_type n, const value_type &x) {
    assign_range_impl(rng(n, x));
  }

  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  vector(IITR from, IITR to, const AL &al = AL{}) : alw_t(al) {
    construct_from_range_impl(rng(from, to));
  }
  template <class IITR>
  enable_if_t<is_itr<IITR>> assign(IITR from, IITR to) {
    assign_range_impl(rng(from, to));
  }

  vector(initializer_list<value_type> l, const AL &al = AL{}) : alw_t(al) {
    construct_from_range_impl(l);
  }
  vector &operator =(initializer_list<value_type> l) {
    assign_range_impl(l);
    return *this;
  }
  void assign(initializer_list<value_type> l) {
    assign_range_impl(l);
  }

  template <class...S>
  iterator emplace(const_iterator pos, S &&...s) {
    return emplace_impl(pos, forward<S>(s)...);
  }
  iterator insert(const_iterator pos, const value_type &x) {
    return emplace_impl(pos, x);
  }
  iterator insert(const_iterator pos, value_type &&x) {
    return emplace_impl(pos, move(x));
  }

  iterator insert(const_iterator pos, size_type n, const value_type &x) {
    return insert_n_impl(pos, n, x);
  }
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  iterator insert(const_iterator pos, IITR from, IITR to) {
    return insert_range_impl(pos, rng(from, to));
  }
  iterator insert(const_iterator pos, initializer_list<value_type> l) {
    return insert_range_impl(pos, l);
  }

  iterator erase(const_iterator pos) {
    return erase_impl(pos);
  }
  iterator erase(const_iterator from, const_iterator to) {
    return erase_range_impl(from, to);
  }

  void clear() noexcept {
    destroy(*this);
    now = op;
  }

  // optional sequence container operations

  reference front() {
    return *op;
  }
  reference back() {
    return *(now - 1);
  }
  const_reference front() const {
    return *op;
  }
  const_reference back() const {
    return *(now - 1);
  }

  template <class...S>
  reference emplace_back(S &&...s) {
    return emplace_back_impl(forward<S>(s)...);
  }
  void push_back(const value_type &x) {
    emplace_back_impl(x);
  }
  void push_back(value_type &&x) {
    emplace_back_impl(move(x));
  }
  void pop_back() noexcept {
    pop_back_impl();
  }

  reference operator [](size_type n) {
    return op[n];
  }
  const_reference operator [](size_type n) const {
    return op[n];
  }
  reference at(size_type n) {
    if (n >= size())
      throw_or_terminate<out_of_range>("re::vector: at(n) failed\n");
    return op[n];
  }
  const_reference at(size_type n) const {
    if (n >= size())
      throw_or_terminate<out_of_range>("re::vector: at(n) failed\n");
    return op[n];
  }

  // specialized operations

  value_type *data() noexcept {
    return to_address(op);
  }
  const value_type *data() const noexcept {
    return to_address(op);
  }
  size_type capacity() const noexcept {
    return ed - op;
  }
  void resize(size_type n) {
    resize_impl(n);
  }
  void resize(size_type n, const value_type &x) {
    resize_impl(n, x);
  }
  void reserve(size_type n) {
    reserve_impl(n);
  }
  void shrink_to_fit() {
    shrink_to_fit_impl();
  }

  // extensions

  template <class UF>
  size_type remove_if(UF eq) {
    const auto i = re::remove_if(*this, eq);
    const auto z = end();
    const size_type ret = z - i;
    erase(i, z);
    return ret;
  }
  template <class X>
  size_type remove(const X &x) {
    return remove_if(bind(equal_to<>(), _1, ref(x)));
  }

  bool full() const noexcept {
    return now == ed;
  }

  void reallocate(size_type n) {
    if (const auto z = size(); n < z)
      n = z;
    if (n == 0u) {
      destroy(*this);
      deallocate();
      new_data();
    }
    else
      reallocate_impl(n);
  }
  void reallocate() {
    reallocate(size());
  }

  void reserve_more(size_type n) {
    reserve_raw_space_at_least(n);
  }

  template <class R>
  iterator replace(const_iterator i1, const_iterator i2, R &&r) {
    return inner::fns::seq_container_replace_impl
      (*this, i1 - begin() + begin(), i2 - begin() + begin(), r);
  }

  template <class R>
  vector(from_range_t, R &&r, const allocator_type &al = allocator_type{})
    requires (is_rng<R> && is_constructible_v<value_type, rng_ref<R>>)
    : alw_t(al) {
    construct_from_range_impl(r);
  }
  template <class R, class = enable_if_t
            <!is_same_v<decay_t<R>, this_t>
             && !is_convertible_v<R &&, const AL &>
             && is_rng<R> && is_constructible_v<value_type, rng_ref<R>>>>
  explicit vector(R &&r) : vector(r, allocator_type{}) {}
  template <class R, class = enable_if_t
            <!is_same_v<decay_t<R>, this_t>
             && !is_convertible_v<R &&, const AL &>
             && is_rng<R> && is_constructible_v<value_type, rng_ref<R>>>>
  vector(R &&r, const allocator_type &al) : alw_t(al) {
    construct_from_range_impl(r);
  }
  template <class R>
  enable_if_t<!is_same_v<decay_t<R>, this_t>
              && !is_convertible_v<R &&, const AL &>
              && is_rng<R> && is_constructible_v<value_type, rng_ref<R>>
              && is_assignable_v<value_type &, rng_ref<R>>, this_t &>
  operator =(R &&r) {
    assign_range_impl(r);
    return *this;
  }
  template <class IITR_RANGE>
  void assign(IITR_RANGE &&r) {
    assign_range_impl(r);
  }
  template <class IITR_RANGE>
  void assign_range(IITR_RANGE &&r) {
    assign_range_impl(r);
  }

  template <class IITR_RANGE>
  enable_if_t<!is_convertible_v<IITR_RANGE &&, value_type &&>
              && !is_convertible_v<IITR_RANGE &&, const value_type &>,
              iterator>
  insert(const_iterator pos, IITR_RANGE &&r) {
    return insert_range_impl(pos, r);
  }
  template <class IITR_RANGE>
  iterator insert_range(const_iterator pos, IITR_RANGE &&r) {
    return insert_range_impl(pos, r);
  }

  template <class IITR_RANGE>
  enable_if_t<!is_convertible_v<IITR_RANGE &&, value_type &&>
              && !is_convertible_v<IITR_RANGE &&, const value_type &>>
  push_back(IITR_RANGE &&r) {
    append_range_impl(r);
  }
  template <class IITR_RANGE>
  void append_range(IITR_RANGE &&r) {
    append_range_impl(r);
  }
  void pop_back(size_type n) {
    pop_back_n_impl(n);
  }

  this_t &append() {
    return *this;
  }
  template <class X, class...S>
  this_t &append(X &&x, S &&...s) {
    push_back(forward<X>(x));
    return append(forward<S>(s)...);
  }
};
template <class T, class AL>
bool operator ==(const vector<T, AL> &x, const vector<T, AL> &y) {
  return equal(x, y);
}
template <class T, class AL>
synth_3way_result<T> operator <=>(const vector<T, AL> &x,
                                  const vector<T, AL> &y) {
  return lexicographical_synth_3way(x, y);
}

namespace inner {

template <class, class>
class bitvec_iterator;

template <class UINT_AL>
class bitvec_reference {
  template <class, class>
  friend class bitvec_iterator;
  template <class, class>
  friend class re::vector;

  using uint = alloc_vt<UINT_AL>;
  using pointer = alloc_cptr<UINT_AL>;

  static constexpr size_t bits_of_uint = sizeof(uint) * 8;

  pointer p;
  alloc_szt<UINT_AL> n;

  void swap_referenced_target(bitvec_reference &x) noexcept {
    adl_swap(p, x.p);
    adl_swap(n, x.n);
  }

  bitvec_reference() noexcept = default;
public:
  ~bitvec_reference() noexcept = default;
  bitvec_reference(const bitvec_reference &) = default;
  bitvec_reference &operator =(const bitvec_reference &x) {
    return operator =(x.operator bool());
  }
  bitvec_reference(bitvec_reference &&) = default;
  bitvec_reference &operator =(bitvec_reference &&x) {
    return operator =(static_cast<const bitvec_reference &>(x));
  }
  friend void swap(bitvec_reference x, bitvec_reference y) noexcept {
    if (x.operator bool() != y.operator bool()) {
      x.flip();
      y.flip();
    }
  }

  bitvec_reference &operator =(bool x) noexcept {
    if (x)
      const_cast<uint &>(*p) |= (uint)(uint(1) << (uint)n);
    else
      const_cast<uint &>(*p) &= (uint)~(uint(1) << (uint)n);
    return *this;
  }

  operator bool() const noexcept {
    return *p & (uint)(uint(1) << (uint)n);
  }
  bool operator ~() const noexcept {
    return !operator bool();
  }

  bitvec_reference &flip() noexcept {
    const_cast<uint &>(*p) ^= (uint)(uint(1) << (uint)n);
    return *this;
  }
};

template <class T, class UINT_AL>
class bitvec_iterator {
  static_assert(is_same_v<remove_cv_t<T>, bool>);

  template <class, class>
  friend class bitvec_iterator;
  template <class, class>
  friend class re::vector;

  using this_t = bitvec_iterator;

  using uint = alloc_vt<UINT_AL>;
  static constexpr alloc_dft<UINT_AL> cap = sizeof(uint) * 8;

  bitvec_reference<UINT_AL> ref;

  using size_type = alloc_szt<UINT_AL>;

public:
  using value_type = bool;
  using reference = conditional_t<is_const_v<T>,
                                  bool, bitvec_reference<UINT_AL>>;
  using pointer = reference *;
  using difference_type = alloc_dft<UINT_AL>;
  using iterator_category = random_access_iterator_tag;

  bitvec_iterator() = default;
  ~bitvec_iterator() = default;
  bitvec_iterator(const bitvec_iterator &) = default;
  bitvec_iterator &operator =(const bitvec_iterator &x)
    noexcept(is_nothrow_copy_assignable_v<bitvec_reference<UINT_AL>>) {
    ref.p = x.ref.p;
    ref.n = x.ref.n;
    return *this;
  }
  bitvec_iterator(bitvec_iterator &&) = default;
  bitvec_iterator &operator =(bitvec_iterator &&x)
    noexcept(is_nothrow_move_assignable_v<bitvec_reference<UINT_AL>>) {
    return operator =(static_cast<const bitvec_iterator &>(x));
  }
  friend void swap(bitvec_iterator &x, bitvec_iterator &y) noexcept {
    x.ref.swap_referenced_target(y.ref);
  }

  template <bool Y = is_const_v<T>, class = enable_if_t<Y>>
  bitvec_iterator(const bitvec_iterator<bool, UINT_AL> &x) : ref(x.ref) {}
  template <bool Y = is_const_v<T>, class = enable_if_t<Y>>
  bitvec_iterator &operator =(const bitvec_iterator<bool, UINT_AL> &x) {
    ref = x.ref;
    return *this;
  }

private:
  template <bool Y = !is_const_v<T>, class = enable_if_t<Y>>
  bitvec_iterator(const bitvec_iterator<const bool, UINT_AL> &x) : ref(x.ref) {}
  template <class B>
  bool eq(const bitvec_iterator<B, UINT_AL> &x) const {
    return ref.p == x.ref.p && ref.n == x.ref.n;
  }
  template <class A, class B, class C>
  friend bool operator ==(const bitvec_iterator<A, C> &,
                          const bitvec_iterator<B, C> &);

public:
  reference operator *() const {
    return ref;
  }
  pointer operator ->() = delete;

  this_t &operator ++() {
    ++ref.n;
    if (ref.n == cap) {
      ref.n = 0;
      ++ref.p;
    }
    return *this;
  }
  this_t operator ++(int) {
    return iter_post_increment(*this);
  }

  this_t &operator --() {
    if (ref.n == 0u) {
      --ref.p;
      ref.n = cap - 1;
    }
    else
      --ref.n;
    return *this;
  }
  this_t operator --(int) {
    return iter_post_decrement(*this);
  }

  this_t &operator +=(difference_type i) {
    const difference_type d = i / cap;
    const difference_type r = i % cap;
    ref.p += d;
    if (r < 0) {
      if (ref.n < to_unsigned(-r)) {
        ref.n += (cap + r);
        --ref.p;
      }
      else
        ref.n -= -r;
    }
    else {
      ref.n += r;
      if (ref.n >= cap) {
        ref.n -= cap;
        ++ref.p;
      }
    }
    return *this;
  }
  this_t &operator -=(difference_type i) {
    return operator +=(-i);
  }
  reference operator [](difference_type i) const {
    return *(copy(*this) += i);
  }

private:
  template <class B>
  strong_ordering cmp(const bitvec_iterator<B, UINT_AL> &x) const {
    const auto o = (ref.p <=> x.ref.p);
    return (o != 0) ? o : (ref.n <=> x.ref.n);
  }
  template <class A, class B, class C>
  friend strong_ordering operator <=>(const bitvec_iterator<A, C> &,
                                      const bitvec_iterator<B, C> &);

  template <class B>
  difference_type minus(const bitvec_iterator<B, UINT_AL> &x) const {
    return (ref.p - x.ref.p) * (to_signed(sizeof(uint)) * 8)
      + (ref.n - x.ref.n);
  }
  template <class A, class B, class C>
  friend itr_dft<bitvec_iterator<A, C>>
  operator -(const bitvec_iterator<A, C> &,
             const bitvec_iterator<B, C> &);
};
template <class T, class T2, class UINT_AL>
bool operator ==(const bitvec_iterator<T, UINT_AL> &x,
                 const bitvec_iterator<T2, UINT_AL> &y) {
  return x.eq(y);
}
template <class T, class T2, class UINT_AL>
strong_ordering operator <=>(const bitvec_iterator<T, UINT_AL> &x,
                             const bitvec_iterator<T2, UINT_AL> &y) {
  return x.cmp(y);
}
template <class T, class UINT_AL>
bitvec_iterator<T, UINT_AL>
operator +(const bitvec_iterator<T, UINT_AL> &x,
           itr_dft<bitvec_iterator<T, UINT_AL>> n) {
  return copy(x) += n;
}
template <class T, class UINT_AL>
bitvec_iterator<T, UINT_AL>
operator +(itr_dft<bitvec_iterator<T, UINT_AL>> n,
           const bitvec_iterator<T, UINT_AL> &x) {
  return copy(x) += n;
}
template <class T, class T2, class UINT_AL>
itr_dft<bitvec_iterator<T, UINT_AL>>
operator -(const bitvec_iterator<T, UINT_AL> &x,
           const bitvec_iterator<T2, UINT_AL> &y) {
  return x.minus(y);
}
template <class T, class UINT_AL>
bitvec_iterator<T, UINT_AL>
operator -(const bitvec_iterator<T, UINT_AL> &x,
           itr_dft<bitvec_iterator<T, UINT_AL>> n) {
  return copy(x) -= n;
}

}
template <class AL>
class vector<bool, AL> : range_fns {
  using range_fns::begin;
  using range_fns::end;
  using range_fns::rbegin;
  using range_fns::rend;
  using range_fns::size;
  using range_fns::empty;

  static_assert(is_same_v<alloc_vt<AL>, bool>);

  using this_t = vector;

  using uint = unsigned long long;
  using uint_alloc = alloc_rebind<AL, uint>;

  vector<uint, uint_alloc> v;
  alloc_szt<AL> n;

  template <class A>
  using bitvec_reference = inner::bitvec_reference<A>;
  template <class A, class B>
  using bitvec_iterator = inner::bitvec_iterator<A, B>;

public:
  using pointer = void;
  using const_pointer = void;

  // container

  using value_type = bool;
  using reference = bitvec_reference<uint_alloc>;
  using const_reference = bool;

  using iterator = bitvec_iterator<bool, uint_alloc>;
  using const_iterator = bitvec_iterator<const bool, uint_alloc>;
  using difference_type = alloc_dft<AL>;
  using size_type = alloc_szt<AL>;

private:
  static constexpr size_type bits_of_uint = sizeof(uint) * 8;

  static size_type v_n(size_type nn) noexcept {
    return nn / bits_of_uint + ((nn % bits_of_uint != 0) ? 1u : 0u);
  }
  static uint max_or_zero(bool y) noexcept {
    return y ? (uint)~(uint)0 : (uint)0;
  }

  size_type tail_count() const noexcept {
    return n % bits_of_uint;
  }

  template <class SZT>
  void size_check(SZT sz) const {
    if (sz > max_size())
      throw_or_terminate<length_error>
        ("re::vector<bool, A>: size overflow in size_check(n)\n");
  }
  template <class SZT>
  void size_check_insert(SZT nn) const {
    if (nn > max_size() - n)
      throw_or_terminate<length_error>
        ("re::vector<bool, A>: size overflow in size_check_insert(n)\n");
  }
  void size_check_insert_1() const {
    if (n == max_size())
      throw_or_terminate<length_error>
        ("re::vector<bool, A>: size overflow in size_check_insert_1()\n");
  }

  template <class SZT>
  size_type checked_v_n(SZT nn) noexcept {
    size_check(nn);
    const size_type nnn = nn;
    return nnn / bits_of_uint + ((nnn % bits_of_uint != 0) ? 1u : 0u);
  }

public:
  // container
  iterator begin() noexcept {
    iterator i;
    i.ref.p = v.begin();
    i.ref.n = 0;
    return i;
  }
  iterator end() noexcept {
    iterator ret;
    ret.ref.n = n % bits_of_uint;
    ret.ref.p = v.end() - ((ret.ref.n != 0) ? 1 : 0);
    return ret;
  }
  const_iterator begin() const noexcept {
    const_iterator i;
    i.ref.p = v.begin();
    i.ref.n = 0;
    return i;
  }
  const_iterator end() const noexcept {
    const_iterator ret;
    ret.ref.p = v.end() - (((ret.ref.n = n % bits_of_uint) != 0) ? 1 : 0);
    return ret;
  }
  const_iterator cbegin() const noexcept {
    return begin();
  }
  const_iterator cend() const noexcept {
    return end();
  }
  size_type max_size() const noexcept {
    constexpr size_type k = integral_traits<difference_type>::max();
    constexpr size_type ret = min_value
      (k - k % bits_of_uint, to_unsigned(integral_traits<ptrdiff_t>::max()));
    constexpr size_type ret2
      = min_value(ret, integral_traits<size_type>::max());
    return ret2;
  }
  size_type size() const noexcept {
    return n;
  }
  bool empty() const noexcept {
    return n == 0u;
  }

private:
  // inner implements

  void push_back_impl(bool y) {
    size_check_insert_1();
    if (tail_count() == 0u)
      v.push_back(static_cast<uint>(y));
    else
      *end() = y;
    ++n;
  }
  template <class...S>
  reference emplace_back_impl(S &&...s) {
    size_check_insert_1();
    bool y(forward<S>(s)...);
    iterator it;
    if (tail_count() == 0u) {
      v.push_back(static_cast<uint>(y));
      it.ref.p = v.end() - 1;
      it.ref.n = 0;
    }
    else {
      it = end();
      *it = y;
    }
    ++n;
    return *it;
  }
  void pop_back_impl() noexcept {
    if (tail_count() == 1)
      v.pop_back();
    else
      *(end() - 1) = false;
    --n;
  }

  void reserve_space_back(size_type nn) {
    const size_type c = tail_count();
    const auto new_n = n + nn;
    size_type x;
    if (c == 0u)
      x = nn;
    else if (bits_of_uint - c >= nn) {
      n = new_n;
      return;
    }
    else
      x = nn - (bits_of_uint - c);
    v.append_range(rng(v_n(x), 0));
    n = new_n;
  }
  iterator reserve_space(iterator it, size_type nn) {
    const size_type old_v_sz = v.size();
    {
      const bool y = (it == end());
      const auto dif = it - begin();
      reserve_space_back(nn);
      it = begin() + dif;
      if (y)
        return it;
    }
    if (nn < bits_of_uint) {
      for (auto &p : r_iters(it.ref.p + 1, v.end()))
        const_cast<uint &>(*p)
          = (uint)(*p << (uint)nn)
          | (uint)(*(p - 1) >> (uint)(bits_of_uint - nn));
      if (it.ref.n != 0) {
        const uint tmp = (uint)~(uint)0 >> (uint)(bits_of_uint - it.ref.n);
        const_cast<uint &>(*it.ref.p)
          = (uint)((uint)(*it.ref.p & (uint)~tmp) << (uint)nn)
          | (uint)(*it.ref.p & tmp);
      }
      else
        const_cast<uint &>(*it.ref.p) = (uint)(*it.ref.p << (uint)nn);
    }
    else {
      for (auto &p : r_iters(it.ref.p, v.begin() + old_v_sz))
        const_cast<uint &>(*(p + nn / bits_of_uint)) = *p;
      const auto it2 = it + nn;
      nn %= bits_of_uint;
      if (nn != 0)
        for (auto &p : r_iters(it2.ref.p, v.end()))
          const_cast<uint &>(*p) = (uint)(*p << (uint)nn)
            | (uint)(*(p - 1) >> (uint)(bits_of_uint - nn));
    }
    return it;
  }

  template <class IITR_RANGE>
  enable_if_t<rng_is_sized<IITR_RANGE>
              || is_fitr<rng_itr<IITR_RANGE>>, iterator>
  insert_range_impl(iterator pos, IITR_RANGE &&r) {
    const auto sz = size(r);
    size_check_insert(sz);
    pos = reserve_space(pos, sz);
    copy(r, pos);
    return pos;
  }
  template <class IITR_RANGE>
  enable_if_t<!(rng_is_sized<IITR_RANGE> || is_fitr<rng_itr<IITR_RANGE>>),
              iterator>
  insert_range_impl(iterator pos, IITR_RANGE &&r) {
    const auto pos_dif = pos - begin();
    const auto old_ed_dif = n;
    for (auto &p : iters(r))
      push_back_impl(bool(*p));
    const iterator new_pos = begin() + pos_dif;
    rotate(rng(new_pos, end()), begin() + old_ed_dif);
    return new_pos;
  }

  template <class...S>
  iterator emplace_impl(iterator pos, S &&...s) {
    size_check_insert_1();
    iterator it = reserve_space(pos, 1);
    *it = bool(forward<S>(s)...);
    return it;
  }

  iterator erase_impl(iterator pos) noexcept {
    uint tmp = 0;
    for (auto &p : r_iters(pos.ref.p + 1, v.end())) {
      const uint tmp2 = (uint)(*p << (uint)(bits_of_uint - 1));
      const_cast<uint &>(*p) = (uint)((uint)(*p >> (uint)1) | tmp);
      tmp = tmp2;
    }
    const uint tmp2 = (uint)~uint(0) << (uint)pos.ref.n;
    const_cast<uint &>(*pos.ref.p)
      = (uint)((uint)((uint)(*pos.ref.p & (uint)~tmp2)
                      | (uint)((uint)(*pos.ref.p >> (uint)1) & (uint)tmp2))
               | (uint)tmp);
    pop_back_impl();
    return pos;
  }
  iterator erase_range_impl(iterator it1, iterator it2) noexcept {
    const auto dif = it2 - it1;
    if (dif == 0)
      return it1;
    n -= dif;

    if (it2.ref.p != v.end()) {
      if (it2.ref.n == it1.ref.n) {
        const auto p = it1.ref.p;
        const uint tmp = (uint)~(uint)0 << (uint)it1.ref.n;
        const_cast<uint &>(*p)
          = (uint)(*p & (uint)~tmp) | (uint)(*it2.ref.p & (uint)tmp);
        copy(rng(it2.ref.p + 1, v.end()),
             const_cast<uint *>(to_address(next(p))));
      }
      else {
        auto p = it1.ref.p;
        uint k1, k2;
        if (it2.ref.n > it1.ref.n) {
          k2 = it2.ref.n - it1.ref.n;
          k1 = bits_of_uint - k2;
          const uint tmp = (uint)~(uint)0 << (uint)it1.ref.n;
          const_cast<uint &>(*p)
            = (uint)(*p & (uint)~tmp) | (uint)((uint)(*it2.ref.p >> k2) & tmp);
        }
        else {
          k1 = it1.ref.n - it2.ref.n;
          k2 = bits_of_uint - k1;
          const uint tmp = (uint)~(uint)0 << (uint)it1.ref.n;
          const_cast<uint &>(*p) = (uint)(*p & (uint)~tmp)
            | (uint)((uint)((uint)(*it2.ref.p & (uint)((uint)~(uint)0 >> k1))
                            << (uint)k1)
                     & tmp);
          const_cast<uint &>(*++p) = (*it2.ref.p >> k2);
        }
        for (const uint &x : rng(it2.ref.p + 1, v.end())) {
          const_cast<uint &>(*p) |= (uint)(x << k1);
          const_cast<uint &>(*++p) = (x >> k2);
        }
      }
    }

    v.erase(v.end() - (v.size() - v_n(n)), v.end());
    return it1;
  }

  template <class R>
  enable_if_t<rng_is_n_value<R>> assign_range_impl(R &&r) {
    const auto sz = size(r);
    size_check(sz);
    v.assign_range(rng(v_n(sz), max_or_zero(*begin(r))));
    n = sz;
  }
  template <class R>
  enable_if_t<!rng_is_n_value<R> && rng_is_sized<R>>
  assign_range_impl(R &&r) {
    const auto sz = size(r);
    size_check(sz);
    v.resize(v_n(sz));
    n = sz;
    copy(r, begin());
  }
  template <class R>
  enable_if_t<!rng_is_n_value<R> && !rng_is_sized<R>>
  assign_range_impl(R &&r) {
    v.clear();
    n = 0;
    for (auto &p : iters(r))
      push_back_impl(bool(*p));
  }

  struct range_construct_tag {};
  template <class R, class = enable_if_t<rng_is_n_value<R>>>
  vector(range_construct_tag, R &&r, const AL &al = AL{})
    : v(checked_v_n(size(r)), max_or_zero(*begin(r)), uint_alloc(al))
    , n(size(r)) {}
  template <class R, class = enable_if_t<!rng_is_n_value<R> && rng_is_sized<R>>,
            int = 0>
  vector(range_construct_tag, R &&r, const AL &al = AL{})
    : v(checked_v_n(size(r)), uint_alloc(al)), n(size(r)) {
    copy(r, begin());
  }
  template <class R,
            class = enable_if_t<!rng_is_n_value<R> && !rng_is_sized<R>>,
            class = void>
  vector(range_construct_tag, R &&r, const AL &al = AL{})
    : v(uint_alloc(al)) {
    for (auto &p : iters(r))
      push_back_impl(bool(*p));
  }

public:
  // container (continued)

  vector() noexcept(noexcept(AL())) : vector(AL()) {}
  ~vector() = default;
  vector(const vector &) = default;
  vector &operator =(const vector &) = default;
  vector(vector &&) = default;
  vector &operator =(vector &&) = default;
  friend void swap(vector &x, vector &y)
    noexcept(is_nothrow_swappable_v<vector<uint, uint_alloc>>) {
    adl_swap(x.v, y.v);
    adl_swap(x.n, y.n);
  }

  template <class AL2>
  friend bool operator ==(const vector<bool, AL2> &, const vector<bool, AL2> &);

  // optional container operations

  // reversible container

  using reverse_iterator = re::reverse_iterator<iterator>;
  using const_reverse_iterator = re::reverse_iterator<const_iterator>;

  reverse_iterator rbegin() noexcept {
    return reverse_iterator(end());
  }
  reverse_iterator rend() noexcept {
    return reverse_iterator(begin());
  }
  const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator(begin());
  }
  const_reverse_iterator crbegin() const noexcept {
    return rbegin();
  }
  const_reverse_iterator crend() const noexcept {
    return rend();
  }

  // allocator-aware container

  using allocator_type = AL;
  allocator_type get_allocator() const noexcept {
    return allocator_type(v.get_allocator());
  }

  explicit vector(const AL &al) noexcept : v(uint_alloc(al)), n() {}
  vector(const vector &x, const AL &al) : v(x.v, uint_alloc(al)), n(x.n) {}
  vector(vector &&x, const AL &al) : v(move(x.v), uint_alloc(al)), n(x.n) {
    x.n = 0;
  }

  // sequence container

  explicit vector(size_type nn, const AL &al = AL{})
    : v(checked_v_n(nn), uint_alloc(al)), n(nn) {}
  vector(size_type nn, const value_type &x, const AL &al = AL{})
    : v(checked_v_n(nn), max_or_zero(x), uint_alloc(al)), n(nn) {}
  void assign(size_type nn, const value_type &x) {
    assign_range_impl(rng(nn, x));
  }

  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  vector(IITR from, IITR to, const AL &al = AL{})
    : vector(range_construct_tag(), rng(from, to), al) {}
  template <class IITR>
  enable_if_t<is_itr<IITR>> assign(IITR from, IITR to) {
    assign_range_impl(rng(from, to));
  }

  vector(initializer_list<value_type> l, const AL &al = AL{})
    : vector(range_construct_tag(), l, al) {}
  vector &operator =(initializer_list<value_type> l) {
    assign_range_impl(l);
    return *this;
  }
  void assign(initializer_list<value_type> l) {
    assign_range_impl(l);
  }

  template <class...S>
  iterator emplace(const_iterator pos, S &&...s) {
    return emplace_impl(pos, forward<S>(s)...);
  }
  iterator insert(const_iterator pos, const value_type &x) {
    return emplace_impl(pos, x);
  }
  iterator insert(const_iterator pos, value_type &&x) {
    return emplace_impl(pos, move(x));
  }

  iterator insert(const_iterator pos, size_type n, const value_type &x) {
    return insert_range_impl(pos, rng(n, x));
  }
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  iterator insert(const_iterator pos, IITR from, IITR to) {
    return insert_range_impl(pos, rng(from, to));
  }
  iterator insert(const_iterator pos, initializer_list<value_type> l) {
    return insert_range_impl(pos, l);
  }

  iterator erase(const_iterator pos) {
    return erase_impl(pos);
  }
  iterator erase(const_iterator from, const_iterator to) {
    return erase_range_impl(from, to);
  }

  void clear() noexcept {
    v.clear();
    n = 0;
  }

  // optional sequence container operations

  reference front() {
    return *begin();
  }
  reference back() {
    return *(begin() + (n - 1));
  }
  const_reference front() const {
    return *begin();
  }
  const_reference back() const {
    return *(begin() + (n - 1));
  }

  template <class...S>
  reference emplace_back(S &&...s) {
    return emplace_back_impl(forward<S>(s)...);
  }
  void push_back(const value_type &x) {
    push_back_impl(x);
  }
  void push_back(value_type &&x) {
    push_back_impl(x);
  }
  void pop_back() {
    pop_back_impl();
  }

  reference operator [](size_type nn) {
    return begin()[nn];
  }
  const_reference operator [](size_type nn) const {
    return begin()[nn];
  }
  reference at(size_type n) {
    if (n >= size())
      throw_or_terminate<out_of_range>("re::vector: at(n) failed\n");
    return begin()[n];
  }
  const_reference at(size_type n) const {
#ifndef RE_NOEXCEPT
    if (n >= size())
      throw_or_terminate<out_of_range>("re::vector<bool, A>: at(n) failed\n");
#endif
    return begin()[n];
  }

  // specialized operations

  size_type capacity() const noexcept {
    return v.capacity() * bits_of_uint;
  }
  void resize(size_type nn) {
    if (nn > n)
      reserve_space_back(nn - n);
    else
      erase(end() - (n - nn), end());
  }
  void resize(size_type nn, const value_type &x) {
    if (nn > n)
      insert_range_impl(end(), rng(nn - n, x));
    else
      erase(end() - (n - nn), end());
  }
  void reserve(size_type nn) {
    size_check(nn);
    v.reserve(v_n(nn));
  }
  void shrink_to_fit() {
    v.shrink_to_fit();
  }
  void flip() noexcept {
    for (uint &x : v)
      x = ~x;
  }

  // extensions

  template <class UF>
  size_type remove_if(UF eq) {
    const bool y = eq(true);
    const size_type nn = count(*this, y);
    *this = rng(size() - nn, !y);
    return nn;
  }
  size_type remove(bool y) {
    const size_type nn = count(*this, y);
    *this = rng(size() - nn, !y);
    return nn;
  }

  bool full() const noexcept {
    return size() == capacity();
  }

  void reallocate(size_type nn) {
    if (const auto z = size(); nn < z)
      nn = z;
    else
      size_check(nn);
    v.reallocate(v_n(nn));
  }
  void reallocate() {
    v.reallocate(v.size());
  }

  void reserve_more(size_type w) {
    const size_type z = size();
    if (max_size() - z < w)
      throw_or_terminate<length_error>
        ("re::vector<bool>: size overflow in reserve_more(n)\n");
    const size_type zz = w + z;
    if (zz != 0u)
      v.reallocate(v_n(zz));
  }

  template <class R>
  iterator replace(const_iterator i1, const_iterator i2, R &&r) {
    return inner::fns::seq_container_replace_impl
      (*this, i1 - begin() + begin(), i2 - begin() + begin(), r);
  }

  template <class R>
  vector(from_range_t, R &&r, const allocator_type &al = allocator_type{})
    requires (is_rng<R> && is_constructible_v<value_type, rng_ref<R>>)
    : vector(range_construct_tag{}, r, al) {}
  template <class IITR_RANGE, class = enable_if_t
            <!is_same_v<decay_t<IITR_RANGE>, this_t>
             && !is_convertible_v<IITR_RANGE &&, const AL &>
             && is_rng<IITR_RANGE>
             && is_constructible_v<value_type, rng_ref<IITR_RANGE>>>>
  explicit vector(IITR_RANGE &&r) : vector(range_construct_tag{}, r, AL()) {}
  template <class IITR_RANGE, class = enable_if_t
            <!is_same_v<decay_t<IITR_RANGE>, this_t>
             && is_rng<IITR_RANGE>
             && is_constructible_v<value_type, rng_ref<IITR_RANGE>>>>
  vector(IITR_RANGE &&r, const AL &al) : vector(range_construct_tag{}, r, al) {}
  template <class IITR_RANGE>
  enable_if_t<!is_same_v<decay_t<IITR_RANGE>, this_t>
              && is_rng<IITR_RANGE>
              && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
              && is_assignable_v<value_type &, rng_ref<IITR_RANGE>>, this_t &>
  operator =(IITR_RANGE &&r) {
    assign_range_impl(r);
    return *this;
  }
  template <class IITR_RANGE>
  void assign_range(IITR_RANGE &&r) {
    assign_range_impl(r);
  }
  template <class IITR_RANGE>
  void assign(IITR_RANGE &&r) {
    assign_range_impl(r);
  }

  template <class IITR_RANGE>
  enable_if_t<!is_convertible_v<IITR_RANGE &&, value_type &&>
              && !is_convertible_v<IITR_RANGE &&, const value_type &>,
              iterator>
  insert(const_iterator pos, IITR_RANGE &&r) {
    return insert_range_impl(pos, r);
  }
  template <class IITR_RANGE>
  iterator insert_range(const_iterator pos, IITR_RANGE &&r) {
    return insert_range_impl(pos, r);
  }

  template <class IITR_RANGE>
  enable_if_t<!is_convertible_v<IITR_RANGE &&, value_type &&>
              && !is_convertible_v<IITR_RANGE &&, const value_type &>>
  push_back(IITR_RANGE &&r) {
    insert_range_impl(end(), r);
  }
  template <class IITR_RANGE>
  void append_range(IITR_RANGE &&r) {
    insert_range_impl(end(), r);
  }
  void pop_back(size_type n) {
    for (; n != 0; --n)
      pop_back();
  }

  this_t &append() {
    return *this;
  }
  template <class X, class...S>
  this_t &append(X &&x, S &&...s) {
    push_back(forward<X>(x));
    return append(forward<S>(s)...);
  }

private:
  template <class>
  friend struct hash;

  size_t hash_code() const noexcept {
    size_t a{}, b{};
    const auto sz = v.size();
    using vt = rng_szt<decltype(v)>;
    if (sz >= 1u) {
      a = inner::fns::byte_array_hash
        (static_cast<const void *>(v.begin()),
         (v.size() - 1u) * sizeof(vt));
      const size_t nn = bits_of_uint - tail_count();
      b = hash<vt>{}((vt)(v.back() << (vt)nn));
    }
    return (size_t)(a ^ b);
  }
};
template <class AL>
bool operator ==(const vector<bool, AL> &x, const vector<bool, AL> &y) {
  if (x.size() != y.size())
    return false;
  const size_t n = x.bits_of_uint - x.tail_count();
  if (n == x.bits_of_uint)
    return x.v == y.v;
  if (!equal(rng(x.v.begin(), x.v.end() - 1), y.v.begin()))
    return false;
  using vt = rng_szt<decltype(x.v)>;
  return (x.v.back() << (vt)n) == (y.v.back() << (vt)n);
}
template <class AL>
strong_ordering operator <=>(const vector<bool, AL> &x,
                             const vector<bool, AL> &y) {
  return lexicographical_synth_3way(x, y);
}
template <class AL>
struct hash<vector<bool, AL>> {
  using argument_type = vector<bool, AL>;
  using result_type = size_t;
  size_t operator ()(const vector<bool, AL> &v) const {
    return v.hash_code();
  }
};

template <class T, size_t N>
class local_vector : allocator_wrapper<allocator<T>> {
  using this_t = local_vector;

  alignas(T) byte a[sizeof(T) * N];
  size_t sz;

  using alw_t = allocator_wrapper<allocator<T>>;
  using alw_t::allocate;
  using alw_t::construct;
  using alw_t::destroy;
  using alw_t::deallocate;
  using alw_t::destroy_fn;
  using alw_t::new_1;
  using alw_t::new_n;
  using alw_t::delete_1;
  using alw_t::delete_n;
  using alw_t::make_temporary;
  using alw_t::uninitialized_fill;
  using alw_t::uninitialized_copy;
  using alw_t::uninitialized_move;
  using alw_t::uninitialized_fully_move;
  using alw_t::fully_move;

  template <class R>
  static auto begin(R &&r) {return re::begin(r);}
  template <class R>
  static auto end(R &&r) {return re::end(r);}
  template <class R>
  static auto rbegin(R &&r) {return re::rbegin(r);}
  template <class R>
  static auto rend(R &&r) {return re::rend(r);}
  template <class R>
  static auto size(R &&r) {return re::size(r);}
  template <class R>
  static auto empty(R &&r) {return re::empty(r);}

public:
  using pointer = T *;
  using const_pointer = const T *;

  // container

  using value_type = T;
  using reference = value_type &;
  using const_reference = const value_type &;

  using iterator = pointer;
  using const_iterator = const_pointer;
  using difference_type = ptrdiff_t;
  using size_type = size_t;

  iterator begin() noexcept {
    return reinterpret_cast<T *>(addressof(a));
  }
  iterator end() noexcept {
    return begin() + sz;
  }
  const_iterator begin() const noexcept {
    return reinterpret_cast<const T *>(addressof(a));
  }
  const_iterator end() const noexcept {
    return begin() + sz;
  }
  const_iterator cbegin() const noexcept {
    return begin();
  }
  const_iterator cend() const noexcept {
    return end();
  }

  size_type max_size() const noexcept {
    return N;
  }
  size_type size() const noexcept {
    return sz;
  }
  bool empty() const noexcept {
    return sz == 0u;
  }

private:
  // inner implements

  template <class...S>
  reference emplace_back_impl(S &&...s) {
    const auto p = end();
    construct(p, forward<S>(s)...);
    ++sz;
    return *p;
  }
  void pop_back_impl() noexcept {
    --sz;
    destroy(end());
  }
  void pop_back_n_impl(size_type n) noexcept {
    const auto ed = end();
    destroy(rng(ed - n, ed));
    sz -= n;
  }

  template <class...S>
  pointer emplace_impl(pointer p, S &&...s) {
    const auto ed = end();
    if (p == ed) {
      construct(p, forward<S>(s)...);
      ++sz;
    }
    else {
      T tmp(forward<S>(s)...);
      construct(ed, move(*(ed - 1)));
      ++sz;
      move_backward(rng(p, ed - 1), ed);
      *p = move(tmp);
    }
    return p;
  }

  pointer erase_impl(pointer p) noexcept {
    const auto ed = end();
    move(rng(p + 1, ed), p);
    destroy(ed - 1);
    --sz;
    return p;
  }
  pointer erase_range_impl(pointer from, pointer to) noexcept {
    const auto ed = end();
    destroy(rng(move(rng(to, ed), from), ed));
    sz -= to - from;
    return from;
  }

  template <class R>
  void append_range_impl(R &&r) {
    sz = uninitialized_copy(r, end()) - begin();
  }

  template <class R>
  enable_if_t<rng_is_sized<R>, pointer>
  insert_range_impl(pointer p, R &&r) {
    const auto ed = end();
    if (p == ed)
      append_range_impl(r);
    else {
      const auto n = size(r);
      const auto p2 = p + n;
      if (p2 >= ed) {
        const auto new_ed = uninitialized_move(rng(p, ed), p2);
#ifndef RE_NOEXCEPT
        try {
#endif
          uninitialized_copy(rng(copy_from(rng(p, ed), begin(r)), end(r)), ed);
#ifndef RE_NOEXCEPT
        }
        catch (...) {
          destroy(rng(p2, new_ed));
          throw;
        }
#endif
        sz = new_ed - begin();
      }
      else {
        const auto cut = ed - n;
        const auto new_ed = uninitialized_move(rng(cut, ed), ed);
        sz = new_ed - begin();
        move_backward(rng(p, cut), ed);
        copy(r, p);
      }
    }
    return p;
  }
  template <class R>
  enable_if_t<!rng_is_sized<R>, pointer>
  insert_range_impl(pointer p, R &&r) {
    const auto ed = end();
    append_range_impl(r);
    rotate(rng(p, end()), ed);
    return p;
  }

  pointer insert_n_impl(pointer p, size_type n, const value_type &x) {
    return insert_range_impl(p, rng(n, x));
  }

  template <class R>
  void construct_from_range_impl(R &&r) {
    sz = uninitialized_copy(r, begin()) - begin();
  }
  void construct_n_impl(size_type n) {
    uninitialized_fill(rng(begin(), n));
    sz = n;
  }

  template <class R>
  enable_if_t<rng_is_sized<R>> assign_range_impl(R &&r) {
    const auto n = size(r);
    if (n <= sz) {
      destroy(rng(copy(r, begin()), end()));
      sz = n;
    }
    else {
      const auto ed = end();
      const auto r_ed = end(r);
      sz = uninitialized_copy(rng(copy_from(rng(begin(), ed), begin(r)), r_ed),
                              ed)
        - begin();
    }
  }
  template <class R>
  enable_if_t<!rng_is_sized<R>> assign_range_impl(R &&r) {
    auto r1 = rng(*this);
    auto r2 = rng(r);
    for (;; ++r1.first, (void)++r2.first) {
      if (empty(r1)) {
        append_range_impl(r2);
        return;
      }
      if (empty(r2)) {
        erase_range_impl(r1.first, r1.second);
        return;
      }
      *r1.first = *r2.first;
    }
  }

  void resize_impl(size_type n) {
    const auto ed = end();
    if (n < sz)
      erase_range_impl(begin() + n, ed);
    else {
      uninitialized_fill(rng(ed, n - sz));
      sz = n;
    }
  }
  void resize_impl(size_type n, const value_type &x) {
    const auto ed = end();
    if (n < sz)
      erase_range_impl(begin() + n, ed);
    else {
      uninitialized_fill(rng(ed, n - sz), copy(x));
      sz = n;
    }
  }

public:
  // container (continued)

  local_vector() noexcept : sz(0) {}
  ~local_vector() {
    destroy(*this);
  }
  local_vector(const local_vector &v) {
    construct_from_range_impl(v);
  }
  local_vector &operator =(const local_vector &v) {
    if (this != addressof(v))
      assign_range_impl(v);
    return *this;
  }
  local_vector(local_vector &&v)
    noexcept(is_nothrow_move_constructible_v<value_type>) {
    sz = uninitialized_fully_move(v, begin()) - begin();
    v.sz = 0;
  }
  local_vector &operator =(local_vector &&v)
    noexcept(is_nothrow_move_constructible_v<value_type>
             && is_nothrow_move_assignable_v<value_type>) {
    if (this != addressof(v)) {
      if (sz >= v.sz)
        erase_range_impl(fully_move(v, begin()), end());
      else {
        uninitialized_fully_move(rng(v.begin() + sz, v.end()), end());
        adl_swap(sz, v.sz);
        fully_move(v, begin());
      }
      v.sz = 0;
    }
    return *this;
  }
  friend void swap(local_vector &a, local_vector &b)
    noexcept(is_nothrow_swappable_v<T>
             && is_nothrow_move_constructible_v<T>) {
    if (addressof(a) != addressof(b)) {
      const bool y = a.sz < b.sz;
      local_vector &longer = y ? b : a;
      local_vector &shorter = y ? a : b;
      shorter.uninitialized_fully_move(rng(swap_ranges(shorter, longer.begin()),
                                           longer.end()),
                                       shorter.end(),
                                       longer.destroy_fn());
      adl_swap(longer.sz, shorter.sz);
    }
  }

  // optional container operations

  // reversible container

  using reverse_iterator = re::reverse_iterator<iterator>;
  using const_reverse_iterator = re::reverse_iterator<const_iterator>;

  reverse_iterator rbegin() noexcept {
    return reverse_iterator(end());
  }
  reverse_iterator rend() noexcept {
    return reverse_iterator(begin());
  }
  const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator(begin());
  }
  const_reverse_iterator crbegin() const noexcept {
    return rbegin();
  }
  const_reverse_iterator crend() const noexcept {
    return rend();
  }

  // sequence container

  explicit local_vector(size_type n) {
    construct_n_impl(n);
  }
  local_vector(size_type n, const value_type &x) {
    construct_from_range_impl(rng(n, ref(x)));
  }
  void assign(size_type n, const value_type &x) {
    assign_range_impl(rng(n, x));
  }

  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  local_vector(IITR from, IITR to) {
    construct_from_range_impl(rng(from, to));
  }
  template <class IITR>
  enable_if_t<is_itr<IITR>> assign(IITR from, IITR to) {
    assign_range_impl(rng(from, to));
  }

  local_vector(initializer_list<value_type> l) {
    construct_from_range_impl(l);
  }
  local_vector &operator =(initializer_list<value_type> l) {
    assign_range_impl(l);
    return *this;
  }
  void assign(initializer_list<value_type> l) {
    assign_range_impl(l);
  }

  template <class...S>
  iterator emplace(const_iterator pos, S &&...s) {
    return emplace_impl(const_cast<pointer>(pos), forward<S>(s)...);
  }
  iterator insert(const_iterator pos, const value_type &x) {
    return emplace_impl(const_cast<pointer>(pos), x);
  }
  iterator insert(const_iterator pos, value_type &&x) {
    return emplace_impl(const_cast<pointer>(pos), move(x));
  }

  iterator insert(const_iterator pos, size_type n, const value_type &x) {
    return insert_n_impl(const_cast<pointer>(pos), n, x);
  }
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  iterator insert(const_iterator pos, IITR from, IITR to) {
    return insert_range_impl(const_cast<pointer>(pos), rng(from, to));
  }
  iterator insert(const_iterator pos, initializer_list<value_type> l) {
    return insert_range_impl(const_cast<pointer>(pos), l);
  }

  iterator erase(const_iterator pos) {
    return erase_impl(const_cast<pointer>(pos));
  }
  iterator erase(const_iterator from, const_iterator to) {
    return erase_range_impl(const_cast<pointer>(from),
                            const_cast<pointer>(to));
  }

  void clear() noexcept {
    destroy(*this);
    sz = 0;
  }

  // optional sequence container operations

  reference front() {
    return *begin();
  }
  reference back() {
    return *(end() - 1);
  }
  const_reference front() const {
    return *begin();
  }
  const_reference back() const {
    return *(end() - 1);
  }

  template <class...S>
  reference emplace_back(S &&...s) {
    return emplace_back_impl(forward<S>(s)...);
  }
  void push_back(const value_type &x) {
    emplace_back_impl(x);
  }
  void push_back(value_type &&x) {
    emplace_back_impl(move(x));
  }
  void pop_back() {
    pop_back_impl();
  }

  reference operator [](size_type n) {
    return begin()[n];
  }
  const_reference operator [](size_type n) const {
    return begin()[n];
  }
  reference at(size_type n) {
    if (n >= size())
      throw_or_terminate<out_of_range>("re::local_vector: at(n) failed\n");
    return begin()[n];
  }
  const_reference at(size_type n) const {
    if (n >= size())
      throw_or_terminate<out_of_range>("re::local_vector: at(n) failed\n");
    return begin()[n];
  }

  // specialized operations

  template <class UF>
  size_type remove_if(UF eq) {
    const auto i = re::remove_if(*this, eq);
    const auto z = end();
    const size_type ret = z - i;
    erase(i, z);
    return ret;
  }
  template <class X>
  size_type remove(const X &x) {
    return remove_if(bind(equal_to<>(), _1, ref(x)));
  }

  value_type *data() noexcept {
    return begin();
  }
  const value_type *data() const noexcept {
    return begin();
  }
  size_type capacity() const noexcept {
    return N;
  }
  void resize(size_type n) {
    resize_impl(n);
  }
  void resize(size_type n, const value_type &x) {
    resize_impl(n, x);
  }

  bool full() const noexcept {
    return size() == capacity();
  }

  template <class R>
  iterator replace(const_iterator i1, const_iterator i2, R &&r) {
    return inner::fns::seq_container_replace_impl
      (*this, i1 - begin() + begin(), i2 - begin() + begin(), r);
  }

  template <class R>
  local_vector(from_range_t, R &&r)
    requires (is_rng<R> && is_constructible_v<value_type, rng_ref<R>>) {
    construct_from_range_impl(r);
  }
  template <class IITR_RANGE, class = enable_if_t
            <!is_same_v<decay_t<IITR_RANGE>, this_t>
             && is_rng<IITR_RANGE>
             && is_constructible_v<value_type, rng_ref<IITR_RANGE>>>>
  explicit local_vector(IITR_RANGE &&r) {
    construct_from_range_impl(r);
  }
  template <class IITR_RANGE>
  enable_if_t<!is_same_v<decay_t<IITR_RANGE>, this_t>
              && is_rng<IITR_RANGE>
              && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
              && is_assignable_v<value_type &, rng_ref<IITR_RANGE>>, this_t &>
  operator =(IITR_RANGE &&r) {
    assign_range_impl(r);
    return *this;
  }
  template <class IITR_RANGE>
  void assign(IITR_RANGE &&r) {
    assign_range_impl(r);
  }
  template <class IITR_RANGE>
  void assign_range(IITR_RANGE &&r) {
    assign_range_impl(r);
  }

  template <class IITR_RANGE>
  enable_if_t<!is_convertible_v<IITR_RANGE &&, value_type &&>
              && !is_convertible_v<IITR_RANGE &&, const value_type &>,
              iterator>
  insert(const_iterator pos, IITR_RANGE &&r) {
    return insert_range_impl(const_cast<pointer>(pos), r);
  }
  template <class IITR_RANGE>
  iterator insert_range(const_iterator pos, IITR_RANGE &&r) {
    return insert_range_impl(const_cast<pointer>(pos), r);
  }

  template <class IITR_RANGE>
  enable_if_t<!is_convertible_v<IITR_RANGE &&, value_type &&>
              && !is_convertible_v<IITR_RANGE &&, const value_type &>>
  push_back(IITR_RANGE &&r) {
    append_range_impl(r);
  }
  template <class IITR_RANGE>
  void append_range(IITR_RANGE &&r) {
    append_range_impl(r);
  }
  void pop_back(size_type n) {
    pop_back_n_impl(n);
  }

  this_t &append() {
    return *this;
  }
  template <class X, class...S>
  this_t &append(X &&x, S &&...s) {
    push_back(forward<X>(x));
    return append(forward<S>(s)...);
  }
};
template <class T, size_t N>
bool operator ==(const local_vector<T, N> &x, const local_vector<T, N> &y) {
  return equal(x, y);
}
template <class T, size_t N>
synth_3way_result<T> operator <=>(const local_vector<T, N> &x,
                                  const local_vector<T, N> &y) {
  return lexicographical_synth_3way(x, y);
}

namespace inner {

template <class T, size_t N, class AL>
struct small_vector_data {
  alloc_ptr<AL> p;
  alloc_szt<AL> sz;
  union shared_t {
    alloc_szt<AL> cp;
    T buf[N];

    shared_t() {}
    ~shared_t() {}
    shared_t(const shared_t &) = delete;
    shared_t &operator =(const shared_t &) = delete;
    shared_t(shared_t &&) = delete;
    shared_t &operator =(shared_t &&) = delete;
  } shared;

  void set_cp(alloc_szt<AL> x) {
    using t = alloc_szt<AL>;
    new(addressof(shared.cp)) t(x);
  }
  auto in_object_data() noexcept {
    return pointer_to<alloc_ptr<AL>>(shared.buf[0]);
  }
  auto in_object_data() const noexcept {
    return pointer_to<alloc_ptr<AL>>(as_const(shared.buf[0]));
  }
};

}
template <class T, size_t N, class AL = default_allocator<T>>
class small_vector
  : inner::small_vector_data<T, N, AL>, allocator_wrapper<AL> {
  static_assert(N != 0);
  static_assert(is_same_v<T, alloc_vt<AL>>);

  template <class, class>
  friend class pointer_vector;

  using this_t = small_vector;

  using data_t = inner::small_vector_data<T, N, AL>;
  using data_t::p;
  using data_t::sz;
  using data_t::shared;
  using data_t::set_cp;
  using data_t::in_object_data;

  using alw_t = allocator_wrapper<AL>;
  using alw_t::allocate;
  using alw_t::construct;
  using alw_t::destroy;
  using alw_t::deallocate;
  using alw_t::destroy_fn;
  using alw_t::new_1;
  using alw_t::new_n;
  using alw_t::delete_1;
  using alw_t::delete_n;
  using alw_t::make_temporary;
  using alw_t::uninitialized_fill;
  using alw_t::uninitialized_copy;
  using alw_t::uninitialized_move;
  using alw_t::uninitialized_fully_move;
  using alw_t::fully_move;

  template <class R>
  static auto begin(R &&r) {return re::begin(r);}
  template <class R>
  static auto end(R &&r) {return re::end(r);}
  template <class R>
  static auto rbegin(R &&r) {return re::rbegin(r);}
  template <class R>
  static auto rend(R &&r) {return re::rend(r);}
  template <class R>
  static auto size(R &&r) {return re::size(r);}
  template <class R>
  static auto empty(R &&r) {return re::empty(r);}

public:
  using pointer = alloc_ptr<AL>;
  using const_pointer = alloc_cptr<AL>;

  // container

  using value_type = T;
  using reference = value_type &;
  using const_reference = const value_type &;

  using iterator = pointer;
  using const_iterator = const_pointer;
  using difference_type = alloc_dft<AL>;
  using size_type = alloc_szt<AL>;

  iterator begin() noexcept {
    return p;
  }
  iterator end() noexcept {
    return p + sz;
  }
  const_iterator begin() const noexcept {
    return p;
  }
  const_iterator end() const noexcept {
    return p + sz;
  }
  const_iterator cbegin() const noexcept {
    return begin();
  }
  const_iterator cend() const noexcept {
    return end();
  }

  size_type max_size() const noexcept {
    return container_regular_max_size<this_t>();
  }
  size_type size() const noexcept {
    return sz;
  }
  bool empty() const noexcept {
    return sz == 0u;
  }

private:
  // inner implements

  friend class allocator_aware_container_ownership<this_t>;
  const AL &alloc_ref() const noexcept {
    return alw_t::get();
  }
  AL &alloc_ref() noexcept {
    return alw_t::get();
  }
  void new_data() noexcept {
    p = in_object_data();
    sz = 0;
  }
  void delete_data() noexcept {
    destroy(*this);
    deallocate();
  }
  void new_data(const this_t &v) {
    if (v.sz <= N) {
      p = in_object_data();
      sz = v.sz;
    }
    else {
      p = allocate(v.sz);
      sz = v.sz;
      set_cp(sz);
    }
#ifndef RE_NOEXCEPT
    try {
#endif
      uninitialized_copy(v, p);
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      deallocate();
      throw;
    }
#endif
  }
  void assign_data(const this_t &v) {
    if (v.sz <= N) {
    reuse_vec:
      if (sz > v.sz)
        destroy(rng(copy(v, p), end()));
      else
        uninitialized_copy(rng(copy_from(*this, v.begin()), v.end()), end());
    }
    else {
      if (!local()) {
        if (shared.cp >= v.sz)
          goto reuse_vec;
        else {
          destroy(*this);
          deallocate(p, shared.cp);
          goto new_vec;
        }
      }
      else {
        destroy(*this);
      new_vec:
        sz = 0;
        set_cp(v.sz);
#ifndef RE_NOEXCEPT
        p = in_object_data();
#endif
        p = allocate(v.sz);
        uninitialized_copy(v, p);
      }
    }
    sz = v.sz;
  }
  void new_data(this_t &&v) {
    if (!v.local()) {
      p = v.p;
      set_cp(v.shared.cp);
    }
    else {
      p = in_object_data();
#ifndef RE_NOEXCEPT
      sz = 0;
#endif
      uninitialized_fully_move(v, p, v.destroy_fn());
    }
    sz = v.sz;
    v.new_data();
  }
  void new_data_individually(this_t &&v) {
    if (v.sz <= N)
      p = in_object_data();
    else {
      p = allocate(sz);
      set_cp(sz);
    }
    sz = v.sz;
#ifndef RE_NOEXCEPT
    try {
#endif
      uninitialized_fully_move(v, p, v.destroy_fn());
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      deallocate();
      throw;
    }
#endif
    v.deallocate();
    v.new_data();
  }
  void assign_data_individually(this_t &&v) {
    if (capacity() >= v.sz) {
      if (sz < v.sz) {
        uninitialized_fully_move(rng(v.begin() + sz, v.end()), end(),
                                 v.destroy_fn());
        adl_swap(sz, v.sz);
        fully_move(v, begin(), v.destroy_fn());
      }
      else {
        destroy(rng(fully_move(v, begin(), v.destroy_fn()), end()));
        sz = v.sz;
      }
      v.deallocate();
      v.new_data();
    }
    else {
      delete_data();
#ifndef RE_NOEXCEPT
      try {
#endif
        new_data_individually(move(v));
#ifndef RE_NOEXCEPT
      }
      catch (...) {
        new_data();
        throw;
      }
#endif
    }
  }
  void swap_data(this_t &v) {
    swap_data_impl(v);
  }
  template <bool Y = is_trivially_copyable_v<T>
            && is_trivially_copyable_v<pointer>>
  enable_if_t<Y> swap_data_impl(this_t &v) noexcept {
    if (this != addressof(v)) {
      alignas(data_t) byte tmp[sizeof(data_t)];
      void *const p1 = reinterpret_cast<void *>(addressof(tmp));
      void *const p2 = reinterpret_cast<void *>(addressof
                                                (static_cast<data_t &>(*this)));
      void *const p3 = reinterpret_cast<void *>(addressof
                                                (static_cast<data_t &>(v)));
      memcpy(p1, p2, sizeof(data_t));
      memcpy(p2, p3, sizeof(data_t));
      memcpy(p3, p1, sizeof(data_t));
      if (p == v.in_object_data())
        p = in_object_data();
      if (v.p == in_object_data())
        v.p = v.in_object_data();
    }
  }
  template <bool Y = is_trivially_copyable_v<T>
            && is_trivially_copyable_v<pointer>>
  enable_if_t<!Y> swap_data_impl(this_t &v) noexcept {
    if (this != addressof(v)) {
      if (local()) {
        if (v.local()) {
          const bool y = (sz < v.sz);
          this_t &shorter = (y ? *this : v);
          this_t &longer = (y ? v : *this);
          const iterator it = swap_ranges(shorter, longer.begin());
          shorter.uninitialized_fully_move(rng(it, longer.end()),
                                           shorter.end(),
                                           longer.destroy_fn());
        }
        else {
          const auto tmp = v.shared.cp;
          v.uninitialized_fully_move(*this, v.in_object_data(), destroy_fn());
          set_cp(tmp);

          p = v.p;
          v.p = v.in_object_data();
        }
        adl_swap(sz, v.sz);
      }
      else {
        if (!v.local()) {
          adl_swap(p, v.p);
          adl_swap(shared.cp, v.shared.cp);
        }
        else {
          const auto tmp = shared.cp;
          uninitialized_fully_move(v, in_object_data(), v.destroy_fn());
          v.set_cp(tmp);

          v.p = p;
          p = in_object_data();
        }
        adl_swap(sz, v.sz);
      }
    }
  }

public:
  static constexpr size_t local_buffer_size() noexcept {
    return N;
  }
  bool local() const noexcept {
    return in_object_data() == p;
  }
private:
  void deallocate() noexcept {
    if (!local())
      deallocate(p, shared.cp);
  }

  // reallocate_impl(n):
  //   requires: max_size() >= n >= sz && n > 0
  void reallocate_impl(size_type n) {
    if (n <= N) {
      if (!local()) {
        const auto cp_bk = shared.cp;
        const auto bufp = in_object_data();
#ifndef RE_NOEXCEPT
        try {
#endif
          uninitialized_fully_move(*this, bufp);
#ifndef RE_NOEXCEPT
        }
        catch (...) {
          set_cp(cp_bk);
          throw;
        }
#endif
        deallocate(p, cp_bk);
        p = bufp;
      }
    }
    else {
      const auto new_p = allocate(n);
#ifndef RE_NOEXCEPT
      try {
#endif
        uninitialized_fully_move(*this, new_p);
#ifndef RE_NOEXCEPT
      }
      catch (...) {
        deallocate(new_p, n);
        throw;
      }
#endif
      deallocate();
      p = new_p;
      set_cp(n);
    }
  }

  template <class UINT>
  void reserve_raw_space_at_least(UINT n) {
    static_assert(is_integral_v<UINT> && is_unsigned_v<UINT>);
    const auto capa = capacity();
    const size_type rest_n = capa - sz;
    if (n > rest_n) {
      n -= rest_n;
      const size_type cp_rest = max_size() - capa;
      if (cp_rest < n)
        throw_or_terminate<length_error>("re::small_vector: size overflow in "
                                         "reserve_raw_space_at_least(n)\n");
      else
        reallocate_impl((n < capa && cp_rest >= capa)
                        ? capa + capa : capa + n);
    }
  }

  template <class...S>
  reference emplace_back_impl(S &&...s) {
    if (sz != capacity()) {
      const auto pos = to_address(p + sz);
      construct(pos, forward<S>(s)...);
      ++sz;
      return *pos;
    }
    const auto x = make_temporary(forward<S>(s)...);
    reserve_raw_space_at_least(1u);
    const auto pos = to_address(p + sz);
    construct(pos, move(*x));
    ++sz;
    return *pos;
  }
  void pop_back_impl() noexcept {
    --sz;
    destroy(to_address(p + sz));
  }
  void pop_back_n_impl(size_type n) noexcept {
    for (auto &i : iters(p + sz - n, p + sz))
      destroy(i);
    sz -= n;
  }

  template <class...S>
  pointer emplace_impl(const_pointer cpos, S &&...s) {
    auto tmp = make_temporary(forward<S>(s)...);
    auto pos = cpos - p + p;
    if (capacity() == sz) {
      const auto dif = pos - p;
      reserve_raw_space_at_least(1u);
      pos = p + dif;
    }
    const auto ed = p + sz;
    if (pos == ed) {
      construct(to_address(ed), move(*tmp));
      ++sz;
    }
    else {
      construct(to_address(ed), move(*(ed - 1)));
      ++sz;
      move_backward(rng(pos, ed - 1), ed);
      *pos = move(*tmp);
    }
    return pos;
  }

  pointer erase_impl(const_pointer cpos) noexcept {
    const auto pos = cpos - p + p;
    move(rng(pos + 1, p + sz), pos);
    --sz;
    destroy(to_address(p + sz));
    return pos;
  }
  pointer erase_range_impl(const_pointer cfrom,
                           const_pointer cto) noexcept {
    pointer from = cfrom - p + p;
    const pointer to = cto - p + p;
    if (from != to) {
      const auto now = p + sz;
      const auto mid = move(rng(to, now), from);
      destroy(rng(mid, now));
      sz = mid - p;
    }
    return from;
  }

  template <class IITR_RANGE>
  enable_if_t<rng_is_sized<IITR_RANGE>>
  append_range_impl(IITR_RANGE &&r) {
    reserve_raw_space_at_least(size(r));
    sz = uninitialized_copy(r, end()) - begin();
  }
  template <class IITR_RANGE>
  enable_if_t<!rng_is_sized<IITR_RANGE>>
  append_range_impl(IITR_RANGE &&r) {
    for (auto &p : iters(r))
      emplace_back_impl(*p);
  }

  template <class IITR_RANGE>
  enable_if_t<rng_is_sized<IITR_RANGE> || is_fitr<rng_itr<IITR_RANGE>>, pointer>
  insert_range_impl(const_pointer cpos, IITR_RANGE &&r) {
    pointer pos = cpos - p + p;
    pointer now = p + sz;
    const auto pos_dif = pos - p;
    if (pos == now) {
      append_range_impl(r);
      return p + pos_dif;
    }
    else {
      const auto r_sz = size(r);
      reserve_raw_space_at_least(r_sz);
      pos = p + pos_dif;
      now = p + sz;
      const auto pos2 = pos + r_sz;
      const auto new_now = now + r_sz;
      if (pos2 >= now) {
        uninitialized_move(rng(pos, now), pos2);
#ifndef RE_NOEXCEPT
        try {
#endif
          uninitialized_copy(rng(copy_from(rng(pos, now), begin(r)),
                                 end(r)),
                             now);
#ifndef RE_NOEXCEPT
        }
        catch (...) {
          destroy(rng(pos2, new_now));
          throw;
        }
#endif
        sz += r_sz;
      }
      else {
        const auto cut = now - r_sz;
        uninitialized_move(rng(cut, now), now);
        sz += r_sz;
        move_backward(rng(pos, cut), now);
        copy(r, pos);
      }
      return pos;
    }
  }
  template <class IITR_RANGE>
  enable_if_t<!(rng_is_sized<IITR_RANGE> || is_fitr<rng_itr<IITR_RANGE>>),
              pointer>
  insert_range_impl(const_pointer cpos, IITR_RANGE &&r) {
    pointer pos = cpos - p + p;
    const auto dif_pos = pos - p;
    if (pos == p + sz) {
      append_range_impl(r);
      return p + dif_pos;
    }
    else {
      const auto old_sz = sz;
      append_range_impl(r);
      const pointer ret = p + dif_pos;
      rotate(rng(ret, p + sz), p + old_sz);
      return ret;
    }
  }

  template <class SZT>
  void size_check(SZT n) const {
    static_assert(is_integral_v<SZT> && is_unsigned_v<SZT>);
    if (n > max_size())
      throw_or_terminate<length_error>
        ("re::small_vector: size overflow in size_check(n)\n");
  }

  template <class IITR_RANGE>
  enable_if_t<rng_is_sized<IITR_RANGE>>
  construct_from_range_impl(IITR_RANGE &&r) {
    const auto r_sz = size(r);
    size_check(r_sz);

    if (r_sz <= N) {
      p = in_object_data();
      sz = r_sz;
    }
    else {
      p = allocate(r_sz);
      sz = r_sz;
      set_cp(sz);
    }
#ifndef RE_NOEXCEPT
    try {
#endif
      uninitialized_copy(r, p);
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      deallocate();
      throw;
    }
#endif
  }
  template <class IITR_RANGE>
  enable_if_t<!rng_is_sized<IITR_RANGE>>
  construct_from_range_impl(IITR_RANGE &&r) {
    new_data();
#ifndef RE_NOEXCEPT
    try {
#endif
      for (auto &p : iters(r))
        emplace_back_impl(*p);
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      delete_data();
      throw;
    }
#endif
  }

  void construct_n_impl(size_type n) {
    size_check(n);
    if (n <= N)
      p = in_object_data();
    else {
      p = allocate(n);
      set_cp(n);
    }
    sz = n;
#ifndef RE_NOEXCEPT
    try {
#endif
      uninitialized_fill(*this);
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      deallocate();
      throw;
    }
#endif
  }

  template <class IITR_RANGE>
  enable_if_t<rng_is_sized<IITR_RANGE>>
  assign_range_impl(IITR_RANGE &&r) {
    const auto r_sz = size(r);
    if (r_sz <= N) {
    reuse_vec:
      if (sz > r_sz)
        destroy(rng(copy(r, p), p + sz));
      else
        uninitialized_copy(rng(copy_from(*this, begin(r)), end(r)), end());
    }
    else {
      if (!local()) {
        if (shared.cp >= r_sz)
          goto reuse_vec;
        else {
          destroy(*this);
          deallocate(p, shared.cp);
          goto new_vec;
        }
      }
      else {
        destroy(*this);
      new_vec:
#ifndef RE_NOEXCEPT
        new_data();
#endif
        p = allocate(r_sz);
        set_cp(r_sz);
        uninitialized_copy(r, p);
      }
    }
    sz = r_sz;
  }
  template <class IITR_RANGE>
  enable_if_t<!rng_is_sized<IITR_RANGE>>
  assign_range_impl(IITR_RANGE &&r) {
    auto r1 = rng(*this);
    auto r2 = rng(r);
    for (;; ++r1.first, (void)++r2.first) {
      if (empty(r1)) {
        append_range_impl(r2);
        return;
      }
      if (empty(r2)) {
        erase_range_impl(r1.first, r1.second);
        return;
      }
      *r1.first = *r2.first;
    }
  }

  pointer insert_n_impl(const_pointer pp,
                        size_type nn, const value_type &x) {
    const auto tmp = make_temporary(x);
    return insert_range_impl(pp, rng(nn, *tmp));
  }

  void resize_impl(size_type n) {
    if (n < sz)
      erase_range_impl(p + n, p + sz);
    else {
      reserve_raw_space_at_least(n -= sz);
      uninitialized_fill(rng(p + sz, n));
      sz += n;
    }
  }
  void resize_impl(size_type n, const value_type &x) {
    if (n < sz)
      erase_range_impl(p + n, p + sz);
    else {
      const auto tmp = make_temporary(x);
      reserve_raw_space_at_least(n -= sz);
      uninitialized_fill(rng(p + sz, n), *tmp);
      sz += n;
    }
  }
  void reserve_impl(size_type n) {
    if (n > capacity()) {
      if (n > max_size())
        throw_or_terminate<length_error>
          ("re::small_vector: size overflow in reserve_impl(n)\n");
      reallocate_impl(n);
    }
  }
  void shrink_to_fit_impl() {
    reallocate_impl(sz);
  }

public:
  // container (continued)

  small_vector() noexcept(noexcept(AL())) : small_vector(AL()) {}
  ~small_vector() {
    delete_data();
  }
  small_vector(const small_vector &v)
    : alw_t(alw_t::traits
            ::select_on_container_copy_construction(v.alloc_ref())) {
    new_data(v);
  }
  small_vector &operator =(const small_vector &v) {
    allocator_aware_container_ownership<this_t>::copy_assign(*this, v);
    return *this;
  }
  small_vector(small_vector &&v) noexcept(is_nothrow_move_constructible_v<T>)
    : alw_t(move(v.alloc_ref())) {
    new_data(move(v));
  }
  small_vector &operator =(small_vector &&v)
    noexcept((alloc_move_prpg<AL> || alloc_always_equal<AL>)
             && is_nothrow_move_constructible_v<T>
             && is_nothrow_move_assignable_v<T>) {
    allocator_aware_container_ownership<this_t>::move_assign(*this, v);
    return *this;
  }
  friend void swap(small_vector &x, small_vector &y)
    noexcept((alloc_swap_prpg<AL> || alloc_always_equal<AL>)
             && is_nothrow_swappable_v<T>
             && is_nothrow_move_constructible_v<T>) {
    allocator_aware_container_ownership<this_t>::swap(x, y);
  }

  // optional container operations

  // reversible container

  using reverse_iterator = re::reverse_iterator<iterator>;
  using const_reverse_iterator = re::reverse_iterator<const_iterator>;

  reverse_iterator rbegin() noexcept {
    return reverse_iterator(end());
  }
  reverse_iterator rend() noexcept {
    return reverse_iterator(begin());
  }
  const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator(begin());
  }
  const_reverse_iterator crbegin() const noexcept {
    return rbegin();
  }
  const_reverse_iterator crend() const noexcept {
    return rend();
  }

  // allocator-aware container

  using allocator_type = AL;
  allocator_type get_allocator() const noexcept {
    return alw_t::get();
  }

  explicit small_vector(const AL &al) noexcept : alw_t(al) {
    new_data();
  }
  small_vector(const small_vector &v, const AL &al) : alw_t(al) {
    new_data(v);
  }
  small_vector(small_vector &&v, const AL &al) : alw_t(al) {
    allocator_aware_container_ownership<this_t>::move_construct(*this, v);
  }

  // sequence container

  explicit small_vector(size_type n, const AL &al = AL{}) : alw_t(al) {
    construct_n_impl(n);
  }
  small_vector(size_type n, const value_type &x,
               const AL &al = AL{}) : alw_t(al) {
    construct_from_range_impl(rng(n, ref(x)));
  }
  void assign(size_type n, const value_type &x) {
    assign_range_impl(rng(n, x));
  }

  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  small_vector(IITR from, IITR to, const AL &al = AL{}) : alw_t(al) {
    construct_from_range_impl(rng(from, to));
  }
  template <class IITR>
  enable_if_t<is_itr<IITR>> assign(IITR from, IITR to) {
    assign_range_impl(rng(from, to));
  }

  small_vector(initializer_list<value_type> l,
               const AL &al = AL{}) : alw_t(al) {
    construct_from_range_impl(l);
  }
  small_vector &operator =(initializer_list<value_type> l) {
    assign_range_impl(l);
    return *this;
  }
  void assign(initializer_list<value_type> l) {
    assign_range_impl(l);
  }

  template <class...S>
  iterator emplace(const_iterator pos, S &&...s) {
    return emplace_impl(pos, forward<S>(s)...);
  }
  iterator insert(const_iterator pos, const value_type &x) {
    return emplace_impl(pos, x);
  }
  iterator insert(const_iterator pos, value_type &&x) {
    return emplace_impl(pos, move(x));
  }

  iterator insert(const_iterator pos, size_type n, const value_type &x) {
    return insert_n_impl(pos, n, x);
  }
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  iterator insert(const_iterator pos, IITR from, IITR to) {
    return insert_range_impl(pos, rng(from, to));
  }
  iterator insert(const_iterator pos, initializer_list<value_type> l) {
    return insert_range_impl(pos, l);
  }

  iterator erase(const_iterator pos) {
    return erase_impl(pos);
  }
  iterator erase(const_iterator from, const_iterator to) {
    return erase_range_impl(from, to);
  }

  void clear() noexcept {
    destroy(*this);
    sz = 0;
  }

  // optional sequence container operations

  reference front() {
    return *p;
  }
  reference back() {
    return *(p + sz - 1);
  }
  const_reference front() const {
    return *p;
  }
  const_reference back() const {
    return *(p + sz - 1);
  }

  template <class...S>
  reference emplace_back(S &&...s) {
    return emplace_back_impl(forward<S>(s)...);
  }
  void push_back(const value_type &x) {
    emplace_back_impl(x);
  }
  void push_back(value_type &&x) {
    emplace_back_impl(move(x));
  }
  void pop_back() noexcept {
    pop_back_impl();
  }

  reference operator [](size_type n) {
    return p[n];
  }
  const_reference operator [](size_type n) const {
    return p[n];
  }
  reference at(size_type n) {
    if (n >= size())
      throw_or_terminate<out_of_range>("re::small_vector: at(n) failed\n");
    return p[n];
  }
  const_reference at(size_type n) const {
    if (n >= size())
      throw_or_terminate<out_of_range>("re::small_vector: at(n) failed\n");
    return p[n];
  }

  // specialized operations

  value_type *data() noexcept {
    return to_address(p);
  }
  const value_type *data() const noexcept {
    return to_address(p);
  }
  size_type capacity() const noexcept {
    return local() ? N : shared.cp;
  }
  void resize(size_type n) {
    resize_impl(n);
  }
  void resize(size_type n, const value_type &x) {
    resize_impl(n, x);
  }
  void reserve(size_type n) {
    reserve_impl(n);
  }
  void shrink_to_fit() {
    shrink_to_fit_impl();
  }

  // extensions

  template <class UF>
  size_type remove_if(UF eq) {
    const auto i = re::remove_if(*this, eq);
    const auto z = end();
    const size_type ret = z - i;
    erase(i, z);
    return ret;
  }
  template <class X>
  size_type remove(const X &x) {
    return remove_if(bind(equal_to<>(), _1, ref(x)));
  }

  bool full() const noexcept {
    return sz == capacity();
  }

  void reallocate(size_type n) {
    if (const auto z = size(); n < z)
      n = z;
    reallocate_impl(n);
  }
  void reallocate() {
    reallocate(sz);
  }

  void reserve_more(size_type n) {
    reserve_raw_space_at_least(n);
  }

  template <class R>
  iterator replace(const_iterator i1, const_iterator i2, R &&r) {
    return inner::fns::seq_container_replace_impl
      (*this, i1 - begin() + begin(), i2 - begin() + begin(), r);
  }

  template <class R>
  small_vector(from_range_t, R &&r, const allocator_type &al = allocator_type{})
    requires (is_rng<R> && is_constructible_v<value_type, rng_ref<R>>)
    : alw_t(al) {
    construct_from_range_impl(r);
  }
  template <class R, class = enable_if_t
            <!is_same_v<decay_t<R>, this_t>
             && !is_convertible_v<R &&, const allocator_type &>
             && is_rng<R> && is_constructible_v<value_type, rng_ref<R>>>>
  explicit small_vector(R &&r) : small_vector(r, allocator_type{}) {}
  template <class R, class = enable_if_t
            <!is_same_v<decay_t<R>, this_t>
             && is_rng<R> && is_constructible_v<value_type, rng_ref<R>>>>
  small_vector(R &&r, const allocator_type &al) : alw_t(al) {
    construct_from_range_impl(r);
  }
  template <class IITR_RANGE>
  enable_if_t<!is_same_v<decay_t<IITR_RANGE>, this_t>
              && is_rng<IITR_RANGE>
              && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
              && is_assignable_v<value_type &, rng_ref<IITR_RANGE>>, this_t &>
  operator =(IITR_RANGE &&r) {
    assign_range_impl(r);
    return *this;
  }
  template <class IITR_RANGE>
  void assign(IITR_RANGE &&r) {
    assign_range_impl(r);
  }
  template <class IITR_RANGE>
  void assign_range(IITR_RANGE &&r) {
    assign_range_impl(r);
  }

  template <class IITR_RANGE>
  enable_if_t<!is_convertible_v<IITR_RANGE &&, value_type &&>
              && !is_convertible_v<IITR_RANGE &&, const value_type &>,
              iterator>
  insert(const_iterator pos, IITR_RANGE &&r) {
    return insert_range_impl(pos, r);
  }
  template <class IITR_RANGE>
  iterator insert_range(const_iterator pos, IITR_RANGE &&r) {
    return insert_range_impl(pos, r);
  }

  template <class IITR_RANGE>
  enable_if_t<!is_convertible_v<IITR_RANGE &&, value_type &&>
              && !is_convertible_v<IITR_RANGE &&, const value_type &>>
  push_back(IITR_RANGE &&r) {
    append_range_impl(r);
  }
  template <class IITR_RANGE>
  void append_range(IITR_RANGE &&r) {
    append_range_impl(r);
  }
  void pop_back(size_type n) {
    pop_back_n_impl(n);
  }

  this_t &append() {
    return *this;
  }
  template <class X, class...S>
  this_t &append(X &&x, S &&...s) {
    push_back(forward<X>(x));
    return append(forward<S>(s)...);
  }
};
template <class T, size_t N, class AL>
bool operator ==(const small_vector<T, N, AL> &x,
                 const small_vector<T, N, AL> &y) {
  return equal(x, y);
}
template <class T, size_t N, class AL>
synth_3way_result<T> operator <=>(const small_vector<T, N, AL> &x,
                                  const small_vector<T, N, AL> &y) {
  return lexicographical_synth_3way(x, y);
}

template <class T>
concept has_allocator_type = requires {
  typename T::allocator_type;
};
template <class T>
struct conditional_allocator_type {};
template <class T>
requires has_allocator_type<T>
struct conditional_allocator_type<T> {
  using allocator_type = typename T::allocator_type;
};

template <class T, class VEC = vector<T *>>
class pointer_vector;
namespace inner {

template <class T, class IT>
class ptrvec_iterator {
  using this_t = ptrvec_iterator;

  template <class, class>
  friend class re::pointer_vector;
  template <class, class>
  friend class re::inner::ptrvec_iterator;

  IT it;

public:
  using value_type = remove_const_t<T>;
  using difference_type = itr_dft<IT>;
  using pointer = T *;
  using reference = T &;
  using iterator_category
    = conditional_t<is_citr<IT>, random_access_iterator_tag, itr_ctg<IT>>;

  ptrvec_iterator() = default;
  ~ptrvec_iterator() = default;
  ptrvec_iterator(const ptrvec_iterator &) = default;
  ptrvec_iterator &operator =(const ptrvec_iterator &) = default;
  ptrvec_iterator(ptrvec_iterator &&) = default;
  ptrvec_iterator &operator =(ptrvec_iterator &&) = default;
  friend void swap(ptrvec_iterator &x, ptrvec_iterator &y) noexcept {
    adl_swap(x.it, y.it);
  }

  template <class TT = T, class = enable_if_t<is_const_v<TT>>>
  ptrvec_iterator(ptrvec_iterator<remove_const_t<TT>, IT> x) : it(x.it) {}
  template <class TT = T, class = enable_if_t<is_const_v<TT>>>
  ptrvec_iterator &operator =(ptrvec_iterator<remove_const_t<TT>, IT> x) {
    it = x.it;
    return *this;
  }

private:
  template <class>
  friend struct re::inner::fo_make;
  friend struct re::inner::fo_base;
  friend struct re::inner::fo_node;

  explicit ptrvec_iterator(IT it) : it(it) {}
  IT base() const {
    return it;
  }
  auto node() const {
    return *it;
  }

public:
  reference operator *() const {
    return **it;
  }
  pointer operator ->() const {
    return to_address(*it);
  }

  this_t &operator ++() {
    ++it;
    return *this;
  }
  this_t operator ++(int) {
    return this_t(it++);
  }

  this_t &operator --() requires is_bitr<IT> {
    --it;
    return *this;
  }
  this_t operator --(int) requires is_bitr<IT> {
    return this_t(it--);
  }

  reference operator [](difference_type i) const requires is_ritr<IT> {
    return *it[i];
  }
  this_t &operator +=(difference_type i) requires is_ritr<IT> {
    it += i;
    return *this;
  }
  this_t &operator -=(difference_type i) requires is_ritr<IT> {
    it -= i;
    return *this;
  }

  template <class X, class Y, class ITER>
  friend enable_if_t<is_same_v<remove_const_t<X>, remove_const_t<Y>>, bool>
  operator ==(const ptrvec_iterator<X, ITER> &x,
              const ptrvec_iterator<Y, ITER> &y) noexcept;
  template <class X, class Y, class ITER>
  friend enable_if_t<is_same_v<remove_const_t<X>, remove_const_t<Y>>,
                     synth_3way_result<ITER>>
  operator <=>(const ptrvec_iterator<X, ITER> &x,
               const ptrvec_iterator<Y, ITER> &y) noexcept;
  template <class X, class Y, class ITER>
  friend enable_if_t<is_same_v<remove_const_t<X>, remove_const_t<Y>>
                     && itr_is_counted<ITER>,
                     itr_dft<ptrvec_iterator<X, ITER>>>
  operator -(ptrvec_iterator<X, ITER>, ptrvec_iterator<Y, ITER>);
};
template <class X, class Y, class ITER>
enable_if_t<is_same_v<remove_const_t<X>, remove_const_t<Y>>, bool>
operator ==(const ptrvec_iterator<X, ITER> &x,
            const ptrvec_iterator<Y, ITER> &y) noexcept {
  return x.base() == y.base();
}
template <class X, class Y, class ITER>
enable_if_t<is_same_v<remove_const_t<X>, remove_const_t<Y>>,
            synth_3way_result<ITER>>
operator <=>(const ptrvec_iterator<X, ITER> &x,
             const ptrvec_iterator<Y, ITER> &y) noexcept {
  return synth_3way(x.base(), y.base());
}
template <class X, class IT>
ptrvec_iterator<X, IT> operator +(itr_dft<ptrvec_iterator<X, IT>> a,
                                  ptrvec_iterator<X, IT> b)
  requires is_ritr<IT> {
  return b += a;
}
template <class X, class IT>
ptrvec_iterator<X, IT> operator +(ptrvec_iterator<X, IT> a,
                                  itr_dft<ptrvec_iterator<X, IT>> b)
  requires is_ritr<IT> {
  return a += b;
}
template <class X, class IT>
ptrvec_iterator<X, IT> operator -(ptrvec_iterator<X, IT> a,
                                  itr_dft<ptrvec_iterator<X, IT>> b)
  requires is_ritr<IT> {
  return a -= b;
}
template <class X, class Y, class ITER>
enable_if_t<is_same_v<remove_const_t<X>, remove_const_t<Y>>
            && itr_is_counted<ITER>,
            itr_dft<ptrvec_iterator<X, ITER>>>
operator -(ptrvec_iterator<X, ITER> a, ptrvec_iterator<Y, ITER> b) {
  return a.base() - b.base();
}

}
template <class T, class VEC>
class pointer_vector : public conditional_allocator_type<VEC> {
  using this_t = pointer_vector;
  using base_t = VEC;
  mutable VEC vec;

  static_assert(is_same_v
                <typename pointer_traits<typename base_t::value_type>
                 ::element_type, T>);

  base_t &base() noexcept {
    return vec;
  }
  const base_t &base() const noexcept {
    return vec;
  }

private:
  static default_allocator<typename base_t::value_type>
  base_alloc_val() noexcept {
    return default_allocator<typename base_t::value_type>{};
  }
  static auto base_alloc_val() noexcept
    requires has_allocator_type<base_t> {
    return typename base_t::allocator_type{};
  }
  using base_alloc_t = decltype(base_alloc_val());

  static default_allocator<T> alloc_val() noexcept {
    return default_allocator<T>{};
  }
  static auto alloc_val() noexcept requires has_allocator_type<base_t> {
    return alloc_rebind<typename base_t::allocator_type, T>{};
  }
  using alloc_t = decltype(alloc_val());

  auto node_alw() const noexcept {
    return allocator_wrapper<default_allocator<T>>{};
  }
  auto node_alw() const noexcept requires has_allocator_type<base_t> {
    return allocator_wrapper<alloc_t>(alloc_t(vec.get_allocator()));
  }

  template <class R>
  static auto begin(R &&r) {return re::begin(r);}
  template <class R>
  static auto end(R &&r) {return re::end(r);}
  template <class R>
  static auto rbegin(R &&r) {return re::rbegin(r);}
  template <class R>
  static auto rend(R &&r) {return re::rend(r);}
  template <class R>
  static auto size(R &&r) {return re::size(r);}
  template <class R>
  static auto empty(R &&r) {return re::empty(r);}

public:
  using pointer = typename base_t::value_type;
  using const_pointer = pointer_rebind_t<pointer, const T>;

  // container

  using value_type = T;
  using reference = value_type &;
  using const_reference = const value_type &;

  using iterator = inner::ptrvec_iterator
    <value_type, typename base_t::iterator>;
  using const_iterator = inner::ptrvec_iterator
    <const value_type, typename base_t::iterator>;
  using difference_type = typename base_t::difference_type;
  using size_type = typename base_t::size_type;

  iterator begin() noexcept {
    return iterator(vec.begin());
  }
  iterator end() noexcept {
    return iterator(vec.end());
  }
  const_iterator begin() const noexcept {
    return const_iterator(vec.begin());
  }
  const_iterator end() const noexcept {
    return const_iterator(vec.end());
  }
  const_iterator cbegin() const noexcept {
    return begin();
  }
  const_iterator cend() const noexcept {
    return end();
  }

  size_type max_size() const noexcept {
    return vec.max_size();
  }
  size_type size() const noexcept {
    return vec.size();
  }
  bool empty() const noexcept {
    return vec.empty();
  }

private:
  // inner implements

  template <class R>
  void construct_from_range(R &&r) {
#ifndef RE_NOEXCEPT
    try {
#endif
      append_range(r);
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      for (auto p : base())
        delete_node(p);
      throw;
    }
#endif
  }

public:
  // node operations

  template <class...S>
  pointer new_node(S &&...s) {
    return node_alw().new_1(forward<S>(s)...);
  }
  void delete_node(pointer p) noexcept {
    node_alw().delete_1(p);
  }
  pointer exchange_node(const_iterator old, pointer p) noexcept {
    const pointer ret = *old.base();
    *old.base() = p;
    return ret;
  }

  iterator link(const_iterator i, pointer p) noexcept {
    return iterator(base().insert(i.base(), p));
  }
  iterator link_front(pointer p) noexcept {
    base().push_front(p);
    return iterator(base().begin());
  }
  iterator link_back(pointer p) noexcept {
    base().push_back(p);
    return iterator(prev(base().end()));
  }
  pointer unlink(const_iterator i) noexcept {
    const auto ret = i.node();
    base().erase(i.base());
    return ret;
  }
  void unlink(const_iterator from, const_iterator to) noexcept {
    base().erase(from.base(), to.base());
  }
  void unlink() noexcept {
    base().clear();
  }
  iterator unlink_front() noexcept {
    base().pop_front();
    return begin();
  }
  iterator unlink_back() noexcept {
    base().pop_back();
    return end();
  }

  // container (continued)

  pointer_vector() = default;
  ~pointer_vector() {
    for (auto p : base())
      delete_node(p);
  }
  pointer_vector(const pointer_vector &x) : vec(x.base()) {
    securely_initialize(base(), [&](auto p) {*p = new_node(**p);},
                        [&](auto p) {delete_node(*p);});
  }
  pointer_vector &operator =(const pointer_vector &x) {
    if constexpr (has_allocator_type<base_t> && alloc_copy_prpg<alloc_t>) {
      if (this != addressof(x)) {
        if (base().get_allocator() == x.base().get_allocator()) {
          base().alloc_ref() = x.base().alloc_ref();
          if (size() >= x.size())
            erase(copy(x, begin()), end());
          else
            append_range(rng(copy_from(*this, x.begin()), x.end()));
        }
        else {
          auto tmp = x.base();
          auto a = node_alw();
          for (auto p : base())
            a.delete_1(p);
          base() = tmp;
#ifndef RE_NOEXCEPT
          try {
#endif
            securely_initialize(base(), [&](auto p) {*p = new_node(**p);},
                                [&](auto p) {delete_node(*p);});
#ifndef RE_NOEXCEPT
          }
          catch (...) {
            base().clear();
            throw;
          }
#endif
        }
      }
      return *this;
    }
    else {
      if (this != addressof(x)) {
        if (size() >= x.size())
          erase(copy(x, begin()), end());
        else
          append_range(rng(copy_from(*this, x.begin()), x.end()));
      }
      return *this;
    }
  }
  pointer_vector(pointer_vector &&x)
    noexcept(is_nothrow_move_constructible_v<base_t>) : vec(move(x.base())) {}
  pointer_vector &operator =(pointer_vector &&x)
    noexcept(is_nothrow_move_assignable_v<base_t>) {
    if constexpr (has_allocator_type<base_t> && alloc_move_prpg<alloc_t>) {
      if (this != addressof(x)) {
        auto a = node_alw();
        for (auto p : base())
          a.delete_1(p);
        base() = move(x.base());
      }
      return *this;
    }
    else {
      if (this != addressof(x)) {
        if (base().get_allocator() == x.base().get_allocator()) {
          auto a = node_alw();
          for (auto p : base())
            a.delete_1(p);
          base() = move(x.base());
        }
        else {
          if (size() >= x.size())
            erase(move(x, begin()), end());
          else
            append_range(move_rng(rng(move_from(*this, x.begin()), x.end())));
          x.clear();
        }
      }
      return *this;
    }
  }
  friend void swap(pointer_vector &x, pointer_vector &y)
    noexcept(is_nothrow_swappable_v<base_t>) {
    if constexpr (has_allocator_type<base_t> && alloc_swap_prpg<alloc_t>) {
      adl_swap(x.base(), y.base());
    }
    else {
      if (x.get_allocator() == y.get_allocator())
        adl_swap(x.base(), y.base());
      else {
        if (addressof(x) != addressof(y)) {
          this_t *longer_p, *shorter_p;
          if (x.size() > y.size()) {
            longer_p = addressof(x);
            shorter_p = addressof(y);
          }
          else {
            longer_p = addressof(y);
            shorter_p = addressof(x);
          }
          const auto i = swap_ranges(*shorter_p, (*longer_p).begin());
          const auto shorter_sz_bk = shorter_p->size();
          shorter_p->append_range(move_rng(i, longer_p->end()));
          longer_p->erase(i, longer_p->end());
        }
      }
    }
  }

  // reversible container

  using reverse_iterator = re::reverse_iterator<iterator>;
  using const_reverse_iterator = re::reverse_iterator<const_iterator>;

  reverse_iterator rbegin() noexcept {
    return reverse_iterator(end());
  }
  reverse_iterator rend() noexcept {
    return reverse_iterator(begin());
  }
  const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator(begin());
  }
  const_reverse_iterator crbegin() const noexcept {
    return rbegin();
  }
  const_reverse_iterator crend() const noexcept {
    return rend();
  }

  // allocator-aware container

  auto get_allocator() const noexcept
    requires has_allocator_type<base_t> {
    return base().get_allocator();
  }

  explicit pointer_vector(const alloc_t &a) noexcept
    requires has_allocator_type<base_t>
    : vec(base_alloc_t(a)) {}
  pointer_vector(const pointer_vector &x, const alloc_t &a)
    requires has_allocator_type<base_t>
    : vec(x.base(), base_alloc_t(a)) {
    securely_initialize(base(), [&](auto p) {*p = new_node(**p);},
                        [&](auto p) {delete_node(*p);});
  }
  pointer_vector(pointer_vector &&x, const alloc_t &a)
    requires has_allocator_type<base_t>
    : vec(x.base(), a) {
    if (x.get_allocator() != a) {
      securely_initialize(base(), [&](auto p) {*p = new_node(**p);},
                          [&](auto p) {delete_node(*p);});
      x.clear();
    }
    else
      x.base().clear();
  }

  // sequence container

  explicit pointer_vector(size_type n) : vec(n) {
    securely_initialize(base(), [&](auto p) {*p = new_node();},
                        [&](auto p) {delete_node(*p);});
  }
  explicit pointer_vector(size_type n, const alloc_t &a)
    requires has_allocator_type<base_t> : vec(n, base_alloc_t(a)) {
    securely_initialize(base(), [&](auto p) {*p = new_node();},
                        [&](auto p) {delete_node(*p);});
  }
  pointer_vector(size_type n, const value_type &x) : vec(n) {
    securely_initialize(base(), [&](auto p) {*p = new_node(x);},
                        [&](auto p) {delete_node(*p);});
  }
  pointer_vector(size_type n, const value_type &x,
                 const alloc_t &a) : vec(n, base_alloc_t(a)) {
    securely_initialize(base(), [&](auto p) {*p = new_node(x);},
                        [&](auto p) {delete_node(*p);});
  }
  void assign(size_type n, const value_type &x) {
    assign_range(rng(n, x));
  }

  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  pointer_vector(IITR from, IITR to) : vec{} {
    construct_from_range(rng(from, to));
  }
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  pointer_vector(IITR from, IITR to, const alloc_t &a)
    requires has_allocator_type<base_t> : vec(base_alloc_t(a)) {
    construct_from_range(rng(from, to));
  }
  template <class IITR>
  enable_if_t<is_itr<IITR>> assign(IITR from, IITR to) {
    assign_range(rng(from, to));
  }

  pointer_vector(initializer_list<value_type> l) : vec{} {
    construct_from_range(l);
  }
  pointer_vector(initializer_list<value_type> l, const alloc_t &a)
    requires has_allocator_type<base_t> : vec(a) {
    construct_from_range(l);
  }
  pointer_vector &operator =(initializer_list<value_type> l) {
    assign_range(l);
    return *this;
  }
  void assign(initializer_list<value_type> l) {
    assign_range(l);
  }

  template <class...S>
  iterator emplace(const_iterator i, S &&...s) {
    const auto p = new_node(forward<S>(s)...);
    iterator ret;
#ifndef RE_NOEXCEPT
    try {
#endif
      ret = iterator(base().insert(i.base(), p));
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      delete_node(p);
      throw;
    }
#endif
    return ret;
  }
  iterator insert(const_iterator i, const value_type &x) {
    return emplace(i, x);
  }
  iterator insert(const_iterator i, value_type &&x) {
    return emplace(i, move(x));
  }

  iterator insert(const_iterator i, size_type n, const value_type &x) {
    return insert_range(i, rng(n, x));
  }
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  iterator insert(const_iterator i, IITR from, IITR to) {
    return insert_range(i, rng(from, to));
  }
  iterator insert(const_iterator i, initializer_list<value_type> l) {
    return insert_range(i, l);
  }

  iterator erase(const_iterator i) {
    delete_node(i.node());
    return iterator(base().erase(i.base()));
  }
  iterator erase(const_iterator from, const_iterator to) {
    for (auto p : rng(from.base(), to.base()))
      delete_node(p);
    return iterator(base().erase(from.base(), to.base()));
  }

  void clear() noexcept {
    for (auto p : base())
      delete_node(p);
    base().clear();
  }

  // optional sequence container operations

  reference front() {
    return *base().front();
  }
  reference back() {
    return *base().back();
  }
  const_reference front() const {
    return *base().front();
  }
  const_reference back() const {
    return *base().back();
  }

  template <class...S>
  reference emplace_back(S &&...s) {
    const auto p = new_node(forward<S>(s)...);
#ifndef RE_NOEXCEPT
    try {
#endif
      base().push_back(p);
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      delete_node(p);
      throw;
    }
#endif
    return *p;
  }
  void push_back(const value_type &x) {
    emplace_back(x);
  }
  void push_back(value_type &&x) {
    emplace_back(move(x));
  }
  void pop_back() noexcept {
    delete_node(base().back());
    base().pop_back();
  }

  template <class...S>
  reference emplace_front(S &&...s) {
    const auto p = new_node(forward<S>(s)...);
#ifndef RE_NOEXCEPT
    try {
#endif
      base().push_front(p);
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      delete_node(p);
      throw;
    }
#endif
    return front();
  }
  void push_front(const value_type &x) {
    emplace_front(x);
  }
  void push_front(value_type &&x) {
    emplace_front(move(x));
  }
  void pop_front() noexcept {
    delete_node(base().front());
    base().pop_front();
  }

  reference operator [](size_type n) {
    return begin()[n];
  }
  const_reference operator [](size_type n) const {
    return begin()[n];
  }
  reference at(size_type n) {
    if (n >= size())
      throw_or_terminate<out_of_range>("re::pointer_vector: at(n) failed\n");
    return begin()[n];
  }
  const_reference at(size_type n) const {
    if (n >= size())
      throw_or_terminate<out_of_range>("re::pointer_vector: at(n) failed\n");
    return begin()[n];
  }

  // specialized operations

  size_type capacity() const noexcept {
    return base().capacity();
  }
  void resize(size_type n) {
    if (n > size()) {
      const auto k = n - size();
      base().resize(n);
#ifndef RE_NOEXCEPT
      try {
#endif
        securely_initialize(rng(base().end() - k, base().end()),
                            [&](auto p) {*p = new_node();},
                            [&](auto p) {delete_node(*p);});
#ifndef RE_NOEXCEPT
      }
      catch (...) {
        base().resize(size() - k);
        throw;
      }
#endif
    }
    else
      pop_back(size() - n);
  }
  void resize(size_type n, const value_type &x) {
    if (n > size())
      append_range(rng(n - size(), x));
    else
      pop_back(size() - n);
  }
  void reserve(size_type n) {
    base().reserve(n);
  }
  void shrink_to_fit() {
    base().shrink_to_fit();
  }

  // list operations

  void splice(const_iterator next, this_t &l) {
    const auto dif = distance(cbegin(), next);
    base().insert_range(next.base(), l.base());
    l.base().clear();
  }
  void splice(const_iterator next, this_t &&l) {
    splice(next, l);
  }
  void splice(const_iterator next,
              this_t &l, const_iterator i) {
    if (this == addressof(l)) {
      if (next != i) {
        const auto p = i.node();
        if (next < i) {
          copy_backward(rng(next.base(), i.base()), re::next(i).base());
          *next.base() = p;
        }
        else
          *copy(rng(re::next(i).base(), next.base()), i.base()) = p;
      }
    }
    else
      insert(next, l.extract(i));
  }
  void splice(const_iterator next, this_t &&l, const_iterator i) {
    splice(next, l, i);
  }
  void splice(const_iterator next, this_t &l,
              const_iterator from, const_iterator to) {
    if (this == addressof(l)) {
      if (next < from)
        rotate(rng(next.base(), to.base()), from.base());
      else if (next > to)
        rotate(rng(from.base(), next.base()), to.base());
    }
    else {
      base().insert(next.base(), rng(from.base(), to.base()));
      l.base().erase(from.base(), to.base());
    }
  }
  void splice(const_iterator next, this_t &&l,
              const_iterator from, const_iterator to) {
    splice(next, l, from, to);
  }

  void swap(const_iterator x, const_iterator y) noexcept {
    adl_swap(*x.base(), *y.base());
  }
  void swap(const_iterator x, this_t &l, const_iterator y) noexcept {
    adl_swap(*x.base(), *y.base());
  }

  template <class UPRED>
  size_type remove_if(UPRED eq) {
    auto &r = base();
    using R = decltype(r);

    rng_szt<R> ret = 0u;
    const auto eq2 = bind(eq, bind(deref, _1));
    auto it = find_if(r, eq2);
    if (it != end(r)) {
      ++ret;
      for (auto &it2 : iters(next(it), end(r))) {
        if (!eq2(*it2)) {
          adl_swap(*it, *it2);
          ++it;
        }
        else
          ++ret;
      }
    }
    erase(iterator(it), end());

    return ret;
  }
  size_type remove(const value_type &x) {
    return remove_if([&x](const value_type &y) {return x == y;});
  }

  template <class BPRED>
  void unique(BPRED eq) {
    auto it = adjacent_find(base(), bind(eq, bind(deref, _1), bind(deref, _2)));
    if (it != base().end()) {
      delete_node(*next(it));
      for (auto &p : iters(next(it, 2), base().end())) {
#ifndef RE_NOEXCEPT
        try {
#endif
          if (!eq(**it, **p))
            *++it = *p;
          else
            delete_node(*p);
#ifndef RE_NOEXCEPT
        }
        catch (...) {
          for (auto pp : rng(p, base().end()))
            delete_node(pp);
          base().erase(next(it), base().end());
          throw;
        }
#endif
      }
      base().erase(next(it), base().end());
    }
  }
  void unique() {
    unique(equal_to<>());
  }

  template <class BPRED>
  void merge(this_t &l, BPRED less) {
    if (addressof(l) == this)
      return;
    base_t tmp(base().get_allocator());
    tmp.reserve((max_size() - size() >= l.size())
                ? (size() + l.size()) : max_size());
    re::merge(base(), l.base(), back_inserter(tmp),
              bind(less, bind(deref, _1), bind(deref, _2)));
    l.base().clear();
    adl_swap(base(), tmp);
  }
  template <class BPRED>
  void merge(this_t &&l, BPRED less) {
    merge(l, less);
  }
  void merge(this_t &l) {
    merge(l, less<>());
  }
  void merge(this_t &&l) {
    merge(l, less<>());
  }

  void reverse() noexcept {
    re::reverse(base());
  }

  template <class BPRED>
  void sort(BPRED less) {
    re::sort(base(), bind(less, bind(deref, _1), bind(deref, _2)));
  }
  void sort() {
    sort(less<>());
  }

  // extensions

  bool full() const noexcept {
    return base().full();
  }

  void reserve_more(size_type n) {
    base().reserve_more(n);
  }

  void reallocate(size_type n) {
    base().reallocate(n);
  }
  void reallocate() {
    base().reallocate();
  }

  template <class R>
  iterator replace(const_iterator i1, const_iterator i2, R &&r) {
    return inner::fns::seq_container_replace_impl
      (*this, i1 - begin() + begin(), i2 - begin() + begin(), r);
  }

  using node_type = typename allocator_wrapper<alloc_t>::unique_ptr;
  template <class...S>
  node_type make_node(S &&...s) {
    using d_t = typename node_type::deleter_type;
    return node_type(new_node(forward<S>(s)...), d_t(get_allocator()));
  }
  node_type extract(const_iterator ci) noexcept {
    const auto p = ci.node();
    unlink(ci);
    using d_t = typename node_type::deleter_type;
    return node_type(p, d_t(get_allocator()));
  }
  iterator insert(const_iterator ci, node_type &&x) {
    if (!x.empty()) {
      const auto ret = link(ci, x.get());
      x.release();
      return ret;
    }
    else
      return iterator(ci.base());
  }
  void push_back(node_type &&x) {
    if (!x.empty()) {
      link_back(x.get());
      x.release();
    }
  }
  void push_front(node_type &&x) {
    if (!x.empty()) {
      link_front(x.get());
      x.release();
    }
  }
  node_type exchange(const_iterator ci, node_type &x) noexcept {
    using d_t = typename node_type::deleter_type;
    const auto p = (!x.empty()) ? exchange_node(ci, x.release()) : unlink(ci);
    return node_type(p, d_t(get_allocator()));
  }
  node_type exchange(const_iterator ci, node_type &&x) noexcept {
    return exchange(ci, x);
  }
  iterator replace(const_iterator ci, node_type &&x) noexcept {
    if (!x.empty()) {
      const iterator ret(ci.base());
      const auto p = x.release();;
      delete_node(exchange_node(ci, p));
      return ret;
    }
    else
      return erase(ci);
  }

  this_t extract(const_iterator ci, const_iterator ci2) {
    this_t l(get_allocator());
    l.splice(l.end(), *this, ci, ci2);
    return l;
  }
  iterator insert(const_iterator ci, this_t &&l) {
    const auto dif = ci - begin();
    splice(ci, l);
    return begin() + dif;
  }
  void push_back(this_t &&l) {
    splice(end(), l);
  }
  void push_front(this_t &&l) {
    splice(begin(), l);
  }
  this_t exchange(const_iterator ci, const_iterator ci2, this_t &x) {
    this_t ret = extract(ci, ci2);
    insert(ci, move(x));
    return ret;
  }
  this_t exchange(const_iterator ci, const_iterator ci2, this_t &&x) {
    return exchange(ci, ci2, x);
  }
  iterator replace(const_iterator ci, const_iterator ci2, this_t &&x) {
    erase(ci, ci2);
    return insert(ci, move(x));
  }

  template <class R>
  pointer_vector(from_range_t, R &&r)
    requires (is_rng<R> && is_constructible_v<value_type, rng_ref<R>>)
    : vec{} {
    construct_from_range(r);
  }
  template <class R>
  pointer_vector(from_range_t, R &&r, const alloc_t &al)
    requires (has_allocator_type<base_t>
              && is_rng<R> && is_constructible_v<value_type, rng_ref<R>>)
    : vec(base_alloc_t(al)) {
    construct_from_range(r);
  }
  template <class R, class = enable_if_t
            <!is_same_v<decay_t<R>, this_t>
             && !is_convertible_v<R &&, const alloc_t &>
             && is_rng<R> && is_constructible_v<value_type, rng_ref<R>>>>
  explicit pointer_vector(R &&r) : vec{} {
    construct_from_range(r);
  }
  template <class R, class = enable_if_t
            <!is_same_v<decay_t<R>, this_t>
             && has_allocator_type<base_t>
             && is_rng<R> && is_constructible_v<value_type, rng_ref<R>>>>
  pointer_vector(R &&r, const alloc_t &al) : vec(base_alloc_t(al)) {
    construct_from_range(r);
  }
  template <class IITR_RANGE>
  enable_if_t<!is_same_v<decay_t<IITR_RANGE>, this_t>
              && is_rng<IITR_RANGE>
              && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
              && is_assignable_v<value_type &, rng_ref<IITR_RANGE>>, this_t &>
  operator =(IITR_RANGE &&r) {
    assign_range(r);
    return *this;
  }
  template <class IITR_RANGE>
  void assign(IITR_RANGE &&r) {
    assign_range(r);
  }
  template <class IITR_RANGE>
  void assign_range(IITR_RANGE &&r) {
    if constexpr (rng_is_sized<IITR_RANGE &&>) {
      if (size() <= size(r))
        append_range(rng(copy_from(*this, begin(r)), end(r)));
      else
        erase(copy(r, begin()), end());
    }
    else {
      auto r1 = rng(*this);
      auto r2 = rng(r);
      for (;; ++r1.first, (void)++r2.first) {
        if (empty(r1)) {
          append_range(r2);
          return;
        }
        if (empty(r2)) {
          erase(r1.first, r1.second);
          return;
        }
        *r1.first = *r2.first;
      }
    }
  }

  template <class IITR_RANGE>
  enable_if_t<!is_convertible_v<IITR_RANGE &&, value_type &&>
              && !is_convertible_v<IITR_RANGE &&, const value_type &>
              && !is_convertible_v<IITR_RANGE &&, node_type &&>
              && !is_convertible_v<IITR_RANGE &&, this_t &&>,
              iterator>
  insert(const_iterator pos, IITR_RANGE &&r) {
    return insert_range(pos, r);
  }
  template <class IITR_RANGE>
  iterator insert_range(const_iterator pos, IITR_RANGE &&r) {
    const auto old_ed_dif = to_signed(base().size());
    const auto pos_dif = pos.base() - base().begin();
    for (auto &p : iters(r)) {
      const auto pp = new_node(*p);
#ifndef RE_NOEXCEPT
      try {
#endif
        base().push_back(pp);
#ifndef RE_NOEXCEPT
      }
      catch (...) {
        delete_node(pp);
        throw;
      }
#endif
    }
    const auto ret = base().begin() + pos_dif;
    rotate(rng(ret, base().end()), base().begin() + old_ed_dif);
    return iterator(ret);
  }

  template <class IITR_RANGE>
  enable_if_t<!is_convertible_v<IITR_RANGE &&, value_type &&>
              && !is_convertible_v<IITR_RANGE &&, const value_type &>
              && !is_convertible_v<IITR_RANGE &&, node_type &&>
              && !is_convertible_v<IITR_RANGE &&, this_t &&>>
  push_back(IITR_RANGE &&r) {
    append_range(r);
  }
  template <class IITR_RANGE>
  void append_range(IITR_RANGE &&r) {
    node_type up;
    base().append_range(bind_rng(r, [&]<class U>(U &&x) {
      up.release();
      up = node_alw().make_unique(forward<U>(x));
      return up.get();
    }));
    up.release();
  }
  void pop_back(size_type n) {
    for (; n != 0; --n)
      pop_back();;
  }

  template <class IITR_RANGE>
  enable_if_t<!is_convertible_v<IITR_RANGE &&, value_type &&>
              && !is_convertible_v<IITR_RANGE &&, const value_type &>
              && !is_convertible_v<IITR_RANGE &&, node_type &&>
              && !is_convertible_v<IITR_RANGE &&, this_t &&>>
  push_front(IITR_RANGE &&r) {
    prepend_range(r);
  }
  template <class IITR_RANGE>
  void prepend_range(IITR_RANGE &&r) {
    node_type up;
    base().prepend_range(bind_rng(r, [&]<class U>(U &&x) {
      up.release();
      up = node_alw().make_unique(forward<U>(x));
      return up.get();
    }));
    up.release();
  }
  void pop_front(size_type n) {
    for (; n != 0; --n)
      pop_front();
  }

  this_t &append() {
    return *this;
  }
  template <class X, class...S>
  this_t &append(X &&x, S &&...s) {
    push_back(forward<X>(x));
    return append(forward<S>(s)...);
  }

  this_t &prepend() {
    return *this;
  }
  template <class X, class...S>
  this_t &prepend(X &&x, S &&...s) {
    prepend(forward<S>(s)...);
    push_front(forward<X>(x));
    return *this;
  }
};
template <class T, class VEC>
bool operator ==(const pointer_vector<T, VEC> &x,
                 const pointer_vector<T, VEC> &y) {
  return equal(x, y);
}
template <class T, class VEC>
synth_3way_result<T> operator <=>(const pointer_vector<T, VEC> &x,
                                  const pointer_vector<T, VEC> &y) {
  return lexicographical_synth_3way(x, y);
}

}

// circular_vector
namespace re {

template <class, class>
class circular_vector;
namespace inner {

template <class AL>
struct circular_vector_head {
  alloc_ptr<AL> op;
  alloc_ptr<AL> ed;
  alloc_ptr<AL> data_op;
  alloc_ptr<AL> data_ed;
};

template <class AL>
struct circular_vector_data {
  using bufp_t = typename allocator_wrapper<alloc_rebind<AL, byte>>
    ::template headed_buffer_ptr<circular_vector_head<AL>, alloc_vt<AL>>;

  bufp_t bufp;

  static void init_impl(bufp_t &bufp) {
    static circular_vector_head<AL> placeholder
      {nullptr, alloc_ptr<AL>(nullptr) + 1, nullptr, nullptr};
    bufp.refer_to_only_head(placeholder);
  }
  void init() {
    init_impl(bufp);
  }
};
  
template <class T, class AL>
class circular_vector_iterator {
  using this_t = circular_vector_iterator;

  template <class, class>
  friend class circular_vector_iterator;
  template <class, class>
  friend class re::circular_vector;

public:
  using value_type = remove_const_t<T>;
  using reference = T &;
  using pointer = T *;
  using difference_type = alloc_dft<AL>;
  using iterator_category = random_access_iterator_tag;

private:
  using stored_pointer = alloc_ptr<AL>;
  using shared_data_pointer = alloc_rebind_ptr<AL, circular_vector_head<AL>>;

  stored_pointer p;
  shared_data_pointer shared_p;

public:
  circular_vector_iterator() = default;
  ~circular_vector_iterator() = default;
  circular_vector_iterator(const this_t &) = default;
  this_t &operator =(const this_t &) = default;
  circular_vector_iterator(this_t &&) = default;
  this_t &operator =(this_t &&) = default;
  friend void swap(this_t &x, this_t &y) noexcept {
    adl_swap(x.p, y.p);
    adl_swap(x.shared_p, y.shared_p);
  }

  template <class TT = T, class = enable_if_t<is_const_v<TT>>>
  circular_vector_iterator(circular_vector_iterator<remove_const_t<TT>, AL> x)
    : p(x.p), shared_p(x.shared_p) {}
  template <class TT = T, class = enable_if_t<is_const_v<TT>>>
  this_t &operator =(circular_vector_iterator<remove_const_t<TT>, AL> x) {
    p = x.p;
    shared_p = x.shared_p;
    return *this;
  }

private:
  template <class>
  friend struct re::inner::fo_make;
  friend struct re::inner::fo_to_mutable;

  circular_vector_iterator(stored_pointer p1, shared_data_pointer p2)
    : p(p1), shared_p(p2) {}
  auto to_mutable() const requires is_const_v<T> {
    return circular_vector_iterator<remove_const_t<T>, AL>(p, shared_p);
  }

public:
  reference operator *() const {
    return *p;
  }
  T *operator ->() const {
    return to_address(p);
  }
  template <class TT, class TTT, class AL2>
  friend enable_if_t<is_same_v<remove_const_t<TT>, remove_const_t<TTT>>, bool>
  operator ==(circular_vector_iterator<TT, AL2>,
              circular_vector_iterator<TTT, AL2>);

  this_t &operator ++() {
    ++p;
    if (p == shared_p->ed)
      p = shared_p->op;
    return *this;
  }
  this_t operator ++(int) {
    return iter_post_increment(*this);
  }

  this_t &operator --() {
    if (p == shared_p->op)
      p = shared_p->ed;
    --p;
    return *this;
  }
  this_t operator --(int) {
    return iter_post_decrement(*this);
  }

  this_t &operator +=(difference_type i) {
    if (i != 0) {
      if (i > 0) {
        const auto rest = shared_p->ed - p;
        p = (i < rest) ? (p + i) : (shared_p->op + (i - rest));
      }
      else {
        i = -i;
        const auto rest = p - shared_p->op;
        p = (i <= rest) ? (p - i) : (shared_p->ed - (i - rest));
      }
    }
    return *this;
  }
  this_t &operator -=(difference_type i) {
    return operator +=(-i);
  }
  reference operator [](difference_type i) const {
    return *(copy(*this) += i);
  }
  template <class TT, class TTT, class AL2>
  friend enable_if_t<is_same_v<remove_const_t<TT>, remove_const_t<TTT>>,
                     itr_dft<circular_vector_iterator<TT, AL2>>>
  operator -(circular_vector_iterator<TTT, AL2>,
             circular_vector_iterator<TT, AL2>);
  template <class TT, class TTT, class AL2>
  friend enable_if_t<is_same_v<remove_const_t<TT>, remove_const_t<TTT>>,
                     synth_3way_result<alloc_ptr<AL2>>>
  operator <=>(circular_vector_iterator<TT, AL2>,
               circular_vector_iterator<TTT, AL2>);
};
template <class TT, class TTT, class AL2>
enable_if_t<is_same_v<remove_const_t<TT>, remove_const_t<TTT>>, bool>
operator ==(circular_vector_iterator<TT, AL2> x,
            circular_vector_iterator<TTT, AL2> y) {
  return x.p == y.p;
}
template <class TT, class AL2>
circular_vector_iterator<TT, AL2>
operator +(circular_vector_iterator<TT, AL2> x,
           itr_dft<circular_vector_iterator<TT, AL2>> i) {
  return x += i;
}
template <class TT, class AL2>
circular_vector_iterator<TT, AL2>
operator +(itr_dft<circular_vector_iterator<TT, AL2>> i,
           circular_vector_iterator<TT, AL2> x) {
  return x += i;
}
template <class TT, class TTT, class AL2>
enable_if_t<is_same_v<remove_const_t<TT>, remove_const_t<TTT>>,
            itr_dft<circular_vector_iterator<TT, AL2>>>
operator -(circular_vector_iterator<TTT, AL2> x,
           circular_vector_iterator<TT, AL2> y) {
  if (x.p == y.p)
    return 0;
  if (x.p >= x.shared_p->data_op) {
    if (y.p >= x.shared_p->data_op)
      return x.p - y.p;
    else
      return x.p - x.shared_p->ed - (y.p - x.shared_p->op);
  }
  else {
    if (y.p < x.shared_p->data_op)
      return x.p - y.p;
    else
      return x.p - x.shared_p->op + (x.shared_p->ed - y.p);
  }
}
template <class TT, class AL2>
circular_vector_iterator<TT, AL2>
operator -(circular_vector_iterator<TT, AL2> x,
           itr_dft<circular_vector_iterator<TT, AL2>> i) {
  return x -= i;
}
template <class TT, class TTT, class AL2>
enable_if_t<is_same_v<remove_const_t<TT>, remove_const_t<TTT>>,
            synth_3way_result<alloc_ptr<AL2>>>
operator <=>(circular_vector_iterator<TT, AL2> x,
             circular_vector_iterator<TTT, AL2> y) {
  if (x.p == y.p)
    return strong_eq;
  if (x.p >= x.shared_p->data_op) {
    if (y.p >= x.shared_p->data_op)
      return synth_3way(x.p, y.p);
    else
      return strong_lt;
  }
  else {
    if (y.p < x.shared_p->data_op)
      return synth_3way(x.p, y.p);
    else
      return strong_gt;
  }
}

}
template <class T, class AL = default_allocator<T>>
class circular_vector
  : inner::circular_vector_data<AL>, allocator_wrapper<AL> {
public:
  static_assert(is_same_v<T, alloc_vt<AL>>);

  using this_t = circular_vector;

  template <class, class>
  friend class pointer_vector;

  using data_t = inner::circular_vector_data<AL>;
  using data_t::bufp;
  using bufp_t = typename data_t::bufp_t;
  using head_t = typename bufp_t::head_type;
  auto &op() {
    return bufp.head().op;
  }
  const auto &op() const {
    return bufp.head().op;
  }
  auto &ed() {
    return bufp.head().ed;
  }
  const auto &ed() const {
    return bufp.head().ed;
  }
  auto &data_op() {
    return bufp.head().data_op;
  }
  const auto &data_op() const {
    return bufp.head().data_op;
  }
  auto &data_ed() {
    return bufp.head().data_ed;
  }
  const auto &data_ed() const {
    return bufp.head().data_ed;
  }
  alloc_rebind_ptr<AL, typename bufp_t::head_type> head_p() const {
    return pointer_to<alloc_ptr<AL>>(bufp.head());
  }

  using alw_t = allocator_wrapper<AL>;
  using alw_t::allocate;
  using alw_t::construct;
  using alw_t::destroy;
  using alw_t::deallocate;
  using alw_t::destroy_fn;
  using alw_t::new_1;
  using alw_t::new_n;
  using alw_t::delete_1;
  using alw_t::delete_n;
  using alw_t::make_temporary;
  using alw_t::uninitialized_fill;
  using alw_t::uninitialized_copy;
  using alw_t::uninitialized_move;
  using alw_t::uninitialized_fully_move;
  using alw_t::fully_move;

  template <class R>
  static auto begin(R &&r) {return re::begin(r);}
  template <class R>
  static auto end(R &&r) {return re::end(r);}
  template <class R>
  static auto rbegin(R &&r) {return re::rbegin(r);}
  template <class R>
  static auto rend(R &&r) {return re::rend(r);}
  template <class R>
  static auto size(R &&r) {return re::size(r);}
  template <class R>
  static auto empty(R &&r) {return re::empty(r);}

public:
  using pointer = alloc_ptr<AL>;
  using const_pointer = alloc_cptr<AL>;

  // container

  using value_type = alloc_vt<AL>;
  using reference = value_type &;
  using const_reference = const value_type &;

  using iterator = inner::circular_vector_iterator<value_type, AL>;
  using const_iterator
    = inner::circular_vector_iterator<const value_type, AL>;
  using difference_type = alloc_dft<AL>;
  using size_type = alloc_szt<AL>;

  iterator begin() noexcept {
    return iterator(data_op(), head_p());
  }
  iterator end() noexcept {
    return iterator(data_ed(), head_p());
  }
  const_iterator begin() const noexcept {
    return const_iterator(data_op(), head_p());
  }
  const_iterator end() const noexcept {
    return const_iterator(data_ed(), head_p());
  }
  const_iterator cbegin() const noexcept {
    return begin();
  }
  const_iterator cend() const noexcept {
    return end();
  }

  size_type max_size() const noexcept {
    constexpr make_unsigned_t<ptrdiff_t> n = min_value
      (integral_traits<difference_type>::max(),
       integral_traits<ptrdiff_t>::max() / to_signed(sizeof(value_type)));
    constexpr size_t n2 = min_value(n, integral_traits<size_t>::max());
    return n2 - 1u;
  }
  size_type size() const noexcept {
    if (data_op() <= data_ed())
      return data_ed() - data_op();
    else
      return ed() - data_op() + (data_ed() - op());
  }
  bool empty() const noexcept {
    return data_op() == data_ed();
  }

private:
  // inner implements

  friend class allocator_aware_container_ownership<this_t>;
  const AL &alloc_ref() const noexcept {
    return alw_t::get();
  }
  AL &alloc_ref() noexcept {
    return alw_t::get();
  }
  void new_data() noexcept {
    data_t::init();
  }
  void delete_data() noexcept {
    destroy(*this);
    deallocate_buf();
  }
  void new_data(const this_t &v) {
    allocate_buf(v.size());
    data_ed() = uninitialized_copy(v, data_op());
  }
  void assign_data(const this_t &v) {
    assign_range_impl(v);
  }
  void new_data(this_t &&v) noexcept {
    data_t::operator =(move(static_cast<data_t &>(v)));
    v.new_data();
  }
  void new_data_individually(this_t &&v) {
    allocate_buf(v.size());
    data_ed() = uninitialized_fully_move(v, data_op(), v.destroy_fn());
    v.deallocate_buf();
    v.new_data();
  }
  void assign_data_individually(this_t &&v) {
    assign_range_impl(move_rng(v));
    v.delete_data();
    v.new_data();
  }
  void swap_data(this_t &v) noexcept {
    adl_swap(bufp, v.bufp);
  }

  // allocate_buf(..., n) requires: n <= max_size()
  void allocate_buf(bufp_t &bufpp, size_type n) {
    if (n == 0u)
      new_data();
    else {
      bufpp = alw_t::template rebind<byte>()
        .template allocate_headed_buffer<head_t, value_type>(n + 1u);
      bufpp.head().data_op
        = bufpp.head().data_ed
        = bufpp.head().op
        = bufpp.data();
      bufpp.head().ed = bufpp.data() + (n + 1u);
    }
  }
  void allocate_buf(size_type n) {
    allocate_buf(bufp, n);
  }

  void deallocate_buf(bufp_t p) {
    alw_t::template rebind<byte>().deallocate_headed_buffer(p);
  }
  void deallocate_buf() noexcept {
    if (bufp.size() != 0)
      alw_t::template rebind<byte>().deallocate_headed_buffer(bufp);
  }

  // requires: size() <= n <= max_size()
  void reallocate_impl(size_type n) {
    if (n == 0u) {
      deallocate_buf();
      new_data();
    }
    else {
      bufp_t tmp;
      allocate_buf(tmp, n);
#ifndef RE_NOEXCEPT
      try {
#endif
        tmp.head().data_ed
          = uninitialized_fully_move(*this, tmp.head().data_op);
#ifndef RE_NOEXCEPT
      }
      catch (...) {
        deallocate_buf(tmp);
        throw;
      }
#endif
      deallocate_buf();
      bufp = tmp;
    }
  }

  void increase_capacity_at_least_1() {
    auto n = capacity();
    if (n == 0u)
      n = 1;
    else if (max_size() - n >= n)
      n += n;
    else if (max_size() > n)
      n += 1;
    else
      throw_or_terminate<length_error>("re::circular_vector: size overflow in "
                                       "reserve_raw_space_at_least_1()");
    reallocate_impl(n);
  }
  void reserve_raw_space_at_least_1() {
    if (full())
      increase_capacity_at_least_1();
  }
  template <class UINT>
  void reserve_raw_space_at_least(UINT n) {
    static_assert(is_integral_v<UINT> && is_unsigned_v<UINT>);
    const size_type cp = capacity();
    const size_type rest = --begin() - end();
    if (n > rest) {
      n -= rest;
      const size_type cp_rest = max_size() - cp;
      if (cp_rest >= n)
        reallocate_impl((n < cp && cp_rest >= cp) ? (cp + cp) : (cp + n));
      else
        throw_or_terminate<length_error>
          ("re::circular_vector: size overflow in "
           "reserve_raw_space_at_least(n)");
    }
  }

  template <class...S>
  reference emplace_back_impl(S &&...s) {
    if (full()) {
      auto tmp = make_temporary(forward<S>(s)...);
      increase_capacity_at_least_1();
      construct(to_address(data_ed()), move(*tmp));
    }
    else
      construct(to_address(data_ed()), forward<S>(s)...);
    reference ret = *data_ed();
    ++data_ed();
    if (data_ed() == ed())
      data_ed() = op();
    return ret;
  }
  template <class...S>
  reference emplace_front_impl(S &&...s) {
    if (full()) {
      auto tmp = make_temporary(forward<S>(s)...);
      increase_capacity_at_least_1();
      pointer p = data_op();
      if (p == op())
        p = ed() - 1;
      else
        --p;
      construct(to_address(p), move(*tmp));
      data_op() = p;
      return *p;
    }
    else {
      pointer p = data_op();
      if (p == op())
        p = ed() - 1;
      else
        --p;
      construct(to_address(p), forward<S>(s)...);
      data_op() = p;
      return *p;
    }
  }

  void pop_back_impl() noexcept {
    destroy(to_address(data_ed() == op()
                       ? (data_ed() = ed() - 1) : --data_ed()));
  }
  void pop_front_impl() noexcept {
    destroy(to_address(data_op()));
    if (++data_op() == ed())
      data_op() = op();
  }

  template <class...S>
  iterator emplace_impl(const_iterator it, S &&...s) {
    if (it == begin()) {
      emplace_front_impl(forward<S>(s)...);
      return begin();
    }
    else if (it == end()) {
      emplace_back_impl(forward<S>(s)...);
      return --end();
    }
    else {
      auto tmp = make_temporary(forward<S>(s)...);
      const auto n1 = it - begin();
      const auto n2 = end() - it;
      reserve_raw_space_at_least_1();
      iterator new_pos = begin() + n1;
      if (n1 < n2) {
        auto tmp_it = --begin();
        const auto tmp_it2 = ++begin();
        construct(to_address(tmp_it), move(*begin()));
        data_op() = tmp_it.p;
        new_pos = move(rng(tmp_it2, new_pos), ++tmp_it);
      }
      else {
        construct(to_address(data_ed()), move(back()));
        const auto old_end = end();
        data_ed() = (++end()).p;
        move_backward(rng(new_pos, prev(old_end)), old_end);
      }
      *new_pos = move(*tmp);
      return new_pos;
    }
  }

  iterator erase_impl(const_iterator cit) {
    const iterator it = cit.to_mutable();
    const auto n1 = it - begin();
    const auto n2 = end() - it;
    const auto next_it = next(it);
    if (n1 < n2) {
      destroy(to_address(exchange(data_op(),
                                  move_backward(rng(begin(), it), next_it).p)));
      return next_it;
    }
    else {
      data_ed() = move(rng(next_it, end()), it).p;
      destroy(to_address(data_ed()));
      return it;
    }
  }
  iterator erase_range_impl(const_iterator from, const_iterator to) {
    const iterator it1 = from.to_mutable();
    const iterator it2 = to.to_mutable();
    if (it1 == it2)
      return it1;
    const auto n1 = it1 - begin();
    const auto n2 = end() - it2;
    if (n1 < n2) {
      const auto new_begin = move_backward(rng(begin(), it1), it2);
      destroy(rng(begin(), new_begin));
      data_op() = new_begin.p;
      return it2;
    }
    else {
      const auto new_end = move(rng(it2, end()), it1);
      destroy(rng(new_end, end()));
      data_ed() = new_end.p;
      return it1;
    }
  }
  void clear_impl() noexcept {
    if (data_op() != data_ed()) {
      destroy(*this);
      data_op() = data_ed() = op();
    }
  }

  template <class SZT>
  void size_check(SZT n) {
    static_assert(is_integral_v<SZT> && is_unsigned_v<SZT>);
    if (n > max_size())
      throw_or_terminate<length_error>
        ("re::circular_vector: size overflow in size_check(n)");
  }

  template <class IITR_RANGE>
  enable_if_t<rng_is_sized<IITR_RANGE>>
  construct_from_range_impl(IITR_RANGE &&r) {
    const auto n = size(r);
    size_check(n);
    allocate_buf(n);
    data_ed() = uninitialized_copy(r, data_ed());
  }
  template <class IITR_RANGE>
  enable_if_t<!rng_is_sized<IITR_RANGE>>
  construct_from_range_impl(IITR_RANGE &&r) {
    new_data();
    for (auto &p : iters(r))
      emplace_back_impl(*p);
  }

  void construct_n_impl(size_type n) {
    allocate_buf(n);
    uninitialized_fill(rng(op(), n));
    data_ed() = op() + n;
  }

  template <class IITR_RANGE>
  enable_if_t<rng_is_sized<IITR_RANGE>>
  assign_range_impl(IITR_RANGE &&r) {
    const auto r_sz = size(r);
    const auto sz = size();
    if (r_sz <= sz)
      erase_range_impl(copy(r, begin()), end());
    else {
      reserve_raw_space_at_least(r_sz - sz);
      const auto r_ed = end(r);
      auto it = begin(r);
      it = copy_from(*this, it);
      data_ed() = uninitialized_copy(rng(it, r_ed), end()).p;
    }
  }
  template <class IITR_RANGE>
  enable_if_t<!rng_is_sized<IITR_RANGE>>
  assign_range_impl(IITR_RANGE &&r) {
    auto r1 = rng(*this);
    auto r2 = rng(r);
    for (;;) {
      if (empty(r1)) {
        append_range_impl(r2);
        return;
      }
      if (empty(r2)) {
        erase_range_impl(r1.first, r1.second);
        return;
      }
      *r1.first = *r2.first;
      ++r1.first;
      ++r2.first;
    }
  }

  template <class IITR_RANGE>
  enable_if_t<rng_is_sized<IITR_RANGE>>
  prepend_range_impl(IITR_RANGE &&r) {
    const auto r_sz = size(r);
    reserve_raw_space_at_least(r_sz);
    const iterator new_begin = begin() - r_sz;
    uninitialized_copy(r, new_begin);
    data_op() = new_begin.p;
  }
  template <class IITR_RANGE>
  enable_if_t<!rng_is_sized<IITR_RANGE>>
  prepend_range_impl(IITR_RANGE &&r) {
    const auto dif = begin() - end();
    for (auto &p : iters(r))
      emplace_front_impl(*p);
    reverse(rng(begin(), end() + dif));
  }

  template <class IITR_RANGE>
  enable_if_t<rng_is_sized<IITR_RANGE>>
  append_range_impl(IITR_RANGE &&r) {
    reserve_raw_space_at_least(size(r));
    data_ed() = uninitialized_copy(r, end()).p;
  }
  template <class IITR_RANGE>
  enable_if_t<!rng_is_sized<IITR_RANGE>>
  append_range_impl(IITR_RANGE &&r) {
    for (auto &p : iters(r))
      emplace_back_impl(*p);
  }

  template <class IITR_RANGE>
  enable_if_t<rng_is_sized<IITR_RANGE>
              || is_fitr<rng_itr<IITR_RANGE &&>>, iterator>
  insert_range_impl(const_iterator cit, IITR_RANGE &&r) {
    iterator new_it = cit.to_mutable();
    if (new_it == end()) {
      const auto dif = size();
      append_range_impl(r);
      return begin() + dif;
    }
    else if (new_it == begin()) {
      prepend_range_impl(r);
      return begin();
    }
    else {
      if (empty(r))
        return new_it;
      const auto n1 = new_it - begin();
      const auto n2 = end() - new_it;
      const auto n = size(r);
      reserve_raw_space_at_least(n);
      if (n1 < n2) {
        new_it = end() - n2;
        const iterator new_begin = begin() - n;
        iterator mid = new_it - n;
        if (mid > end()) {
          uninitialized_move(rng(begin(), new_it), new_begin);
          const auto ed = end(r);
          auto it = begin(r);
          auto mid2 = mid;
#ifndef RE_NOEXCEPT
          try {
#endif
            for (; mid2 != begin(); ++mid2, (void)++it)
              construct(to_address(mid2.p), *it);
#ifndef RE_NOEXCEPT
          }
          catch (...) {
            destroy(rng(new_begin, mid2));
            throw;
          }
#endif
          data_op() = new_begin.p;
          copy(rng(it, ed), mid2);
          return mid;
        }
        else {
          mid = begin() + n;
          uninitialized_move(rng(begin(), mid), new_begin);
#ifndef RE_NOEXCEPT
          try {
#endif
            mid = move(rng(mid, new_it), begin());
            copy(r, mid);
#ifndef RE_NOEXCEPT
          }
          catch (...) {
            for (auto &p : iters(new_begin, begin()))
              destroy(to_address(p));
            throw;
          }
#endif
          data_op() = new_begin.p;
          return mid;
        }
      }
      else {
        new_it = begin() + n1;
        const iterator mid = new_it + n;
        if (mid > end()) {
          const iterator new_end = uninitialized_move(rng(new_it, end()), mid);
          auto it = begin(r);
          const auto ed = end(r);
#ifndef RE_NOEXCEPT
          try {
#endif
            it = copy_from(rng(new_it, end()), it);
            uninitialized_copy(rng(it, ed), end());
#ifndef RE_NOEXCEPT
          }
          catch (...) {
            destroy(rng(mid, new_end));
            throw;
          }
#endif
          data_ed() = new_end.p;
        }
        else {
          const auto old_end = end();
          const iterator cut = end() - n;
          const iterator new_end = uninitialized_move(rng(cut, end()), end());
          data_ed() = new_end.p;
          move_backward(rng(new_it, cut), old_end);
          copy(r, new_it);
        }
        return new_it;
      }
    }
  }
  template <class IITR_RANGE>
  enable_if_t<!(rng_is_sized<IITR_RANGE>
                || is_fitr<rng_itr<IITR_RANGE &&>>), iterator>
  insert_range_impl(const_iterator cit, IITR_RANGE &&r) {
    const iterator it = cit;
    if (it == begin()) {
      prepend_range_impl(r);
      return begin();
    }
    const difference_type old_sz = size();
    if (it == end()) {
      append_range_impl(r);
      return begin() + old_sz;
    }
    else {
      const auto n1 = it - begin();
      const auto n2 = end() - it;
      if (n1 < n2) {
        for (auto &p : iters(r))
          emplace_front(*p);
        const iterator old_begin = end() - old_sz;
        reverse(rng(begin(), old_begin));
        return rotate(rng(begin(), end() - n2), old_begin);
      }
      else {
        for (auto &p : iters(r))
          emplace_back(*p);
        const iterator new_it = begin() + n1;
        rotate(rng(new_it, end()), begin() + old_sz);
        return new_it;
      }
    }
  }

  iterator insert_n_impl(const_iterator p,
                         size_type n, const value_type &x) {
    auto tmp = make_temporary(x);
    return insert_range_impl(p, rng(n, ref(*tmp)));
  }

  void resize_impl(size_type n) {
    const size_type sz = size();
    if (n <= sz)
      erase_range_impl(begin() + n, end());
    else {
      const size_type nn = n - sz;
      reserve_raw_space_at_least(nn);
      const iterator new_end = end() + nn;
      uninitialized_fill(rng(end(), new_end));
      data_ed() = new_end.p;
    }
  }
  void resize_impl(size_type n, const value_type &x) {
    const size_type sz = size();
    if (n <= sz)
      erase_range_impl(begin() + n, end());
    else {
      const auto tmp = make_temporary(x);
      const size_type nn = n - sz;
      reserve_raw_space_at_least(nn);
      const iterator new_end = end() + nn;
      uninitialized_fill(rng(end(), new_end), *tmp);
      data_ed() = new_end.p;
    }
  }

  void shrink_to_fit_impl() {
    reallocate_impl(size());
  }
  void reserve_impl(size_type n) {
    if (n > max_size())
      throw_or_terminate<length_error>
        ("re::circular_vector: size overflow in reserve_impl()");
    if (n > capacity())
      reallocate_impl(n);
  }

public:
  // container (continued)

  circular_vector() noexcept(noexcept(AL())) : circular_vector(AL()) {}
  ~circular_vector() {
    delete_data();
  }
  circular_vector(const circular_vector &v)
    : alw_t(alw_t::traits
            ::select_on_container_copy_construction(v.alloc_ref())) {
    new_data(v);
  }
  circular_vector &operator =(const circular_vector &v) {
    allocator_aware_container_ownership<this_t>::copy_assign(*this, v);
    return *this;
  }
  circular_vector(circular_vector &&v) noexcept
    : alw_t(move(v.alloc_ref())) {
    new_data(move(v));
  }
  circular_vector &operator =(circular_vector &&v)
    noexcept(alloc_move_prpg<AL> || alloc_always_equal<AL>) {
    allocator_aware_container_ownership<this_t>::move_assign(*this, v);
    return *this;
  }
  friend void swap(circular_vector &x, circular_vector &y)
    noexcept(alloc_swap_prpg<AL> || alloc_always_equal<AL>) {
    allocator_aware_container_ownership<this_t>::swap(x, y);
  }

  // optional container operations

  // reversible container

  using reverse_iterator = re::reverse_iterator<iterator>;
  using const_reverse_iterator = re::reverse_iterator<const_iterator>;

  reverse_iterator rbegin() noexcept {
    return reverse_iterator(end());
  }
  reverse_iterator rend() noexcept {
    return reverse_iterator(begin());
  }
  const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator(begin());
  }
  const_reverse_iterator crbegin() const noexcept {
    return rbegin();
  }
  const_reverse_iterator crend() const noexcept {
    return rend();
  }

  // allocator-aware container

  using allocator_type = AL;
  allocator_type get_allocator() const noexcept {
    return alw_t::get();
  }

  explicit circular_vector(const AL &al) noexcept : alw_t(al) {
    new_data();
  }
  circular_vector(const circular_vector &v, const AL &al) : alw_t(al) {
    new_data(v);
  }
  circular_vector(circular_vector &&v, const AL &al) : alw_t(move(al)) {
    allocator_aware_container_ownership<this_t>::move_construct(*this, v);
  }

  // sequence container

  explicit circular_vector(size_type n, const AL &al = AL{}) : alw_t(al) {
    construct_n_impl(n);
  }
  circular_vector(size_type n, const T &x,
                  const AL &al = AL{}) : alw_t(al) {
    construct_from_range_impl(rng(n, ref(x)));
  }
  void assign(size_type n, const T &x) {
    assign_range_impl(rng(n, x));
  }

  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  circular_vector(IITR from, IITR to, const AL &al = AL{}) : alw_t(al) {
    construct_from_range_impl(rng(from, to));
  }
  template <class IITR>
  enable_if_t<is_itr<IITR>> assign(IITR from, IITR to) {
    assign_range_impl(rng(from, to));
  }

  circular_vector(initializer_list<T> l, const AL &al = AL{}) : alw_t(al) {
    construct_from_range_impl(l);
  }
  circular_vector &operator =(initializer_list<T> l) {
    assign_range_impl(l);
    return *this;
  }
  void assign(initializer_list<T> l) {
    assign_range_impl(l);
  }

  template <class...S>
  iterator emplace(const_iterator pos, S &&...s) {
    return emplace_impl(pos, forward<S>(s)...);
  }
  iterator insert(const_iterator pos, const T &x) {
    return emplace_impl(pos, x);
  }
  iterator insert(const_iterator pos, T &&x) {
    return emplace_impl(pos, move(x));
  }

  iterator insert(const_iterator pos, size_type n, const T &x) {
    return insert_n_impl(pos, n, x);
  }
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  iterator insert(const_iterator pos, IITR from, IITR to) {
    return insert_range_impl(pos, rng(from, to));
  }
  iterator insert(const_iterator pos, initializer_list<T> l) {
    return insert_range_impl(pos, l);
  }

  iterator erase(const_iterator pos) {
    return erase_impl(pos);
  }
  iterator erase(const_iterator from, const_iterator to) {
    return erase_range_impl(from, to);
  }
  void clear() noexcept {
    clear_impl();
  }

  // optional sequence container operations

  reference front() {
    return *data_op();
  }
  reference back() {
    return *((data_ed() == op() ? ed() : data_ed()) - 1);
  }
  const_reference front() const {
    return *data_op();
  }
  const_reference back() const {
    return *((data_ed() == op() ? ed() : data_ed()) - 1);
  }

  template <class...S>
  reference emplace_back(S &&...s) {
    return emplace_back_impl(forward<S>(s)...);
  }
  void push_back(const T &x) {
    emplace_back_impl(x);
  }
  void push_back(T &&x) {
    emplace_back_impl(move(x));
  }
  void pop_back() {
    pop_back_impl();
  }

  template <class...S>
  reference emplace_front(S &&...s) {
    return emplace_front_impl(forward<S>(s)...);
  }
  void push_front(const T &x) {
    emplace_front_impl(x);
  }
  void push_front(T &&x) {
    emplace_front_impl(move(x));
  }
  void pop_front() {
    pop_front_impl();
  }

  reference operator [](size_type n) {
    return begin()[n];
  }
  const_reference operator [](size_type n) const {
    return begin()[n];
  }
  reference at(size_type n) {
    if (n >= size())
      throw_or_terminate<out_of_range>("re::circular_vector: at(n) failed");
    return begin()[n];
  }
  const_reference at(size_type n) const {
    if (n >= size())
      throw_or_terminate<out_of_range>("re::circular_vector: at(n) failed");
    return begin()[n];
  }

  // specialized operations

  void resize(size_type n) {
    resize_impl(n);
  }
  void resize(size_type n, const T &x) {
    resize_impl(n, x);
  }

  void shrink_to_fit() {
    shrink_to_fit_impl();
  }

  void reserve(size_type n) {
    reserve_impl(n);
  }

  size_type capacity() const noexcept {
    return ed() - op() - 1;
  }

  template <class UF>
  size_type remove_if(UF eq) {
    const auto i = re::remove_if(*this, eq);
    const auto z = end();
    const size_type ret = z - i;
    erase(i, z);
    return ret;
  }
  template <class X>
  size_type remove(const X &x) {
    return remove_if(bind(equal_to<>(), _1, ref(x)));
  }

  bool full() const noexcept {
    return ++end() == begin();
  }

  void reallocate(size_type n) {
    if (const auto sz = size(); n < sz)
      n = sz;
    reallocate_impl(n);
  }
  void reallocate() {
    reallocate_impl(size());
  }

  void reserve_more(size_type n) {
    reserve_raw_space_at_least(n);
  }

  template <class R>
  iterator replace(const_iterator i1, const_iterator i2, R &&r) {
    return inner::fns::seq_container_replace_impl
      (*this, i1.to_mutable(), i2.to_mutable(), r);
  }

  // operations for range

  template <class R>
  circular_vector(from_range_t,
                  R &&r, const allocator_type &al = allocator_type{})
    requires (is_rng<R> && is_constructible_v<value_type, rng_ref<R>>)
    : alw_t(al) {
    construct_from_range_impl(r);
  }
  template <class R, class = enable_if_t
            <!is_same_v<decay_t<R>, this_t>
             && !is_convertible_v<R &&, const allocator_type &>
             && is_rng<R> && is_constructible_v<value_type, rng_ref<R>>>>
  explicit circular_vector(R &&r) : circular_vector(r, allocator_type{}) {}
  template <class R, class = enable_if_t
            <!is_same_v<decay_t<R>, this_t>
             && is_rng<R> && is_constructible_v<value_type, rng_ref<R>>>>
  circular_vector(R &&r, const allocator_type &al) : alw_t(al) {
    construct_from_range_impl(r);
  }
  template <class IITR_RANGE>
  enable_if_t<!is_same_v<decay_t<IITR_RANGE>, this_t>
              && is_rng<IITR_RANGE>
              && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
              && is_assignable_v<value_type &, rng_ref<IITR_RANGE>>, this_t &>
  operator =(IITR_RANGE &&r) {
    assign_range_impl(r);
    return *this;
  }
  template <class IITR_RANGE>
  void assign(IITR_RANGE &&r) {
    assign_range_impl(r);
  }
  template <class IITR_RANGE>
  void assign_range(IITR_RANGE &&r) {
    assign_range_impl(r);
  }

  template <class IITR_RANGE>
  enable_if_t<!is_convertible_v<IITR_RANGE &&, value_type &&>
              && !is_convertible_v<IITR_RANGE &&, const value_type &>,
              iterator>
  insert(const_iterator pos, IITR_RANGE &&r) {
    return insert_range_impl(pos, r);
  }
  template <class IITR_RANGE>
  iterator insert_range(const_iterator pos, IITR_RANGE &&r) {
    return insert_range_impl(pos, r);
  }

  template <class IITR_RANGE>
  enable_if_t<!is_convertible_v<IITR_RANGE &&, value_type &&>
              && !is_convertible_v<IITR_RANGE &&, const value_type &>>
  push_back(IITR_RANGE &&r) {
    append_range_impl(r);
  }
  template <class IITR_RANGE>
  void append_range(IITR_RANGE &&r) {
    append_range_impl(r);
  }
  void pop_back(size_type n) {
    for (; n != 0; --n)
      pop_back();
  }

  template <class IITR_RANGE>
  enable_if_t<!is_convertible_v<IITR_RANGE &&, value_type &&>
              && !is_convertible_v<IITR_RANGE &&, const value_type &>>
  push_front(IITR_RANGE &&r) {
    prepend_range_impl(r);
  }
  template <class IITR_RANGE>
  void prepend_range(IITR_RANGE &&r) {
    prepend_range_impl(r);
  }
  void pop_front(size_type n) {
    for (; n != 0; --n)
      pop_front();
  }

  this_t &append() {
    return *this;
  }
  template <class X, class...S>
  this_t &append(X &&x, S &&...s) {
    push_back(forward<X>(x));
    return append(forward<S>(s)...);
  }

  this_t &prepend() {
    return *this;
  }
  template <class X, class...S>
  this_t &prepend(X &&x, S &&...s) {
    prepend(forward<S>(s)...);
    push_front(forward<X>(x));
    return *this;
  }
};
template <class T, class AL>
bool operator ==(const circular_vector<T, AL> &x,
                 const circular_vector<T, AL> &y) {
  return equal(x, y);
}
template <class T, class AL>
synth_3way_result<T> operator <=>(const circular_vector<T, AL> &x,
                                  const circular_vector<T, AL> &y) {
  return lexicographical_synth_3way(x, y);
}

}

// deque
namespace re {

template <class, class>
class deque;
namespace inner {

template <class T>
struct deque_default_lower_buffer_size {
  static constexpr size_t tmp = 128u / sizeof(T);
  static constexpr size_t value
    = conditional_t
    <(tmp <= 8),
     size_constant<8>,
     conditional_t
     <(tmp <= 16),
      size_constant<16>,
      conditional_t
      <(tmp <= 32),
       size_constant<32>,
       conditional_t
       <(tmp <= 64),
        size_constant<64>,
        size_constant<64>
        >
       >
      >
     >::value;

  static_assert(value >= 3);
};

template <class AL>
struct deque_data {
  //  ++++++++++++++++++++++++++++++++-            upper buffer   |
  //  |||.....|.......................                            |
  //  | \\____|___________________                                |
  //  |  \____|_______            \                               |
  //  |       |       \           |                               |
  // \|/     \|/     \|/         \|/                              |
  //  ++++++++++++++++++++++++    ++++++++...      lower buffer   |

  using pointer = alloc_ptr<AL>;
  using value_type = alloc_vt<AL>;
  using size_type = alloc_szt<AL>;

  using lower_pointer = alloc_rebind_ptr<AL, value_type>;
  using upper_pointer = alloc_rebind_ptr<AL, lower_pointer>;

  struct lower_buffer_head_t {
    typename allocator_wrapper<alloc_rebind<AL, byte>>
      ::template headed_buffer_ptr<lower_buffer_head_t, alloc_vt<AL>> next;
  };
  using lower_buffer_ptr_t
    = typename allocator_wrapper<alloc_rebind<AL, byte>>
    ::template headed_buffer_ptr<lower_buffer_head_t, alloc_vt<AL>>;

  struct upper_buffer_t {
    upper_pointer op;
    upper_pointer ed;
    upper_pointer op_wall;
    lower_buffer_ptr_t lower_bufp;
  };
  using upper_buffer_pointer = alloc_rebind_ptr<AL, upper_buffer_t>;

  // constraint: !(upper_op == upper_ed && lower_ed < lower_op)
  upper_pointer upper_op; // record to construct begin iterator
  upper_pointer upper_ed; // record to construct begin iterator
  lower_pointer lower_op; // record to construct end iterator
  lower_pointer lower_ed; // record to construct end iterator
  upper_buffer_pointer upper_bufp;
};

template <class T, class AL>
class deque_iterator {
  static constexpr alloc_dft<AL> lower_buffer_ssize() {
    return deque_default_lower_buffer_size<remove_const_t<T>>::value;
  }

  using this_t = deque_iterator;

  template <class, class>
  friend class re::deque;
  template <class, class>
  friend class deque_iterator;

  using data_t = inner::deque_data<AL>;
  using lower_pointer = typename data_t::lower_pointer;
  using upper_pointer = typename data_t::upper_pointer;
  using upper_buffer_pointer = typename data_t::upper_buffer_pointer;

  lower_pointer lower_p;
  upper_pointer upper_p;
  upper_buffer_pointer upper_bufp;

public:
  using value_type = remove_const_t<T>;
  using pointer = T *;
  using reference = T &;
  using difference_type = alloc_dft<AL>;
  using iterator_category = random_access_iterator_tag;

  deque_iterator() = default;
  ~deque_iterator() = default;
  deque_iterator(const deque_iterator &) = default;
  deque_iterator &operator =(const deque_iterator &) = default;
  deque_iterator(deque_iterator &&) = default;
  deque_iterator &operator =(deque_iterator &&) = default;
  friend void swap(deque_iterator &x, deque_iterator &y) noexcept {
    adl_swap(x.lower_p, y.lower_p);
    adl_swap(x.upper_p, y.upper_p);
    adl_swap(x.upper_bufp, y.upper_bufp);
  }

  template <class TT = T, class = enable_if_t<is_const<TT>::value>>
  deque_iterator(deque_iterator<remove_const_t<TT>, AL> t)
    : lower_p(t.lower_p), upper_p(t.upper_p), upper_bufp(t.upper_bufp) {}
  template <class TT = T, class = enable_if_t<is_const<TT>::value>>
  deque_iterator &operator =(deque_iterator<remove_const_t<TT>, AL> t) {
    lower_p = t.lower_p;
    upper_p = t.upper_p;
    upper_bufp = t.upper_bufp;
    return *this;
  }

private:
  template <class>
  friend struct re::inner::fo_make;
  friend struct re::inner::fo_to_mutable;

  deque_iterator(upper_pointer pp, lower_pointer p, upper_buffer_pointer ppp)
    : lower_p(p), upper_p(pp), upper_bufp(ppp) {}
  auto to_mutable() const requires is_const_v<T> {
    return deque_iterator<remove_const_t<T>, AL>(upper_p, lower_p, upper_bufp);
  }

public:
  reference operator *() const {
    return *lower_p;
  }
  pointer operator ->() const {
    return to_address(lower_p);
  }

  this_t &operator ++() {
    ++lower_p;
    if (lower_p == *upper_p + lower_buffer_ssize()) {
      ++upper_p;
      if (upper_p == upper_bufp->ed)
        upper_p = upper_bufp->op;
      lower_p = *upper_p;
    }
    return *this;
  }
  this_t operator ++(int) {
    return iter_post_increment(*this);
  }

  this_t &operator --() {
    if (lower_p == *upper_p) {
      if (upper_p == upper_bufp->op)
        upper_p = upper_bufp->ed - 1;
      else
        --upper_p;
      lower_p = *upper_p + lower_buffer_ssize() - 1;
    }
    else
      --lower_p;
    return *this;
  }
  this_t operator --(int) {
    return iter_post_decrement(*this);
  }

  this_t &operator +=(difference_type i) {
    const difference_type dif = lower_p - *upper_p + i;
    if (0 <= dif && dif < lower_buffer_ssize())
      lower_p = *upper_p + dif;
    else {
      difference_type upper_dif = i / lower_buffer_ssize();
      difference_type lower_dif = i % lower_buffer_ssize()
        + (lower_p - *upper_p);

      if (lower_dif < 0) {
        --upper_dif;
        lower_dif += lower_buffer_ssize();
      }
      else if (lower_dif >= lower_buffer_ssize()) {
        ++upper_dif;
        lower_dif -= lower_buffer_ssize();
      }

      if (upper_dif >= upper_bufp->ed - upper_p)
        upper_p = upper_bufp->op + (upper_dif - (upper_bufp->ed - upper_p));
      else if (upper_dif < upper_bufp->op - upper_p)
        upper_p = upper_bufp->ed + (upper_dif - (upper_bufp->op - upper_p));
      else
        upper_p += upper_dif;
      lower_p = *upper_p + lower_dif;
    }
    return *this;
  }
  this_t &operator -=(difference_type i) {
    return operator +=(-i);
  }
  reference operator [](difference_type i) const {
    return *(copy(*this) += i);
  }

  template <class TT, class UU, class AL2>
  friend enable_if_t<is_same_v<remove_const_t<TT>, remove_const_t<UU>>, bool>
  operator ==(deque_iterator<TT, AL2>, deque_iterator<UU, AL2>);
  template <class TT, class UU, class AL2>
  friend enable_if_t<is_same_v<remove_const_t<TT>, remove_const_t<UU>>,
                     itr_dft<deque_iterator<TT, AL2>>>
  operator -(deque_iterator<TT, AL2>, deque_iterator<UU, AL2>);
  template <class TT, class UU, class AL2>
  friend strong_ordering operator <=>(deque_iterator<TT, AL2>,
                                      deque_iterator<UU, AL2>);
};
template <class TT, class UU, class AL2>
enable_if_t<is_same_v<remove_const_t<TT>, remove_const_t<UU>>, bool>
operator ==(deque_iterator<TT, AL2> p, deque_iterator<UU, AL2> pp) {
  return p.lower_p == pp.lower_p;
}
template <class TT, class AL2>
deque_iterator<TT, AL2>
operator +(deque_iterator<TT, AL2> p, itr_dft<deque_iterator<TT, AL2>> i) {
  return p += i;
}
template <class TT, class AL2>
deque_iterator<TT, AL2>
operator +(itr_dft<deque_iterator<TT, AL2>> i, deque_iterator<TT, AL2> p) {
  return p += i;
}
template <class TT, class AL2>
deque_iterator<TT, AL2>
operator -(deque_iterator<TT, AL2> p, itr_dft<deque_iterator<TT, AL2>> i) {
  return p += -i;
}
template <class TT, class UU, class AL2>
enable_if_t<is_same_v<remove_const_t<TT>, remove_const_t<UU>>,
            itr_dft<deque_iterator<TT, AL2>>>
operator -(deque_iterator<TT, AL2> p, deque_iterator<UU, AL2> pp) {
  if (p.upper_p == pp.upper_p)
    return p.lower_p - pp.lower_p;
  else {
    using dif_t = itr_dft<deque_iterator<TT, AL2>>;
    dif_t upper_dif;
    if (p.upper_p >= p.upper_bufp->op_wall) {
      if (pp.upper_p >= p.upper_bufp->op_wall)
        upper_dif = p.upper_p - pp.upper_p;
      else
        upper_dif = p.upper_p - pp.upper_p
          - (p.upper_bufp->ed - p.upper_bufp->op);
    }
    else {
      if (pp.upper_p < p.upper_bufp->op_wall)
        upper_dif = p.upper_p - pp.upper_p;
      else
        upper_dif = p.upper_p - pp.upper_p
          + (p.upper_bufp->ed - p.upper_bufp->op);
    }
    const dif_t lower_dif = (p.lower_p - *p.upper_p)
      - (pp.lower_p - *pp.upper_p);
    return upper_dif * deque_iterator<TT, AL2>::lower_buffer_ssize()
      + lower_dif;
  }
}
template <class TT, class UU, class AL2>
strong_ordering operator <=>(deque_iterator<TT, AL2> p,
                             deque_iterator<UU, AL2> pp) {
  if (p.upper_p == pp.upper_p)
    return synth_3way(p.lower_p, pp.lower_p);
  if (p.upper_p >= p.upper_bufp->op_wall) {
    if (pp.upper_p >= p.upper_bufp->op_wall)
      return synth_3way(p.upper_p, pp.upper_p);
    else
      return strong_lt;
  }
  else {
    if (pp.upper_p < p.upper_bufp->op_wall)
      return synth_3way(p.upper_p, pp.upper_p);
    else
      return strong_gt;
  }
}

}
template <class T, class AL = default_allocator<T>>
class deque : inner::deque_data<AL>, allocator_wrapper<AL> {
  static_assert(is_same_v<T, alloc_vt<AL>>);

  static constexpr
  alloc_szt<AL> lower_buf_size() {
    return inner::deque_default_lower_buffer_size<remove_const_t<T>>::value;
  }
  static constexpr
  alloc_dft<AL> lower_buf_ssize() {
    return inner::deque_default_lower_buffer_size<remove_const_t<T>>::value;
  }

  using this_t = deque;

  using data_t = inner::deque_data<AL>;
  using data_t::lower_op;
  using data_t::lower_ed;
  using data_t::upper_op;
  using data_t::upper_ed;
  using data_t::upper_bufp;

  using upper_pointer = typename data_t::upper_pointer;
  using lower_pointer = typename data_t::lower_pointer;

  using lower_buffer_head_t = typename data_t::lower_buffer_head_t;
  using lower_buffer_ptr_t = typename data_t::lower_buffer_ptr_t;
  using upper_buffer_t = typename data_t::upper_buffer_t;

  using upper_alloc_t = alloc_rebind<AL, lower_pointer>;
  using upper_alloc_traits = alloc_rebind_traits<AL, lower_pointer>;

  using alloc_t = AL;
  using alloc_traits = allocator_traits<AL>;

  using buf_info_alloc_t = alloc_rebind<AL, typename data_t::upper_buffer_t>;
  using buf_info_alloc_traits
    = alloc_rebind_traits<AL, typename data_t::upper_buffer_t>;
  using buf_info_pointer
    = typename buf_info_alloc_traits::pointer;

  using alw_t = allocator_wrapper<AL>;
  using alw_t::allocate;
  using alw_t::construct;
  using alw_t::destroy;
  using alw_t::deallocate;
  using alw_t::destroy_fn;
  using alw_t::new_1;
  using alw_t::new_n;
  using alw_t::delete_1;
  using alw_t::delete_n;
  using alw_t::make_temporary;
  using alw_t::uninitialized_fill;
  using alw_t::uninitialized_copy;
  using alw_t::uninitialized_move;
  using alw_t::uninitialized_fully_move;
  using alw_t::fully_move;

  template <class R>
  static auto begin(R &&r) {return re::begin(r);}
  template <class R>
  static auto end(R &&r) {return re::end(r);}
  template <class R>
  static auto rbegin(R &&r) {return re::rbegin(r);}
  template <class R>
  static auto rend(R &&r) {return re::rend(r);}
  template <class R>
  static auto size(R &&r) {return re::size(r);}
  template <class R>
  static auto empty(R &&r) {return re::empty(r);}

public:
  using pointer = alloc_ptr<AL>;
  using const_pointer = alloc_cptr<AL>;

  // container

  using value_type = alloc_vt<AL>;
  using reference = value_type &;
  using const_reference = const value_type &;

  using iterator = inner::deque_iterator<value_type, AL>;
  using const_iterator = inner::deque_iterator<const value_type, AL>;
  using difference_type = alloc_dft<AL>;
  using size_type = alloc_szt<AL>;

  iterator begin() noexcept {
    return iterator(upper_op, lower_op, upper_bufp);
  }
  iterator end() noexcept {
    return iterator(upper_ed, lower_ed, upper_bufp);
  }
  const_iterator begin() const noexcept {
    return const_iterator(upper_op, lower_op, upper_bufp);
  }
  const_iterator end() const noexcept {
    return const_iterator(upper_ed, lower_ed, upper_bufp);
  }
  const_iterator cbegin() const noexcept {
    return begin();
  }
  const_iterator cend() const noexcept {
    return end();
  }

  size_type max_size() const noexcept {
    return container_regular_max_size<this_t>()
      - sizeof(lower_buffer_head_t) - 1u
      - inner::deque_default_lower_buffer_size<T>::value * sizeof(value_type);
  }
  size_type size() const noexcept {
    if (upper_op == upper_ed)
      return lower_ed - lower_op;
    else
      return (*upper_op + lower_buf_size() - lower_op)
        + (lower_ed - *upper_ed)
        + lower_buf_size() * ((upper_op < upper_ed)
                              ? (upper_ed - upper_op - 1)
                              : ((upper_bufp->ed - upper_op)
                                 + (upper_ed - upper_bufp->op) - 1));
  }
  bool empty() const noexcept {
    return lower_op == lower_ed;
  }

private:
  // inner implements

  friend class allocator_aware_container_ownership<this_t>;
  const AL &alloc_ref() const noexcept {
    return alw_t::get();
  }
  AL &alloc_ref() noexcept {
    return alw_t::get();
  }
  void new_data() noexcept {
    static lower_pointer p = nullptr;
    upper_op = upper_ed = pointer_to<alloc_ptr<AL>>(p);
    lower_op = lower_ed = nullptr;
    upper_bufp = nullptr;
  }
  void delete_data() noexcept {
    if (lower_op != nullptr) {
      destroy(*this);

      auto p = upper_bufp->lower_bufp;
      do {
        const auto tmp = p.head().next;
        alw_t::template rebind<byte>().deallocate_headed_buffer(p);
        p = tmp;
      } while (p != nullptr);

      auto upper_al = upper_alw();
      upper_al.delete_n(upper_bufp->op, upper_buf().size());

      auto buf_info_al = buf_info_alw();
      buf_info_al.delete_1(upper_bufp);
    }
  }
  void new_data(const this_t &v) {
    if (empty(v))
      new_data();
    else {
      initialize_buffer((v.upper_op == v.upper_ed)
                        ? 2u : v.count_used_lower_buf());
      set_end(uninitialized_copy(v, end()));
    }
  }
  void assign_data(const this_t &v) {
    assign_range_impl(v);
  }
  void new_data(this_t &&v) noexcept {
    data_t::operator =(move(static_cast<data_t &>(v)));
    v.new_data();
  }
  void new_data_individually(this_t &&v) {
    if (empty(v))
      new_data();
    else {
      initialize_buffer(v.upper_op == v.upper_ed
                        ? 2 : v.count_used_lower_buf());
      set_end(uninitialized_move(v, end()));
      v.delete_data();
      v.new_data();
    }
  }
  void assign_data_individually(this_t &&v) {
    assign_range_impl(move_rng(v));
    v.delete_data();
    v.new_data();
  }
  void swap_data(this_t &v) noexcept {
    adl_swap(static_cast<data_t &>(*this), static_cast<data_t &>(v));
  }
  void swap_data_individually(this_t &v) {
    const bool y = size() < v.size();
    this_t &shorter = y ? *this : v;
    this_t &longer = y ? v : *this;
    const iterator it = swap_ranges(shorter, longer.begin());
    shorter.append_range_impl(move_rng(rng(it, longer.end())));
    longer.erase_range_impl(it, longer.end());
  }

  auto upper_alw() noexcept {
    return alw_t::template rebind<lower_pointer>();
  }
  auto buf_info_alw() noexcept {
    return alw_t::template rebind<upper_buffer_t>();
  }

  auto upper_buf() const noexcept {
    return rng(upper_bufp->op, upper_bufp->ed);
  }

  size_type count_used_lower_buf() const noexcept {
    return upper_op < upper_ed
      ? (upper_ed - upper_op + 1)
      : (upper_bufp->ed - upper_op + (upper_ed - upper_bufp->op) + 1);
  }

  void set_begin(iterator it) noexcept {
    upper_bufp->op_wall = upper_op = it.upper_p;
    lower_op = it.lower_p;
  }
  void set_end(iterator it) noexcept {
    upper_ed = it.upper_p;
    lower_ed = it.lower_p;
  }

  // initialize_buffer(n)
  // initialize_buffer_cleanup(n)
  //   n is lower buffer amount
  //   requires: uninitialized && n >= 2 && n is not beyond limit
  void initialize_buffer(size_type n) {
    auto buf_info_al = buf_info_alw();
    auto upper_al = upper_alw();

    upper_bufp = buf_info_al.new_1();

#ifndef RE_NOEXCEPT
    try {
#endif
      upper_bufp->op = upper_al.new_n(n);
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      buf_info_al.delete_1(upper_bufp);
      throw;
    }
#endif
    upper_bufp->ed = upper_bufp->op + n;

    lower_buffer_ptr_t tmp_p;
#ifndef RE_NOEXCEPT
    try {
#endif
      tmp_p = alw_t::template rebind<byte>()
        .template allocate_headed_buffer<lower_buffer_head_t, value_type>
        (n * lower_buf_size());
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      upper_al.delete_n(upper_bufp->op, n);
      buf_info_al.delete_1(upper_bufp);
      throw;
    }
#endif
    tmp_p.head().next = nullptr;
    upper_bufp->lower_bufp = tmp_p;

    auto p = tmp_p.data();
    for (auto &x : upper_buf()) {
      x = p;
      p += lower_buf_size();
    }

    upper_bufp->op_wall = upper_op = upper_ed = upper_bufp->op;
    lower_op = lower_ed = *upper_op;
  }
  void initialize_buffer_cleanup(size_type n) {
#ifndef RE_NOEXCEPT
    try {
#endif
      initialize_buffer(n);
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      new_data();
      throw;
    }
#endif
  }
  // reallocate_buffer(n)
  //   n is lower buffer amount
  //   requires: upper_bufp != nullptr && n >= 2 && n is not beyond limit
  //     && n is not smaller than current lower buf amount
  void reallocate_buffer(size_type n) {
    auto upper_a = upper_alw();

    const upper_pointer newbuf_op = upper_a.new_n(n);
    const upper_pointer newbuf_ed = newbuf_op + n;

    lower_buffer_ptr_t tmp_p;
#ifndef RE_NOEXCEPT
    try {
#endif
      tmp_p = alw_t::template rebind<byte>()
        .template allocate_headed_buffer<lower_buffer_head_t, value_type>
        ((n - upper_buf().size()) * lower_buf_size());
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      upper_a.delete_n(newbuf_op, n);
      throw;
    }
#endif
    tmp_p.head().next = upper_bufp->lower_bufp;
    upper_bufp->lower_bufp = tmp_p;

    upper_pointer mid;
    if (upper_op <= upper_ed) {
      mid = copy(upper_buf(), newbuf_op);
      upper_op = newbuf_op + (upper_op - upper_bufp->op);
      upper_ed = newbuf_op + (upper_ed - upper_bufp->op);
    }
    else {
      mid = copy(rng(upper_bufp->op, upper_op),
                 copy(rng(upper_op, upper_bufp->ed), newbuf_op));
      upper_ed = newbuf_op + (upper_bufp->ed - upper_op
                              + (upper_ed - upper_bufp->op));
      upper_op = newbuf_op;
    }
    upper_a.delete_n(upper_bufp->op, upper_bufp->ed - upper_bufp->op);
    upper_bufp->op = newbuf_op;
    upper_bufp->ed = newbuf_ed;
    upper_bufp->op_wall = upper_op;
    auto p = tmp_p.data();
    for (auto &pp : rng(mid, newbuf_ed)) {
      pp = p;
      p += lower_buf_size();
    }
  }

  void reserve_raw_space_back_at_least_1() {
    if (lower_op == nullptr)
      initialize_buffer_cleanup(2u);
    else if (lower_ed == *upper_ed + lower_buf_size() - 1) {
      upper_pointer next_upper_p = upper_ed;
      if (++next_upper_p == upper_bufp->ed)
        next_upper_p = upper_bufp->op;
      if (next_upper_p == upper_op) {
        const size_type bufsz = upper_buf().size();
        const size_type upper_rest
          = numeric_limits<size_type>::max() / lower_buf_size() - bufsz;
        if (upper_rest == 0u)
          throw_or_terminate<length_error>
            ("re::deque: size overflow in "
             "reserve_raw_space_back_at_least_1()\n");
        reallocate_buffer((upper_rest > bufsz) ? (bufsz + bufsz) : upper_rest);
      }
    }
  }
  void reserve_raw_space_front_at_least_1() {
    if (lower_op == nullptr) {
      initialize_buffer_cleanup(2u);
      lower_op = (lower_ed += lower_buf_size() - 1);
    }
    else if (lower_op == *upper_op) {
      upper_pointer next_upper_p = upper_op;
      if (next_upper_p == upper_bufp->op)
        next_upper_p = upper_bufp->ed;
      --next_upper_p;
      if (next_upper_p == upper_ed) {
        const size_type bufsz = upper_buf().size();
        const size_type upper_rest
          = numeric_limits<size_type>::max() / lower_buf_size() - bufsz;
        if (upper_rest == 0u)
          throw_or_terminate<length_error>
            ("re::deque: size overflow in "
             "reserve_raw_space_front_at_least_1()\n");
        reallocate_buffer((upper_rest > bufsz) ? (bufsz + bufsz) : upper_rest);
      }
    }
  }
  template <class UINT>
  void reserve_raw_space_back_at_least(UINT n) {
    static_assert(is_unsigned_v<UINT> && is_integral_v<UINT>);
    if (lower_op == nullptr)
      initialize_buffer_cleanup((n < lower_buf_size())
                                ? 2u : (n / lower_buf_size() + 1u));
    else {
      const size_type rest
        = *upper_ed + lower_buf_size() - 1 - lower_ed
        + (upper_op <= upper_ed
           ? (upper_op - upper_bufp->op + (upper_bufp->ed - upper_ed - 1))
           : (upper_op - upper_ed - 1))
        * lower_buf_size();
      if (n > rest) {
        n -= rest;
        const size_type bufsz = upper_buf().size();
        const size_type upper_rest
          = numeric_limits<size_type>::max() / lower_buf_size() - bufsz;
        n = n / lower_buf_size() + 1u;
        if (n >= upper_rest)
          throw_or_terminate<length_error>
            ("re::deque: size overflow in "
             "reserve_raw_space_back_at_least(n)\n");
        reallocate_buffer((n < bufsz && upper_rest > bufsz)
                          ? bufsz + bufsz : n + bufsz);
      }
    }
  }
  template <class UINT>
  void reserve_raw_space_front_at_least(UINT n) {
    static_assert(is_unsigned_v<UINT> && is_integral_v<UINT>);
    if (lower_op == nullptr) {
      initialize_buffer_cleanup((n < lower_buf_size())
                                ? 2u : (n / lower_buf_size() + 1u));
      lower_op = (lower_ed += (lower_buf_size() - 1u));
    }
    else {
      const size_type rest
        = (lower_op - *upper_op)
        + to_unsigned(upper_op <= upper_ed
                      ? (upper_op - upper_bufp->op
                         + (upper_bufp->ed - upper_ed - 1))
                      : (upper_op - upper_ed - 1))
        * lower_buf_size();
      if (n > rest) {
        n -= rest;
        const size_type bufsz = upper_buf().size();
        const size_type upper_rest
          = numeric_limits<size_type>::max() / lower_buf_size() - bufsz;
        n = n / lower_buf_size() + 1u;
        if (n >= upper_rest)
          throw_or_terminate<length_error>
            ("re::deque: size overflow in "
             "reserve_raw_space_front_at_least(n)\n");
        reallocate_buffer((n < bufsz && upper_rest > bufsz)
                          ? bufsz + bufsz : n + bufsz);
      }
    }
  }

  template <class...S>
  reference emplace_back_impl(S &&...s) {
    reserve_raw_space_back_at_least_1();
    const auto retp = to_address(lower_ed);
    construct(retp, forward<S>(s)...);
    ++lower_ed;
    if (lower_ed == *upper_ed + lower_buf_size()) {
      ++upper_ed;
      if (upper_ed == upper_bufp->ed)
        upper_ed = upper_bufp->op;
      lower_ed = *upper_ed;
    }
    return *retp;
  }
  template <class...S>
  reference emplace_front_impl(S &&...s) {
    reserve_raw_space_front_at_least_1();
#ifndef RE_NOEXCEPT
    const auto it = --begin();
    construct(to_address(it.lower_p), forward<S>(s)...);
    set_begin(it);
#else
    set_begin(--begin());
    construct(to_address(lower_op), forward<S>(s)...);
#endif
    return *lower_op;
  }

  void pop_back_impl() noexcept {
    set_end(--end());
    destroy(to_address(lower_ed));
  }
  void pop_front_impl() noexcept {
    destroy(to_address(lower_op));
    set_begin(++begin());
  }

  template <class...S>
  iterator emplace_impl(const_iterator it, S &&...s) {
    if (it == begin()) {
      emplace_front_impl(forward<S>(s)...);
      return begin();
    }
    else if (it == end()) {
      emplace_back_impl(forward<S>(s)...);
      return --end();
    }
    else {
      auto tmp = make_temporary(forward<S>(s)...);
      iterator new_pos;
      const auto n1 = it - begin();
      const auto n2 = end() - it;
      if (n1 < n2) {
        reserve_raw_space_front_at_least_1();
        new_pos = end() - n2;
        iterator tmp_it = --begin();
        iterator tmp_it2 = ++begin();
        construct(to_address(tmp_it.lower_p), move(*begin()));
        set_begin(tmp_it);
        new_pos = move(rng(tmp_it2, new_pos), ++tmp_it);
      }
      else {
        reserve_raw_space_back_at_least_1();
        new_pos = begin() + n1;
        const iterator old_end = end();
        construct(to_address(lower_ed), move(*--end()));
        set_end(++end());
        move_backward(rng(new_pos, --copy(old_end)), old_end);
      }
      *new_pos = move(*tmp);
      return new_pos;
    }
  }

  iterator erase_impl(const_iterator cit) {
    const iterator it = cit.to_mutable();
    const difference_type n1 = it - begin();
    const difference_type n2 = end() - it;
    const iterator next_it = ++copy(it);
    if (n1 < n2) {
      move_backward(rng(begin(), it), next_it);
      destroy(to_address(lower_op));
      set_begin(++begin());
      return next_it;
    }
    else {
      move(rng(next_it, end()), it);
      set_end(--end());
      destroy(to_address(lower_ed));
      return it;
    }
  }
  iterator erase_range_impl(const_iterator from, const_iterator to) {
    const iterator it1 = from.to_mutable();
    const iterator it2 = to.to_mutable();
    if (it1 == it2)
      return it1;
    const difference_type n1 = it1 - begin();
    const difference_type n2 = end() - it2;
    if (n1 < n2) {
      const iterator old_begin = begin();
      set_begin(move_backward(rng(begin(), it1), it2));
      destroy(rng(old_begin, begin()));
      return it2;
    }
    else {
      const iterator old_end = end();
      set_end(move(rng(it2, end()), it1));
      destroy(rng(end(), old_end));
      return it1;
    }
  }
  void clear_impl() noexcept {
    if (lower_op != nullptr) {
      destroy(*this);
      upper_bufp->op_wall = upper_op = upper_ed = upper_bufp->op;
      lower_op = lower_ed = *upper_op;
    }
  }

  template <class SZT>
  void size_check(SZT n) {
    static_assert(is_integral_v<SZT> && is_unsigned_v<SZT>);
    if (n > max_size())
      throw_or_terminate<length_error>
        ("re::deque: size overflow in size_check(n)\n");
  }

  template <class IITR_RANGE>
  enable_if_t<rng_is_sized<IITR_RANGE>>
  construct_from_range_impl(IITR_RANGE &&r) {
    if (empty(r))
      new_data();
    else {
      const auto r_sz = size(r);
      size_check(r_sz);
      initialize_buffer(r_sz < lower_buf_size()
                        ? 2u : r_sz / lower_buf_size() + 1u);
      set_end(uninitialized_copy(r, end()));
    }
  }
  template <class IITR_RANGE>
  enable_if_t<!rng_is_sized<IITR_RANGE>>
  construct_from_range_impl(IITR_RANGE &&r) {
    new_data();
    for (auto &p : iters(r))
      emplace_back_impl(*p);
  }

  void construct_n_impl(size_type n) {
    if (n == 0u)
      new_data();
    else {
      size_check(n);
      initialize_buffer(n < lower_buf_size() ? 2u : n / lower_buf_size() + 1u);
      const auto new_end = end() + n;
      uninitialized_fill(rng(end(), new_end));
      set_end(new_end);
    }
  }

  template <class IITR_RANGE>
  enable_if_t<rng_is_sized<IITR_RANGE>> assign_range_impl(IITR_RANGE &&r) {
    const auto n = size(r);
    const size_type sz = size();
    if (n <= sz)
      erase_range_impl(copy(r, begin()), end());
    else {
      reserve_raw_space_back_at_least(n - sz);
      const auto r_ed = end(r);
      auto it = begin(r);
      it = copy_from(*this, it);
      set_end(uninitialized_copy(rng(it, r_ed), end()));
    }
  }
  template <class IITR_RANGE>
  enable_if_t<!rng_is_sized<IITR_RANGE>> assign_range_impl(IITR_RANGE &&r) {
    auto r1 = rng(*this);
    auto r2 = rng(r);
    for (;;) {
      if (empty(r1)) {
        append_range_impl(r2);
        return;
      }
      if (empty(r2)) {
        erase_range_impl(r1.first, r1.second);
        return;
      }
      *r1.first = *r2.first;
      ++r1.first;
      ++r2.first;
    }
  }

  template <class IITR_RANGE>
  enable_if_t<rng_is_sized<IITR_RANGE>>
  prepend_range_impl(IITR_RANGE &&r) {
    const auto r_sz = size(r);
    reserve_raw_space_front_at_least(r_sz);
#ifndef RE_NOEXCEPT
    const iterator new_begin = begin() - r_sz;
    uninitialized_copy(r, new_begin);
    set_begin(new_begin);
#else
    set_begin(begin() - r_sz);
    uninitialized_copy(r, begin());
#endif
  }
  template <class IITR_RANGE>
  enable_if_t<!rng_is_sized<IITR_RANGE>>
  prepend_range_impl(IITR_RANGE &&r) {
    const auto dif = begin() - end();
    for (auto &p : iters(r))
      emplace_front_impl(*p);
    reverse(rng(begin(), end() + dif));
  }

  template <class IITR_RANGE>
  enable_if_t<rng_is_sized<IITR_RANGE>>
  append_range_impl(IITR_RANGE &&r) {
    reserve_raw_space_back_at_least(size(r));
    set_end(uninitialized_copy(r, end()));
  }
  template <class IITR_RANGE>
  enable_if_t<!rng_is_sized<IITR_RANGE>>
  append_range_impl(IITR_RANGE &&r) {
    for (auto &p : iters(r))
      emplace_back_impl(*p);
  }

  template <class IITR_RANGE>
  enable_if_t<rng_is_sized<IITR_RANGE>
              || is_fitr<rng_itr<IITR_RANGE>>, iterator>
  insert_range_impl(const_iterator cit, IITR_RANGE &&r) {
    iterator new_it = cit.to_mutable();
    if (new_it == end()) {
      const auto dif = size();
      append_range_impl(r);
      return begin() + dif;
    }
    else if (new_it == begin()) {
      prepend_range_impl(r);
      return begin();
    }
    else {
      if (empty(r))
        return new_it;
      const difference_type n1 = new_it - begin();
      const difference_type n2 = end() - new_it;
      const auto n = size(r);
      if (n1 < n2) {
        reserve_raw_space_front_at_least(n);
        new_it = end() - n2;
        const iterator new_begin = begin() - n;
        iterator mid = new_it - n;
        if ((mid.upper_p == upper_op && mid.lower_p <= lower_op)
            || ((upper_op <= upper_ed
                 && (mid.upper_p < upper_op || mid.upper_p > upper_ed))
                || (upper_op > upper_ed
                    && mid.upper_p < upper_op && mid.upper_p > upper_ed))) {
          uninitialized_move(rng(begin(), new_it), new_begin);
          const auto ed = end(r);
          auto it = begin(r);
          iterator mid2 = mid;
#ifndef RE_NOEXCEPT
          try {
#endif
            for (; mid2 != begin(); ++mid2, (void)++it)
              construct(to_address(mid2.lower_p), *it);
#ifndef RE_NOEXCEPT
          }
          catch (...) {
            destroy(rng(new_begin, mid2));
            throw;
          }
#endif
          set_begin(new_begin);
          copy(rng(it, ed), mid2);
          return mid;
        }
        else {
          mid = begin() + n;
          uninitialized_move(rng(begin(), mid), new_begin);
#ifndef RE_NOEXCEPT
          try {
#endif
            mid = move(rng(mid, new_it), begin());
            copy(r, mid);
#ifndef RE_NOEXCEPT
          }
          catch (...) {
            for (auto &p : iters(new_begin, begin()))
              destroy(to_address(p));
            throw;
          }
#endif
          set_begin(new_begin);
          return mid;
        }
      }
      else {
        reserve_raw_space_back_at_least(n);
        new_it = begin() + n1;
        const iterator mid = new_it + n;
        if ((mid.upper_p == upper_ed && mid.lower_p >= lower_ed)
            || ((upper_op <= upper_ed
                 && (mid.upper_p > upper_ed || mid.upper_p < upper_op))
                || (upper_op > upper_ed
                    && mid.upper_p > upper_ed && mid.upper_p < upper_op))) {
          const iterator new_end = uninitialized_move(rng(new_it, end()), mid);
          auto it = begin(r);
          const auto ed = end(r);
#ifndef RE_NOEXCEPT
          try {
#endif
            it = copy_from(rng(new_it, end()), it);
            uninitialized_copy(rng(it, ed), end());
#ifndef RE_NOEXCEPT
          }
          catch (...) {
            destroy(rng(mid, new_end));
            throw;
          }
#endif
          set_end(new_end);
        }
        else {
          const iterator cut = end() - n;
          const iterator new_end = uninitialized_move(rng(cut, end()), end());
#ifndef RE_NOEXCEPT
          try {
#endif
            move_backward(rng(new_it, cut), end());
            copy(r, new_it);
#ifndef RE_NOEXCEPT
          }
          catch (...) {
            destroy(rng(end(), new_end));
            throw;
          }
#endif
          set_end(new_end);
        }
        return new_it;
      }
    }
  }
  template <class IITR_RANGE>
  enable_if_t<!(rng_is_sized<IITR_RANGE> || is_fitr<rng_itr<IITR_RANGE>>),
              iterator>
  insert_range_impl(const_iterator cit, IITR_RANGE &&r) {
    const iterator it = cit;
    if (it == cbegin()) {
      prepend_range_impl(r);
      return begin();
    }
    const difference_type old_sz = size();
    if (it == cend()) {
      append_range_impl(r);
      return begin() + old_sz;
    }
    else {
      const auto n1 = it - begin();
      const auto n2 = end() - it;
      if (n1 < n2) {
        for (auto &p : iters(r))
          emplace_front(*p);
        const iterator old_begin = end() - old_sz;
        reverse(rng(begin(), old_begin));
        return rotate(rng(begin(), end() - n2), old_begin);
      }
      else {
        for (auto &p : iters(r))
          emplace_back(*p);
        const iterator new_it = begin() + n1;
        rotate(rng(new_it, end()), begin() + old_sz);
        return new_it;
      }
    }
  }

  iterator insert_n_impl(const_iterator p,
                         size_type n, const value_type &x) {
    auto tmp = make_temporary(x);
    return insert_range_impl(p, rng(n, ref(*tmp)));
  }

  template <class...S>
  void resize_impl(size_type n, const S &...s) {
    const size_type sz = size();
    if (n <= sz)
      erase_range_impl(begin() + n, end());
    else {
      const size_type nn = n - sz;
      reserve_raw_space_back_at_least(nn);
      const iterator new_end = end() + nn;
      uninitialized_fill(rng(end(), new_end), s...);
      set_end(new_end);
    }
  }

  void shrink_to_fit_impl() {
    if (empty()) {
      delete_data();
      new_data();
    }
    else {
      const auto sz = size();
      const size_type nn = (sz < lower_buf_size()
                            ? 2u : (sz / lower_buf_size() + 1u));
      if (upper_buf().size() > nn) {
        this_t tmp(alloc_ref());
        tmp.initialize_buffer_cleanup(nn);
        tmp.set_end(uninitialized_fully_move(*this, tmp.end()));
        upper_bufp->op_wall = upper_ed = upper_op = upper_bufp->op;
        lower_op = lower_ed = *upper_op;
        adl_swap(*this, tmp);
      }
    }
  }
  void reserve_impl(size_type n) {
    if (n != 0) {
      if (lower_op == nullptr)
        initialize_buffer_cleanup(n / lower_buf_size() + 2u);
      else if (n > ((upper_buf().size() - 1u) * lower_buf_size())) {
        if (n > max_size())
          throw_or_terminate<length_error>
            ("re::deque: size overflow in reserve_impl(n)\n");
        reallocate_buffer(n / lower_buf_size() + 2u);
      }
    }
  }

public:
  // container (continued)

  deque() noexcept(noexcept(AL())) : deque(AL()) {}
  ~deque() {
    delete_data();
  }
  deque(const deque &v)
    : alw_t(alw_t::traits
            ::select_on_container_copy_construction(v.alloc_ref())) {
    new_data(v);
  }
  deque &operator =(const deque &v) {
    allocator_aware_container_ownership<this_t>::copy_assign(*this, v);
    return *this;
  }
  deque(deque &&v) noexcept : alw_t(move(v.alloc_ref())) {
    new_data(move(v));
  }
  deque &operator =(deque &&v)
    noexcept(alloc_move_prpg<AL> || alloc_always_equal<AL>) {
    allocator_aware_container_ownership<this_t>::move_assign(*this, v);
    return *this;
  }
  friend void swap(deque &x, deque &y)
    noexcept(alloc_swap_prpg<AL> || alloc_always_equal<AL>) {
    allocator_aware_container_ownership<this_t>::swap(x, y);
  }

  template <class TT, class AL2>
  friend bool operator ==(const deque<TT, AL2> &, const deque<TT, AL2> &);

  // optional container operations

  template <class TT, class AL2>
  friend synth_3way_result<TT>
  operator <=>(const deque<TT, AL2> &, const deque<TT, AL2> &);

  // reversible container

  using reverse_iterator = re::reverse_iterator<iterator>;
  using const_reverse_iterator = re::reverse_iterator<const_iterator>;

  reverse_iterator rbegin() noexcept {
    return reverse_iterator(end());
  }
  reverse_iterator rend() noexcept {
    return reverse_iterator(begin());
  }
  const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator(begin());
  }
  const_reverse_iterator crbegin() const noexcept {
    return rbegin();
  }
  const_reverse_iterator crend() const noexcept {
    return rend();
  }

  // allocator-aware container

  using allocator_type = AL;
  allocator_type get_allocator() const noexcept {
    return alw_t::get();
  }

  explicit deque(const AL &al) noexcept : alw_t(al) {
    new_data();
  }
  deque(const deque &v, const AL &al) : alw_t(al) {
    new_data(v);
  }
  deque(deque &&v, const AL &al) : alw_t(move(al)) {
    allocator_aware_container_ownership<this_t>::move_construct(*this, v);
  }

  // sequence container

  explicit deque(size_type n, const AL &al = AL{}) : alw_t(al) {
    construct_n_impl(n);
  }
  deque(size_type n, const T &x, const AL &al = AL{}) : alw_t(al) {
    construct_from_range_impl(rng(n, ref(x)));
  }
  void assign(size_type n, const T &x) {
    assign_range_impl(rng(n, x));
  }

  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  deque(IITR from, IITR to, const AL &al = AL{}) : alw_t(al) {
    construct_from_range_impl(rng(from, to));
  }
  template <class IITR>
  enable_if_t<is_itr<IITR>> assign(IITR from, IITR to) {
    assign_range_impl(rng(from, to));
  }

  deque(initializer_list<T> l, const AL &al = AL{}) : alw_t(al) {
    construct_from_range_impl(l);
  }
  deque &operator =(initializer_list<T> l) {
    assign_range_impl(l);
    return *this;
  }
  void assign(initializer_list<T> l) {
    assign_range_impl(l);
  }

  template <class...S>
  iterator emplace(const_iterator pos, S &&...s) {
    return emplace_impl(pos, forward<S>(s)...);
  }
  iterator insert(const_iterator pos, const T &x) {
    return emplace_impl(pos, x);
  }
  iterator insert(const_iterator pos, T &&x) {
    return emplace_impl(pos, move(x));
  }

  iterator insert(const_iterator pos, size_type n, const T &x) {
    return insert_n_impl(pos, n, x);
  }
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  iterator insert(const_iterator pos, IITR from, IITR to) {
    return insert_range_impl(pos, rng(from, to));
  }
  iterator insert(const_iterator pos, initializer_list<T> l) {
    return insert_range_impl(pos, l);
  }

  iterator erase(const_iterator pos) {
    return erase_impl(pos);
  }
  iterator erase(const_iterator from, const_iterator to) {
    return erase_range_impl(from, to);
  }
  void clear() noexcept {
    clear_impl();
  }

  // optional sequence container operations

  reference front() {
    return *lower_op;
  }
  reference back() {
    return *--end();
  }
  const_reference front() const {
    return *lower_op;
  }
  const_reference back() const {
    return *--end();
  }

  template <class...S>
  reference emplace_back(S &&...s) {
    return emplace_back_impl(forward<S>(s)...);
  }
  void push_back(const T &x) {
    emplace_back_impl(x);
  }
  void push_back(T &&x) {
    emplace_back_impl(move(x));
  }
  void pop_back() {
    pop_back_impl();
  }

  template <class...S>
  reference emplace_front(S &&...s) {
    return emplace_front_impl(forward<S>(s)...);
  }
  void push_front(const T &x) {
    emplace_front_impl(x);
  }
  void push_front(T &&x) {
    emplace_front_impl(move(x));
  }
  void pop_front() {
    pop_front_impl();
  }

  reference operator [](size_type n) {
    return begin()[n];
  }
  const_reference operator [](size_type n) const {
    return begin()[n];
  }
  reference at(size_type n) {
    if (n >= size())
      throw_or_terminate<out_of_range>("re::deque: at(n) failed\n");
    return begin()[n];
  }
  const_reference at(size_type n) const {
    if (n >= size())
      throw_or_terminate<out_of_range>("re::deque: at(n) failed\n");
    return begin()[n];
  }

  // specialized operations

  void resize(size_type n) {
    resize_impl(n);
  }
  void resize(size_type n, const T &x) {
    resize_impl(n, x);
  }
  void shrink_to_fit() {
    shrink_to_fit_impl();
  }

  // extensions

  void reserve(size_type n) {
    reserve_impl(n);
  }
  size_type upper_capacity() const noexcept {
    return lower_op == nullptr
      ? 0u : (upper_buf().size() * lower_buf_size() - 1u);
  }
  size_type lower_capacity() const noexcept {
    return lower_op == nullptr
      ? 0u : ((upper_buf().size() - 1u) * lower_buf_size());
  }
  void reallocate(size_type n) {
    if (const auto z = size(); n < z)
      n = z;
    else if (n > max_size())
      throw_or_terminate<length_error>
        ("re::deque: size overflow in reallocate(n)\n");
    if (n == 0u) {
      delete_data();
      new_data();
    }
    else {
      this_t tmp(alloc_ref());
      tmp.initialize_buffer_cleanup(n < lower_buf_size()
                                    ? 2u : n / lower_buf_size() + 1u);
      tmp.set_end(uninitialized_fully_move(*this, tmp.end()));
      if (lower_op != nullptr) {
        upper_bufp->op_wall = upper_ed = upper_op = upper_bufp->op;
        lower_op = lower_ed = *upper_op;
      }
      adl_swap(*this, tmp);
    }
  }
  void reallocate() {
    reallocate(size());
  }

  void reserve_more(size_type n) {
    reserve_raw_space_back_at_least(n);
  }

  template <class UF>
  size_type remove_if(UF eq) {
    const auto i = re::remove_if(*this, eq);
    const auto z = end();
    const size_type ret = z - i;
    erase(i, z);
    return ret;
  }
  template <class X>
  size_type remove(const X &x) {
    return remove_if(bind(equal_to<>(), _1, ref(x)));
  }

  bool full() const noexcept {
    if (lower_op == nullptr)
      return true;
    else {
      auto p = upper_ed + 1;
      if (p == upper_bufp->ed)
        p = upper_bufp->op;
      if (p == upper_op)
        return ((lower_ed - *upper_ed)
                + (*upper_op + lower_buf_size() - lower_op))
          >= lower_buf_ssize();
      else
        return false;
    }
  }

  template <class R>
  iterator replace(const_iterator i1, const_iterator i2, R &&r) {
    return inner::fns::seq_container_replace_impl
      (*this, i1.to_mutable(), i2.to_mutable(), r);
  }

  template <class R>
  deque(from_range_t, R &&r, const allocator_type &a = allocator_type{})
    requires (is_rng<R> && is_constructible_v<value_type, rng_ref<R>>)
    : alw_t(a) {
    construct_from_range_impl(r);
  }
  template <class R, class = enable_if_t
            <!is_same_v<decay_t<R>, this_t>
             && !is_convertible_v<R &&, const allocator_type &>
             && is_rng<R> && is_constructible_v<value_type, rng_ref<R>>>>
  explicit deque(R &&r) : deque(r, allocator_type{}) {}
  template <class R, class = enable_if_t
            <!is_same_v<decay_t<R>, this_t>
             && is_rng<R> && is_constructible_v<value_type, rng_ref<R>>>>
  deque(R &&r, const allocator_type &al) : alw_t(al) {
    construct_from_range_impl(r);
  }
  template <class IITR_RANGE>
  enable_if_t<!is_same_v<decay_t<IITR_RANGE>, this_t>
              && is_rng<IITR_RANGE>
              && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
              && is_assignable_v<value_type &, rng_ref<IITR_RANGE>>, this_t &>
  operator =(IITR_RANGE &&r) {
    assign_range_impl(r);
    return *this;
  }
  template <class IITR_RANGE>
  void assign(IITR_RANGE &&r) {
    assign_range_impl(r);
  }
  template <class IITR_RANGE>
  void assign_range(IITR_RANGE &&r) {
    assign_range_impl(r);
  }

  template <class IITR_RANGE>
  enable_if_t<!is_convertible_v<IITR_RANGE &&, value_type &&>
              && !is_convertible_v<IITR_RANGE &&, const value_type &>, iterator>
  insert(const_iterator pos, IITR_RANGE &&r) {
    return insert_range_impl(pos, r);
  }
  template <class IITR_RANGE>
  iterator insert_range(const_iterator pos, IITR_RANGE &&r) {
    return insert_range_impl(pos, r);
  }

  template <class IITR_RANGE>
  enable_if_t<!is_convertible_v<IITR_RANGE &&, value_type &&>
              && !is_convertible_v<IITR_RANGE &&, const value_type &>>
  push_back(IITR_RANGE &&r) {
    append_range_impl(r);
  }
  template <class IITR_RANGE>
  void append_range(IITR_RANGE &&r) {
    append_range_impl(r);
  }
  void pop_back(size_type n) {
    for (; n != 0; --n)
      pop_back();
  }

  template <class IITR_RANGE>
  enable_if_t<!is_convertible_v<IITR_RANGE &&, value_type &&>
              && !is_convertible_v<IITR_RANGE &&, const value_type &>>
  push_front(IITR_RANGE &&r) {
    prepend_range_impl(r);
  }
  template <class IITR_RANGE>
  void prepend_range(IITR_RANGE &&r) {
    prepend_range_impl(r);
  }
  void pop_front(size_type n) {
    for (; n != 0; --n)
      pop_front();
  }

  this_t &append() {
    return *this;
  }
  template <class X, class...S>
  this_t &append(X &&x, S &&...s) {
    push_back(forward<X>(x));
    return append(forward<S>(s)...);
  }

  this_t &prepend() {
    return *this;
  }
  template <class X, class...S>
  this_t &prepend(X &&x, S &&...s) {
    prepend(forward<S>(s)...);
    push_front(forward<X>(x));
    return *this;
  }
};
template <class T, class AL>
bool operator ==(const deque<T, AL> &x, const deque<T, AL> &y) {
  return equal(x, y);
}
template <class T, class AL>
synth_3way_result<T> operator <=>(const deque<T, AL> &x,
                                  const deque<T, AL> &y) {
  return lexicographical_synth_3way(x, y);
}

}

// forward_list
namespace re {

namespace inner {

template <class TRAITS>
class node_handle {
protected:
  using node_pointer = typename TRAITS::node_base_pointer;
  using alloc_t = typename TRAITS::allocator_type;

  node_pointer p{};
  alignas(alloc_t) byte alloc_storage[sizeof(alloc_t)]{};

  alloc_t *alloc_ptr() noexcept {
    return reinterpret_cast<alloc_t *>(addressof(alloc_storage));
  }
  alloc_t &alloc_ref() noexcept {
    return *alloc_ptr();
  }
  const alloc_t *alloc_ptr() const noexcept {
    return reinterpret_cast<const alloc_t *>(addressof(alloc_storage));
  }
  const alloc_t &alloc_ref() const noexcept {
    return *alloc_ptr();
  }

  void delete_data() noexcept {
    if (p != nullptr) {
      TRAITS::delete_node(alloc_ref(), p);
      alloc_ref().~alloc_t();
    }
  }

public:
  using allocator_type = alloc_t;

  node_handle() = default;
  ~node_handle() {
    delete_data();
  }
  node_handle(const node_handle &) = delete;
  node_handle &operator =(const node_handle &) = delete;
  node_handle(node_handle &&x) noexcept {
    p = x.p;
    if (x.p != nullptr) {
      ::new(alloc_ptr()) alloc_t(move(x.alloc_ref()));
      x.alloc_ref().~alloc_t();
      x.p = nullptr;
    }
  }
  node_handle &operator =(node_handle &&x) noexcept {
    if (this != addressof(x)) {
      this->~node_handle();
      ::new(this) node_handle(move(x));
    }
    return *this;
  }
  friend void swap(node_handle &x, node_handle &y)
    noexcept(alloc_swap_prpg<alloc_t> || alloc_always_equal<alloc_t>) {
    if (x.p != nullptr) {
      if (y.p != nullptr)
        adl_swap(x.alloc_ref(), y.alloc_ref());
      else {
        ::new(y.alloc_ptr()) alloc_t(move(x.alloc_ref()));
        x.alloc_ref().~alloc_t();
      }
    }
    else {
      if (y.p != nullptr) {
        ::new(x.alloc_ptr()) alloc_t(move(y.alloc_ref()));
        y.alloc_ref().~alloc_t();
      }
    }
    adl_swap(x.p, y.p);
  }

  explicit node_handle(node_pointer pp, const alloc_t &al) noexcept
    : p(pp) {
    ::new(alloc_ptr()) alloc_t(al);
  }

  // get_allocator() requires: p != nullptr
  alloc_t get_allocator() const {
    return alloc_ref();
  }
  explicit operator bool() const noexcept {
    return p != nullptr;
  }
  bool empty() const noexcept {
    return p == nullptr;
  }

  // release(): extract the owned node pointer, may return nullptr
  node_pointer get() const noexcept {
    return p;
  }
  node_pointer release() noexcept {
    if (p != nullptr)
      alloc_ref().~alloc_t();
    return exchange(p, nullptr);
  }

  typename TRAITS::value_type &operator *() const {
    return *TRAITS::data(p);
  }
  void clear() noexcept {
    operator =({});
  }
};

template <class TRAITS>
class forward_list_node_handle : node_handle<TRAITS> {
  using base_t = node_handle<TRAITS>;
  using this_t = forward_list_node_handle;

public:
  using base_t::allocator_type;

  forward_list_node_handle() noexcept = default;
  forward_list_node_handle(const this_t &) = delete;
  forward_list_node_handle &operator =(const this_t &) = delete;
  forward_list_node_handle(this_t &&) noexcept = default;
  forward_list_node_handle &operator =(this_t &&) = default;
  friend void swap(this_t &x, this_t &y)
    noexcept(is_nothrow_swappable_v<base_t>) {
    adl_swap(static_cast<base_t &>(x), static_cast<base_t &>(y));
  }

  explicit forward_list_node_handle(typename base_t::node_pointer p,
                                    const typename base_t::alloc_t &al)
    : base_t(p, al) {}

  using base_t::get_allocator;
  using base_t::empty;
  using base_t::operator bool;
  using base_t::get;
  using base_t::release;
  using base_t::operator *;
};

}

template <size_t ID = 0, class VOID_PTR = void *>
struct join_forward_list {
  typename pointer_traits<VOID_PTR>::template rebind<join_forward_list> next;
};

template <class T, class AL = default_allocator<T>>
struct forward_list_node : join_forward_list<0, alloc_void_ptr<AL>> {
  alignas(T) byte data[sizeof(T)];

  T &operator *() const {
    return *reinterpret_cast<T *>(addressof(data));
  }
  T *operator ->() const {
    return reinterpret_cast<T *>(addressof(data));
  }
};
namespace inner {

template <class NODE_BASE_TYPE, class SIZE_TYPE, bool STORE_SIZE>
struct forward_list_header_data {
  mutable NODE_BASE_TYPE op;
};
template <class NODE_BASE_TYPE, class SIZE_TYPE>
struct forward_list_header_data<NODE_BASE_TYPE, SIZE_TYPE, true> {
  mutable NODE_BASE_TYPE op;
  SIZE_TYPE sz;
};

}

template <class NODE_T, size_t ID = 0,
          bool STORE_SIZE = false, bool STORE_NODE_ALLOCATOR = false,
          class AL = default_allocator<NODE_T>>
struct forward_list_traits {
  using value_type = alloc_vt<AL>;
  using allocator_type = AL;
  using node_type = NODE_T;
  using node_pointer = alloc_rebind_ptr<AL, node_type>;
  using node_base_type = join_forward_list<ID, alloc_void_ptr<AL>>;
  using node_base_pointer = alloc_rebind_ptr<AL, node_base_type>;
  using difference_type = alloc_dft<AL>;
  using size_type = alloc_szt<AL>;

  using id = size_constant<ID>;
  using store_node_allocator = bool_constant<STORE_NODE_ALLOCATOR>;
  using store_allocator = bool_constant<STORE_NODE_ALLOCATOR>;
  using store_size = bool_constant<STORE_SIZE>;

  static node_base_pointer next(node_base_pointer p) {
    return p->next;
  }
  static void next(node_base_pointer p, node_base_pointer next_p) {
    p->next = next_p;
  }

  template <class VT = value_type>
  static enable_if_t<!is_same_v<VT, node_type>, value_type *>
  data(node_base_pointer p) {
    return reinterpret_cast<value_type *>
      (addressof(static_cast<node_pointer>(p)->data));
  }
  template <class VT = value_type>
  static enable_if_t<is_same_v<VT, node_type>, value_type *>
  data(node_base_pointer p) {
    return to_address(static_cast<node_pointer>(p));
  }

  using header_type
    = inner::forward_list_header_data<node_base_type, size_type,
                                      store_size::value>;
  static node_base_pointer before_begin_node(const header_type &h) {
    return pointer_traits<node_base_pointer>::pointer_to(h.op);
  }
  template <bool Y = STORE_SIZE, class = enable_if_t<Y>>
  static size_type size(const header_type &h) {
    return h.sz;
  }
  template <bool Y = STORE_SIZE, class = enable_if_t<Y>>
  static void size(header_type &h, size_type n) {
    h.sz = n;
  }

  template <class...S, class VT = value_type>
  static enable_if_t<!is_same_v<VT, node_type>, node_base_pointer>
  new_node(AL &al, S &&...s) {
    return allocator_wrapper<AL>(al)
      .template new_node<node_type>(forward<S>(s)...);
  }
  template <class VT = value_type>
  static enable_if_t<!is_same_v<VT, node_type>>
  delete_node(AL &al, node_base_pointer p) noexcept {
    allocator_wrapper<AL>(al).delete_node(static_cast<node_pointer>(p));
  }

  template <class...S, class VT = value_type>
  static enable_if_t<is_same_v<VT, node_type>, node_base_pointer>
  new_node(AL &al, S &&...s) {
    return static_cast<node_base_pointer>
      (allocator_wrapper<AL>(al).new_1(forward<S>(s)...));
  }
  template <class VT = value_type>
  static enable_if_t<is_same_v<VT, node_type>>
  delete_node(AL &al, node_base_pointer p) noexcept {
    allocator_wrapper<AL>(al).delete_1(static_cast<node_pointer>(p));
  }
};
template <class>
class forward_list_adaptor;
template <class T, class AL>
struct flstt
  : forward_list_traits<forward_list_node<T, AL>, 0, 0, 1, AL> {
  static_assert(is_same_v<T, alloc_vt<AL>>);
};
template <class T, class AL>
struct slstt
  : forward_list_traits<forward_list_node<T, AL>, 0, 1, 1, AL> {
  static_assert(is_same_v<T, alloc_vt<AL>>);
};
template <class T, class AL = default_allocator<T>>
using forward_list = forward_list_adaptor<flstt<T, AL>>;
template <class T, class AL = default_allocator<T>>
using slist = forward_list_adaptor<slstt<T, AL>>;

template <class>
class forward_list_adaptor;
namespace inner {

template <class T, class TRAITS>
class forward_list_iterator {
  static_assert(is_same_v<remove_const_t<T>, typename TRAITS::value_type>);

  using this_t = forward_list_iterator;

  template <class, class>
  friend class forward_list_iterator;
  template <class>
  friend class re::forward_list_adaptor;

public:
  using node_pointer = typename TRAITS::node_base_pointer;
private:
  node_pointer p{};

public:
  using value_type = remove_const_t<T>;
  using pointer = T *;
  using reference = T &;
  using difference_type = typename TRAITS::difference_type;
  using iterator_category = forward_iterator_tag;

  forward_list_iterator() = default;
  forward_list_iterator(const this_t &) = default;
  forward_list_iterator &operator =(const this_t &) = default;
  forward_list_iterator(this_t &&) = default;
  forward_list_iterator &operator =(this_t &&) = default;
  friend void swap(this_t &x, this_t &y) noexcept {
    adl_swap(x.p, y.p);
  }

  template <class TT = T, class = enable_if_t<is_const_v<TT>>>
  forward_list_iterator
  (forward_list_iterator<remove_const_t<TT>, TRAITS> it) : p(it.p) {}
  template <class TT = T, class = enable_if_t<is_const_v<TT>>>
  this_t &operator =(forward_list_iterator<remove_const_t<TT>, TRAITS> it) {
    p = it.p;
    return *this;
  }

  explicit forward_list_iterator(node_pointer pp) : p(pp) {}
  node_pointer node() const {
    return p;
  }
  auto to_mutable() const requires is_const_v<T> {
    return forward_list_iterator<remove_const_t<T>, TRAITS>(p);
  }

private:
  this_t next() const {
    return this_t(TRAITS::next(p));
  }
  void next(this_t next_p) const {
    TRAITS::next(p, next_p.node());
  }

public:
  reference operator *() const {
    return *TRAITS::data(p);
  }
  pointer operator ->() const {
    return TRAITS::data(p);
  }

  this_t &operator ++() {
    p = next().node();
    return *this;
  }
  this_t operator ++(int) {
    return iter_post_increment(*this);
  }
};
template <class A, class AA, class B>
enable_if_t<is_same_v<remove_const_t<A>, remove_const_t<AA>>, bool>
operator ==(forward_list_iterator<A, B> x, forward_list_iterator<AA, B> y) {
  return x.node() == y.node();
}
template <class A, class B>
bool operator ==(forward_list_iterator<A, B> x, nullptr_t) {
  return x.node() == nullptr;
}

}
template <class TRAITS>
class forward_list_adaptor
  : TRAITS::header_type
  , conditional_t<TRAITS::store_node_allocator::value,
                  typename TRAITS::allocator_type, inner::empty_type> {
  using this_t = forward_list_adaptor;

  using data_t = typename TRAITS::header_type;
  using alloc_t = conditional_t<TRAITS::store_node_allocator::value,
                                typename TRAITS::allocator_type,
                                inner::empty_type>;

  template <class R>
  static auto begin(R &&r) {return re::begin(r);}
  template <class R>
  static auto end(R &&r) {return re::end(r);}
  template <class R>
  static auto rbegin(R &&r) {return re::rbegin(r);}
  template <class R>
  static auto rend(R &&r) {return re::rend(r);}
  template <class R>
  static auto size(R &&r) {return re::size(r);}
  template <class R>
  static auto empty(R &&r) {return re::empty(r);}

public:
  using pointer = alloc_ptr<typename TRAITS::allocator_type>;
  using const_pointer = alloc_cptr<typename TRAITS::allocator_type>;

  // container

  using value_type = typename TRAITS::value_type;
  using reference = value_type &;
  using const_reference = const value_type &;

  using iterator = inner::forward_list_iterator<value_type, TRAITS>;
  using const_iterator
    = inner::forward_list_iterator<const value_type, TRAITS>;
  using difference_type = typename TRAITS::difference_type;
  using size_type = typename TRAITS::size_type;

  iterator before_begin() noexcept {
    return iterator(TRAITS::before_begin_node(*this));
  }
  iterator begin() noexcept {
    return ++before_begin();
  }
  iterator end() noexcept {
    return iterator{};
  }
  const_iterator before_begin() const noexcept {
    return const_iterator(TRAITS::before_begin_node(*this));
  }
  const_iterator begin() const noexcept {
    return ++before_begin();
  }
  const_iterator end() const noexcept {
    return const_iterator{};
  }
  const_iterator cbefore_begin() const noexcept {
    return before_begin();
  }
  const_iterator cbegin() const noexcept {
    return begin();
  }
  const_iterator cend() const noexcept {
    return end();
  }

  size_type max_size() const noexcept {
    return container_regular_max_size<this_t>();
  }
  bool empty() const noexcept {
    return begin() == nullptr;
  }
  template <class Y = typename TRAITS::store_size>
  enable_if_t<Y::value, size_type> size() const noexcept {
    return TRAITS::size(static_cast<const data_t &>(*this));
  }

private:
  // inner implements

  template <class Y = typename TRAITS::store_size>
  enable_if_t<Y::value, size_type> get_size() const noexcept {
    return TRAITS::size(static_cast<const data_t &>(*this));
  }
  template <class Y = typename TRAITS::store_size>
  enable_if_t<Y::value> set_size(size_type n) noexcept {
    TRAITS::size(static_cast<data_t &>(*this), n);
  }

  template <class Y = typename TRAITS::store_size>
  enable_if_t<!Y::value, size_type> get_size() const noexcept {
    return 0;
  }
  template <class Y = typename TRAITS::store_size>
  enable_if_t<!Y::value> set_size(size_type) noexcept {}

public:
  // extensions(node operations):

  using traits = TRAITS;
  using node_pointer = typename TRAITS::node_base_pointer;

  template <class...S>
  iterator new_node(S &&...s) {
    return iterator(TRAITS::new_node(static_cast<alloc_t &>(*this),
                                     forward<S>(s)...));
  }
  iterator exchange_node_after(const_iterator prev,
                               const_iterator node) noexcept {
    const auto ret = prev.next();
    const auto next = ret.next();
    prev.next(node);
    node.next(next);
    return ret.to_mutable();
  }
  void delete_node(const_iterator it) noexcept {
    TRAITS::delete_node(static_cast<alloc_t &>(*this), it.node());
  }

  iterator link_after(const_iterator prev, const_iterator node) noexcept {
    set_size(get_size() + 1u);
    const auto next = prev.next();
    prev.next(node);
    node.next(next);
    return node.to_mutable();
  }
  iterator link_after(const_iterator prev,
                      const_iterator it, const_iterator last_it) noexcept {
    set_size(get_size() + to_unsigned(1 + distance(it, last_it)));
    const auto next = prev.next();
    prev.next(it);
    last_it.next(next);
    return last_it.to_mutable();
  }
  iterator link_front(const_iterator node) noexcept {
    return link_after(before_begin(), node);
  }
  iterator link_front(const_iterator it, const_iterator last_it) noexcept {
    set_size(get_size() + to_unsigned(1 + distance(it, last_it)));
    const auto n = before_begin().next();
    before_begin().next(it.to_mutable());
    last_it.next(n);
    return it.to_mutable();
  }
  iterator unlink_after(const_iterator prev) noexcept {
    set_size(get_size() - 1u);
    const auto next = re::next(prev).next();
    prev.next(next);
    return next.to_mutable();
  }
  iterator unlink_after(const_iterator prev, const_iterator next) noexcept {
    set_size(get_size() - (distance(prev, next) - 1));
    prev.next(next);
    return next.to_mutable();
  }
  void unlink() noexcept {
    set_size(0);
    new_data();
  }
  iterator unlink_front() noexcept {
    return unlink_after(before_begin());
  }

  template <bool Y = traits::store_node_allocator::value>
  enable_if_t<Y, iterator>
  erase_or_unlink_after(const_iterator it) noexcept {
    return erase_after(it);
  }
  template <bool Y = traits::store_node_allocator::value>
  enable_if_t<!Y, iterator>
  erase_or_unlink_after(const_iterator it) noexcept {
    return unlink_after(it);
  }

  using node_type = inner::forward_list_node_handle<traits>;
  template <class...S>
  node_type make_node(S &&...s) {
    return node_type(new_node(forward<S>(s)...).node(), get_allocator());
  }

  node_type extract_after(const_iterator ci) noexcept {
    const_iterator x = ci.next();
    unlink_after(ci);
    return node_type(x.node(), get_allocator());
  }
  iterator insert_after(const_iterator ci, node_type &&x) noexcept {
    if (!x.empty())
      return link_after(ci, iterator(x.release()));
    else
      return ci.to_mutable();
  }
  void push_front(node_type &&x) noexcept {
    if (!x.empty())
      link_front(iterator(x.release()));
  }
  node_type exchange_after(const_iterator ci, node_type &x) noexcept {
    iterator it;
    if (!x.empty())
      it = exchange_node_after(ci, iterator(x.release()));
    else {
      it = next(ci).to_mutable();
      unlink_after(ci);
    }
    return node_type(it.node(), get_allocator());
  }
  node_type exchange_after(const_iterator ci, node_type &&x) noexcept {
    return exchange_after(ci, x);
  }
  iterator replace_after(const_iterator ci, node_type &&x) noexcept {
    if (!x.empty()) {
      const iterator it(x.release());
      delete_node(exchange_node_after(ci, it));
      return it;
    }
    else {
      erase_after(ci);
      return ci.to_mutable();
    }
  }

  this_t extract_after(const_iterator ci, const_iterator ci2) noexcept {
    this_t l(get_allocator());
    l.splice_after(l.before_begin(), *this, ci, ci2);
    return l;
  }
  iterator insert_after(const_iterator ci, this_t &&l) noexcept {
    if (l.empty())
      return ci.to_mutable();
    else {
      const auto it1 = l.begin();
      auto it2 = it1;
      while (it2.next() != nullptr)
        ++it2;
      l.unlink();
      return link_after(ci, it1, it2);
    }
  }
  void push_front(this_t &&l) noexcept {
    if (!l.empty()) {
      auto it = l.begin();
      while (next(it) != l.end())
        ++it;
      link_front(l.begin(), it);
      l.unlink();
    }
  }
  this_t exchange_after(const_iterator ci, const_iterator ci2,
                        this_t &&x) noexcept {
    this_t ret = extract_after(ci, ci2);
    insert_after(ci, move(x));
    return ret;
  }
  iterator replace_after(const_iterator ci, const_iterator ci2,
                         this_t &&x) noexcept {
    erase_after(ci, ci2);
    return insert_after(ci, move(x));
  }

private:
  // inner implements (continued)

  iterator erase_after_impl(iterator prev) noexcept {
    set_size(get_size() - 1u);
    const iterator node = prev.next();
    const iterator next = node.next();
    prev.next(next);
    delete_node(node);
    return next;
  }

  template <class IITR_RANGE>
  iterator insert_range_after_impl(iterator prev, IITR_RANGE &&r) {
    const iterator next = prev.next();
    const iterator prev_bk(prev);
#ifndef RE_NOEXCEPT
    try {
#endif
      for (auto &it : iters(r)) {
        const iterator node = new_node(*it);
        set_size(get_size() + 1u);
        prev.next(node);
        prev = node;
      }
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      prev.next(next);
      erase_range_after_impl(prev_bk, next);
    }
#endif
    prev.next(next);
    return prev;
  }
  iterator erase_range_after_impl(iterator prev, iterator next) noexcept {
    for (iterator it = prev.next(); it != next;) {
      const iterator tmp = it.next();
      set_size(get_size() - 1u);
      delete_node(it);
      it = tmp;
    }
    prev.next(next);
    return next;
  }

  template <class IITR_RANGE>
  void assign_range_impl(IITR_RANGE &&r) {
    auto rr = rng(r);
    iterator it = before_begin();
    for (;;) {
      if (empty(rr)) {
        erase_range_after_impl(it, end());
        break;
      }
      if (it.next() == end()) {
        insert_range_after_impl(it, rr);
        break;
      }
      *++it = *rr.first;
      ++rr.first;
    }
  }

  template <class...S>
  void resize_impl(size_type n, const S &...s) {
    iterator it = before_begin();
    size_type c = 0;
    for (;;) {
      if (c == n) {
        erase_range_after_impl(it, end());
        return;
      }
      if (it.next() == end())
        break;
      ++c;
      ++it;
    }
    for (size_type cc = n - c; cc != 0; --cc)
      it = link_after(it, new_node(s...));
  }

  void clear_impl() {
    for_each_node(*this, next, [&](auto it) {delete_node(it);});
    new_data();
  }

  void splice_after_impl(iterator prev, this_t &l) noexcept {
    size_type old_sz = l.get_size();
    const iterator next = prev.next();
    prev.next(l.before_begin().next());
    while (prev.next() != nullptr)
      ++prev;
    prev.next(next);
    l.new_data();
    set_size(get_size() + old_sz);
  }
  void splice_after_impl(iterator prev,
                         this_t &l, iterator l_prev) noexcept {
    if (prev != next(l_prev)) {
      const iterator l_node = next(l_prev);
      const iterator l_next = l_node.next();
      l_prev.next(l_next);

      const iterator next = prev.next();
      prev.next(l_node);
      l_node.next(next);
    }
    l.set_size(l.get_size() - 1u);
    set_size(get_size() + 1u);
  }
  void splice_after_impl(iterator prev, this_t &l,
                         iterator l_prev, iterator l_next) noexcept {
    if (next(l_prev) != l_next && prev != l_prev) {
      const iterator next = prev.next();
      iterator it = l_prev.next();
      prev.next(it);
      size_type count = 1;
      while (++copy(it) != l_next) {
        ++it;
        ++count;
      }
      l.set_size(l.get_size() - count);
      set_size(get_size() + count);
      it.next(next);
      l_prev.next(l_next);
    }
  }

  friend class allocator_aware_container_ownership<this_t>;
  const alloc_t &alloc_ref() const noexcept {
    return static_cast<const alloc_t &>(*this);
  }
  alloc_t &alloc_ref() noexcept {
    return static_cast<alloc_t &>(*this);
  }
  void new_data() noexcept {
    before_begin().next(iterator{});
    set_size(0);
  }
  void delete_data() noexcept {
    for_each_node(*this, next, [&](auto it) {delete_node(it);});
  }
  void new_data(const this_t &v) {
    new_data();
    insert_range_after_impl(before_begin(), v);
  }
  void assign_data(const this_t &v) {
    assign_range_impl(v);
  }
  void new_data(this_t &&v) noexcept {
    data_t::operator =(move(static_cast<data_t &>(v)));
    v.new_data();
  }
  void new_data_individually(this_t &&v) {
    new_data();
    insert_range_after_impl(before_begin(), move_rng(v));
    v.delete_data();
    v.new_data();
  }
  void assign_data_individually(this_t &&v) {
    assign_range_impl(move_rng(v));
    v.delete_data();
    v.new_data();
  }
  void swap_data(this_t &v) noexcept {
    adl_swap(static_cast<data_t &>(*this), static_cast<data_t &>(v));
  }
  void swap_data_individually(this_t &v) {
    iterator it = before_begin();
    iterator it2 = v.before_begin();
    for (;;) {
      const iterator next_it = it.next();
      const iterator next_it2 = it2.next();
      if (next_it == end()) {
        insert_range_after_impl(it, move_rng(rng(next_it2, v.end())));
        v.erase_range_after_impl(it2, v.end());
        return;
      }
      if (next_it2 == v.end()) {
        v.insert_range_after_impl(it2, move_rng(rng(next_it, end())));
        erase_range_after_impl(it, end());
        return;
      }
      adl_swap(*next_it, *next_it2);
      it = next_it;
      it2 = next_it2;
    }
  }

public:
  // container (continued)

  forward_list_adaptor() noexcept(!TRAITS::store_node_allocator::value
                                  || noexcept(alloc_t{})) {
    new_data();
  }
  ~forward_list_adaptor() {}
  forward_list_adaptor(const this_t &) = delete;
  this_t &operator =(const this_t &x) = delete;
  forward_list_adaptor(this_t &&x) noexcept : alloc_t(move(x.alloc_ref())) {
    new_data(move(x));
  }
  this_t &operator =(this_t &&x) noexcept {
    if (this != addressof(x))
      new_data(move(x));
    return *this;
  }
  friend void swap(this_t &x, this_t &y) noexcept {
    x.swap_data(y);
  }

  ~forward_list_adaptor()
    requires TRAITS::store_node_allocator::value {
    delete_data();
  }
  forward_list_adaptor(const this_t &x)
    requires TRAITS::store_node_allocator::value
    : alloc_t(allocator_traits<alloc_t>
              ::select_on_container_copy_construction(x)) {
    new_data(x);
  }
  this_t &operator =(const this_t &x)
    requires TRAITS::store_node_allocator::value {
    allocator_aware_container_ownership<this_t>::copy_assign(*this, x);
    return *this;
  }
  this_t &operator =(this_t &&x)
    noexcept(alloc_move_prpg<alloc_t> || alloc_always_equal<alloc_t>)
    requires TRAITS::store_node_allocator::value {
    allocator_aware_container_ownership<this_t>::move_assign(*this, x);
    return *this;
  }
  friend void swap(this_t &x, this_t &y)
    noexcept(alloc_swap_prpg<alloc_t> || alloc_always_equal<alloc_t>)
    requires TRAITS::store_node_allocator::value {
    allocator_aware_container_ownership<this_t>::swap(x, y);
  }

  // optional container operations

  // reversible container

  // allocator-aware container

  using allocator_type = typename TRAITS::allocator_type;
  alloc_t get_allocator() const noexcept {
    return *this;
  }

  explicit forward_list_adaptor(const alloc_t &al) noexcept : alloc_t(al) {
    new_data();
  }
  forward_list_adaptor(const this_t &x, const alloc_t &al) : alloc_t(al) {
    new_data(x);
  }
  forward_list_adaptor(this_t &&x, const alloc_t &al) : alloc_t(al) {
    allocator_aware_container_ownership<this_t>::move_construct(*this, x);
  }

  // sequence container

  explicit forward_list_adaptor(size_type n, const alloc_t &al = alloc_t{})
    : alloc_t(al) {
    new_data();
    for (; n != 0; --n)
      link_front(new_node());
  }
  forward_list_adaptor(size_type n, const value_type &x,
                       const alloc_t &al = alloc_t{}) : alloc_t(al) {
    new_data();
    insert_range_after_impl(before_begin(), rng(n, ref(x)));
  }
  void assign(size_type n, const value_type &x) {
    assign_range_impl(rng(n, x));
  }

  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  forward_list_adaptor(IITR from, IITR to,
                       const alloc_t &al = alloc_t{}) : alloc_t(al) {
    new_data();
    insert_range_after_impl(before_begin(), rng(from, to));
  }
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  void assign(IITR from, IITR to) {
    assign_range_impl(rng(from, to));
  }

  forward_list_adaptor(initializer_list<value_type> l,
                       const alloc_t &al = alloc_t{}) : alloc_t(al) {
    new_data();
    insert_range_after_impl(before_begin(), l);
  }
  this_t &operator =(initializer_list<value_type> l) {
    assign_range_impl(l);
    return *this;
  }
  void assign(initializer_list<value_type> l) {
    assign_range_impl(l);
  }

  template <class...S>
  iterator emplace_after(const_iterator pos, S &&...s) {
    return link_after(pos, new_node(forward<S>(s)...));
  }
  iterator insert_after(const_iterator pos, const value_type &x) {
    return link_after(pos, new_node(x));
  }
  iterator insert_after(const_iterator pos, value_type &&x) {
    return link_after(pos, new_node(move(x)));
  }
  iterator insert_after(const_iterator pos,
                        size_type n, const value_type &x) {
    return insert_range_after_impl(pos.to_mutable(), rng(n, ref(x)));
  }
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  iterator insert_after(const_iterator pos, IITR from, IITR to) {
    return insert_range_after_impl(pos.to_mutable(), rng(from, to));
  }
  iterator insert_after(const_iterator pos,
                        initializer_list<value_type> l) {
    return insert_range_after_impl(pos.to_mutable(), l);
  }

  iterator erase_after(const_iterator pos) {
    return erase_after_impl(pos.to_mutable());
  }
  iterator erase_after(const_iterator from, const_iterator to) {
    return erase_range_after_impl(from.to_mutable(), to.to_mutable());
  }
  void clear() noexcept {
    clear_impl();
  }

  // optional sequence container operations

  reference front() {
    return *begin();
  }
  const_reference front() const {
    return *begin();
  }

  template <class...S>
  reference emplace_front(S &&...s) {
    return *link_after(before_begin(), new_node(forward<S>(s)...));
  }
  void push_front(const value_type &x) {
    link_after(before_begin(), new_node(x));
  }
  void push_front(value_type &&x) {
    link_after(before_begin(), new_node(move(x)));
  }
  void pop_front() {
    erase_after_impl(before_begin());
  }

  // specialized operations

  void resize(size_type n) {
    resize_impl(n);
  }
  void resize(size_type n, const value_type &x) {
    resize_impl(n, x);
  }

  void splice_after(const_iterator prev, this_t &l) noexcept {
    splice_after_impl(prev.to_mutable(), l);
  }
  void splice_after(const_iterator prev, this_t &&l) noexcept {
    splice_after_impl(prev.to_mutable(), l);
  }
  void splice_after(const_iterator prev,
                    this_t &l, const_iterator l_prev) noexcept {
    splice_after_impl(prev.to_mutable(), l, l_prev.to_mutable());
  }
  void splice_after(const_iterator prev,
                    this_t &&l, const_iterator i) noexcept {
    splice_after_impl(prev.to_mutable(), l, i.to_mutable());
  }
  void splice_after(const_iterator prev, this_t &l,
                    const_iterator l_prev, const_iterator l_next) noexcept {
    splice_after_impl(prev.to_mutable(), l,
                      l_prev.to_mutable(), l_next.to_mutable());
  }
  void splice_after(const_iterator prev, this_t &&l,
                    const_iterator l_prev,
                    const_iterator l_next) noexcept {
    splice_after_impl(prev.to_mutable(), l,
                      l_prev.to_mutable(), l_next.to_mutable());
  }

  void swap_after(const_iterator prev, const_iterator x_prev) noexcept {
    if (prev != x_prev) {
      if (next(prev) == x_prev) {
        const auto x = next(x_prev);
        const auto x_next = next(x);
        prev.next(x);
        x.next(x_prev);
        x_prev.next(x_next);
      }
      else if (next(x_prev) == prev) {
        const auto x = next(prev);
        const auto x_next = next(x);
        x_prev.next(x);
        x.next(prev);
        prev.next(x_next);
      }
      else {
        const auto i = next(prev);
        const auto i_next = next(i);
        const auto x = next(x_prev);
        const auto x_next = next(x);
        prev.next(x);
        x.next(i_next);
        x_prev.next(i);
        i.next(x_next);
      }
    }
  }
  void swap_after(const_iterator prev,
                  this_t &l, const_iterator x_prev) noexcept {
    if (this == addressof(l))
      swap_after(prev, x_prev);
    else {
      const auto i = next(prev);
      const auto i_next = next(i);
      const auto x = next(x_prev);
      const auto x_next = next(x);
      prev.next(x);
      x.next(i_next);
      x_prev.next(i);
      i.next(x_next);
    }
  }

  template <class UPRED>
  size_type remove_if(UPRED eq) {
    size_type ret = 0;
    iterator it = before_begin();
    iterator next;
    for (;;) {
      next = it.next();
      if (next == end())
        break;
      if (eq(*next)) {
        erase_or_unlink_after(it);
        ++ret;
      }
      else
        it = next;
    }
    return ret;
  }
  template <class X>
  size_type remove(const X &t) {
    return remove_if([&t](const value_type &x) {return x == t;});
  }

  template <class BPRED>
  void unique(BPRED eq) {
    for (iterator it = begin(); it != end();) {
      iterator next = it.next();
      for (;;) {
        if (next == end())
          return;
        if (eq(*it, *next))
          next = erase_or_unlink_after(it);
        else {
          it = next;
          break;
        }
      }
    }
  }
  void unique() {
    unique(equal_to<>());
  }

  template <class BPRED>
  void merge(this_t &l, BPRED less) {
    if (addressof(l) == this)
      return;
    iterator it = before_begin();
    iterator l_it = l.before_begin();
    if (++copy(l_it) == l.end())
      return;
    if (++copy(it) == end())
      return splice_after(it, l);
    for (;;) {
      if (less(*++copy(l_it), *++copy(it))) {
        splice_after(it, l, l_it);
        if (++copy(l_it) == l.end())
          return;
      }
      else {
        ++it;
        if (++copy(it) == end())
          return splice_after(it, l);
      }
    }
  }
  template <class BPRED>
  void merge(this_t &&l, BPRED less) {
    merge(l, less);
  }
  void merge(this_t &l) {
    merge(l, less<>{});
  }
  void merge(this_t &&l) {
    merge(l, less<>{});
  }

  void reverse() noexcept {
    iterator done{};
    for_each_node(*this, next, [&](auto it) {
      it.next(done);
      done = it;
    });
    before_begin().next(done);
  }

  template <class BPRED>
  void sort(BPRED less) {
    if (empty() || ++begin() == end())
      return;
    constexpr size_t max_depth = sizeof(ptrdiff_t) * 8;
    local_vector<this_t, max_depth> sorted; // the ith has 2 ^ i or 0 elements
    for (size_t n = max_depth; n != 0; --n)
      sorted.emplace_back(this_t(get_allocator()));
    this_t l(get_allocator());
    while (!empty()) {
      l.splice_after(l.before_begin(), *this, before_begin());
      for (this_t &x : sorted) {
        if (x.empty()) {
          x = move(l);
          break;
        }
        else {
          x.merge(l, less);
          l = move(x);
        }
      }
    }
    for (auto &x : rrng(sorted))
      merge(x, less);
  }
  void sort() {
    sort(less<>{});
  }

  template <class R>
  iterator replace_after(const_iterator ci1, const_iterator ci2, R &&r)
    requires (!is_convertible_v<R &&, this_t &&>) {
    const iterator i1 = ci1.to_mutable();
    const iterator i2 = ci2.to_mutable();
    if constexpr (is_frng<R>) {
      const auto d1 = distance(i1, i2) - 1;
      const auto d2 = ssize(r);
      if (d2 > d1) {
        auto r_it = begin(r);
        auto r_ed = end(r);
        auto it = i1;
        for (;;) {
          auto it_next = next(it);
          if (it_next == ci2)
            break;
          *it_next = *r_it;
          it = it_next;
          ++r_it;
        }
        return insert_after(it, rng(r_it, r_ed));
      }
      else {
        auto r_it = begin(r);
        auto r_ed = end(r);
        auto it = i1;
        for (;;) {
          auto it_next = next(it);
          if (r_it == r_ed)
            break;
          *it_next = *r_it;
          it = it_next;
          ++r_it;
        }
        auto ret = it;
        while (next(ret) != ci2)
          ++ret;
        erase_after(it, ci2);
        return ret;
      }
    }
    else {
      erase_after(ci1, ci2);
      return insert_after(ci1, r);
    }
  }

  // extensions

  template <class R>
  forward_list_adaptor(from_range_t, R &&r, const alloc_t &al = alloc_t{})
    requires (is_rng<R> && is_constructible_v<value_type, rng_ref<R>>)
    : alloc_t(al) {
    new_data();
    insert_range_after_impl(before_begin(), r);
  }
  template <class R, class = enable_if_t
            <!is_same_v<decay_t<R>, this_t>
             && !is_convertible_v<R &&, const alloc_t &>
             && is_rng<R> && is_constructible_v<value_type, rng_ref<R>>>>
  explicit forward_list_adaptor(R &&r) : forward_list_adaptor(r, alloc_t{}) {}
  template <class R, class = enable_if_t
            <!is_same_v<decay_t<R>, this_t>
             && is_rng<R> && is_constructible_v<value_type, rng_ref<R>>>>
  forward_list_adaptor(R &&r, const alloc_t &al) : alloc_t(al) {
    new_data();
    insert_range_after_impl(before_begin(), r);
  }
  template <class IITR_RANGE>
  enable_if_t<!is_same_v<decay_t<IITR_RANGE>, this_t>
              && is_rng<IITR_RANGE>
              && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
              && is_assignable_v<value_type &, rng_ref<IITR_RANGE>>, this_t &>
  operator =(IITR_RANGE &&r) {
    assign_range_impl(r);
    return *this;
  }
  template <class IITR_RANGE>
  void assign(IITR_RANGE &&r) {
    assign_range_impl(r);
  }
  template <class IITR_RANGE>
  void assign_range(IITR_RANGE &&r) {
    assign_range_impl(r);
  }

  template <class IITR_RANGE>
  enable_if_t<!is_convertible_v<IITR_RANGE &&, value_type &&>
              && !is_convertible_v<IITR_RANGE &&, const value_type &>
              && !is_convertible_v<IITR_RANGE &&, node_type &&>
              && !is_convertible_v<IITR_RANGE &&, this_t &&>,
              iterator>
  insert_after(const_iterator pos, IITR_RANGE &&r) {
    return insert_range_after_impl(pos.to_mutable(), r);
  }
  template <class IITR_RANGE>
  iterator insert_range_after(const_iterator pos, IITR_RANGE &&r) {
    return insert_range_after_impl(pos.to_mutable(), r);
  }

  template <class IITR_RANGE>
  enable_if_t<!is_convertible_v<IITR_RANGE &&, value_type &&>
              && !is_convertible_v<IITR_RANGE &&, const value_type &>
              && !is_convertible_v<IITR_RANGE &&, node_type &&>
              && !is_convertible_v<IITR_RANGE &&, this_t &&>>
  push_front(IITR_RANGE &&r) {
    insert_range_after_impl(before_begin(), r);
  }
  template <class IITR_RANGE>
  void prepend_range(IITR_RANGE &&r) {
    insert_range_after_impl(before_begin(), r);
  }
  void pop_front(size_type n) {
    for (; n != 0; --n)
      pop_front();
  }

  this_t &prepend() {
    return *this;
  }
  template <class X, class...S>
  this_t &prepend(X &&x, S &&...s) {
    prepend(forward<S>(s)...);
    push_front(forward<X>(x));
    return *this;
  }
};
template <class TRAITS>
bool operator ==(const forward_list_adaptor<TRAITS> &x,
                 const forward_list_adaptor<TRAITS> &y) {
  return equal(x, y);
}
template <class TRAITS>
synth_3way_result<typename TRAITS::value_type>
operator <=>(const forward_list_adaptor<TRAITS> &x,
             const forward_list_adaptor<TRAITS> &y) {
  return lexicographical_synth_3way(x, y);
}

}

// list
namespace re {

namespace inner {

template <class TRAITS>
class list_node_handle : node_handle<TRAITS> {
  using base_t = node_handle<TRAITS>;
  using this_t = list_node_handle;

public:
  using base_t::allocator_type;

  list_node_handle() noexcept = default;
  list_node_handle(const this_t &) = delete;
  list_node_handle &operator =(const this_t &) = delete;
  list_node_handle(this_t &&) noexcept = default;
  list_node_handle &operator =(this_t &&) = default;
  friend void swap(this_t &x, this_t &y)
    noexcept(is_nothrow_swappable_v<base_t>) {
    adl_swap(static_cast<base_t &>(x), static_cast<base_t &>(y));
  }

  explicit list_node_handle(typename base_t::node_pointer p,
                            const typename base_t::alloc_t &al)
    : base_t(p, al) {}

  using base_t::get_allocator;
  using base_t::empty;
  using base_t::operator bool;
  using base_t::get;
  using base_t::release;
  using base_t::operator *;
};

}

template <size_t ID = 0, class VOID_PTR = void *>
struct join_list {
  pointer_rebind_t<VOID_PTR, join_list> prev;
  pointer_rebind_t<VOID_PTR, join_list> next;
};
template <class T, class AL = default_allocator<T>>
struct list_node : join_list<0, alloc_void_ptr<AL>> {
  alignas(T) byte data[sizeof(T)];

  T &operator *() const {
    return *reinterpret_cast<T *>(addressof(data));
  }
  T *operator ->() const {
    return reinterpret_cast<T *>(addressof(data));
  }
};
namespace inner {

template <class, class, bool>
struct list_header_data;
template <class NODE_BASE_TYPE, class SIZE_TYPE>
struct list_header_data<NODE_BASE_TYPE, SIZE_TYPE, true> {
  mutable NODE_BASE_TYPE ed;
};
template <class NODE_BASE_TYPE, class SIZE_TYPE>
struct list_header_data<NODE_BASE_TYPE, SIZE_TYPE, false> {
  mutable NODE_BASE_TYPE ed;
  SIZE_TYPE sz;
};

}

template <class NODE_T, size_t ID = 0,
          bool STORE_SIZE = true, bool STORE_NODE_ALLOCATOR = false,
          class AL = default_allocator<NODE_T>>
struct list_traits {
  using value_type = alloc_vt<AL>;
  using allocator_type = AL;
  using node_type = NODE_T;
  using node_pointer = alloc_rebind_ptr<AL, node_type>;
  using node_base_type = join_list<ID, alloc_void_ptr<AL>>;
  using node_base_pointer = alloc_rebind_ptr<AL, node_base_type>;
  using difference_type = alloc_dft<AL>;
  using size_type = alloc_szt<AL>;

  using id = size_constant<ID>;
  using store_node_allocator = bool_constant<STORE_NODE_ALLOCATOR>;
  using store_allocator = bool_constant<STORE_NODE_ALLOCATOR>;
  using store_size = bool_constant<STORE_SIZE>;

  static node_base_pointer prev(node_base_pointer p) {
    return p->prev;
  }
  static void prev(node_base_pointer p, node_base_pointer prev_p) {
    p->prev = prev_p;
  }

  static node_base_pointer next(node_base_pointer p) {
    return p->next;
  }
  static void next(node_base_pointer p, node_base_pointer next_p) {
    p->next = next_p;
  }

  template <class VT = value_type>
  static enable_if_t<!is_same_v<VT, node_type>, value_type *>
  data(node_base_pointer p) {
    return reinterpret_cast<value_type *>
      (addressof(static_cast<node_pointer>(p)->data));
  }
  template <class VT = value_type>
  static enable_if_t<is_same_v<VT, node_type>, value_type *>
  data(node_base_pointer p) {
    return to_address(static_cast<node_pointer>(p));
  }

  using header_type
    = inner::list_header_data<node_base_type, size_type, !store_size::value>;
  static node_base_pointer end_node(const header_type &h) {
    return pointer_traits<node_base_pointer>::pointer_to(h.ed);
  }
  template <bool Y = store_size::value, class = enable_if_t<Y>>
  static size_type size(const header_type &h) {
    return h.sz;
  }
  template <bool Y = store_size::value, class = enable_if_t<Y>>
  static void size(header_type &h, size_type n) {
    h.sz = n;
  }

  template <class...S, class VT = value_type>
  static enable_if_t<!is_same_v<VT, node_type>, node_base_pointer>
  new_node(AL &al, S &&...s) {
    return allocator_wrapper<AL>(al)
      .template new_node<node_type>(forward<S>(s)...);
  }
  template <class VT = value_type>
  static enable_if_t<!is_same_v<VT, node_type>>
  delete_node(AL &al, node_base_pointer p) noexcept {
    allocator_wrapper<AL>(al).delete_node(static_cast<node_pointer>(p));
  }

  template <class...S, class VT = value_type>
  static enable_if_t<is_same_v<VT, node_type>, node_base_pointer>
  new_node(AL &al, S &&...s) {
    return static_cast<node_base_pointer>
      (allocator_wrapper<AL>(al).new_1(forward<S>(s)...));
  }
  template <class VT = value_type>
  static enable_if_t<is_same_v<VT, node_type>>
  delete_node(AL &al, node_base_pointer p) noexcept {
    allocator_wrapper<AL>(al).delete_1(static_cast<node_pointer>(p));
  }
};
template <class>
class list_adaptor;
template <class T, class AL>
struct lstt : list_traits<list_node<T, AL>, 0, 1, 1, AL> {
  static_assert(is_same_v<T, alloc_vt<AL>>);
};
template <class T, class AL>
struct bdlstt : list_traits<list_node<T, AL>, 0, 0, 1, AL> {
  static_assert(is_same_v<T, alloc_vt<AL>>);
};
template <class T, class AL = default_allocator<T>>
using list = list_adaptor<lstt<T, AL>>;
template <class T, class AL = default_allocator<T>>
using bidirectional_list = list_adaptor<bdlstt<T, AL>>;

template <class>
class list_adaptor;
namespace inner {

template <class T, class TRAITS>
class list_iterator {
  static_assert(is_same_v<remove_const_t<T>, typename TRAITS::value_type>);

  template <class>
  friend class re::list_adaptor;

  using this_t = list_iterator;

public:
  using node_pointer = typename TRAITS::node_base_pointer;
private:
  node_pointer p{};

public:
  using value_type = remove_const_t<T>;
  using pointer = T *;
  using reference = T &;
  using difference_type = typename TRAITS::difference_type;
  using iterator_category = bidirectional_iterator_tag;

  list_iterator() = default;
  list_iterator(const this_t &) = default;
  list_iterator &operator =(const this_t &) = default;
  list_iterator(this_t &&) = default;
  list_iterator &operator =(this_t &&) = default;
  friend void swap(this_t &x, this_t &y) noexcept {
    adl_swap(x.p, y.p);
  }

  template <class TT = T, class = enable_if_t<is_const_v<TT>>>
  list_iterator(list_iterator<remove_const_t<TT>, TRAITS> it) : p(it.node()) {}
  template <class TT = T, class = enable_if_t<is_const_v<TT>>>
  this_t &operator =(list_iterator<remove_const_t<TT>, TRAITS> it) {
    p = it.node();
    return *this;
  }

  explicit list_iterator(node_pointer pp) : p(pp) {}
  node_pointer node() const {
    return p;
  }
  auto to_mutable() const requires is_const_v<T> {
    return list_iterator<remove_const_t<T>, TRAITS>(p);
  }

private:
  this_t prev() const {
    return this_t(TRAITS::prev(p));
  }
  void prev(this_t it) const {
    TRAITS::prev(p, it.node());
  }
  this_t next() const {
    return this_t(TRAITS::next(p));
  }
  void next(this_t it) const {
    TRAITS::next(p, it.node());
  }

public:
  reference operator *() const {
    return *TRAITS::data(p);
  }
  pointer operator ->() const {
    return TRAITS::data(p);
  }

  this_t &operator ++() {
    p = TRAITS::next(p);
    return *this;
  }
  this_t operator ++(int) {
    return iter_post_increment(*this);
  }

  this_t &operator --() {
    p = TRAITS::prev(p);
    return *this;
  }
  this_t operator --(int) {
    return iter_post_decrement(*this);
  }
};
template <class A, class AA, class B>
enable_if_t<is_same_v<remove_const_t<A>, remove_const_t<AA>>, bool>
operator ==(list_iterator<A, B> x, list_iterator<AA, B> y) {
  return x.node() == y.node();
}
template <class A, class B>
bool operator ==(list_iterator<A, B> x, nullptr_t) {
  return x.node() == nullptr;
}

}
template <class TRAITS>
class list_adaptor
  : TRAITS::header_type
  , conditional_t<TRAITS::store_node_allocator::value,
                  typename TRAITS::allocator_type, inner::empty_type> {
  using this_t = list_adaptor;

  using data_t = typename TRAITS::header_type;
  using alloc_t = conditional_t<TRAITS::store_node_allocator::value,
                                typename TRAITS::allocator_type,
                                inner::empty_type>;

  template <class R>
  static auto begin(R &&r) {return re::begin(r);}
  template <class R>
  static auto end(R &&r) {return re::end(r);}
  template <class R>
  static auto rbegin(R &&r) {return re::rbegin(r);}
  template <class R>
  static auto rend(R &&r) {return re::rend(r);}
  template <class R, enable_if_t<is_rng<R>>>
  static auto size(R &&r) {return re::size(r);}
  template <class R>
  static auto empty(R &&r) {return re::empty(r);}

public:
  using pointer = alloc_ptr<typename TRAITS::allocator_type>;
  using const_pointer = alloc_cptr<typename TRAITS::allocator_type>;

  // container

  using value_type = typename TRAITS::value_type;
  using reference = value_type &;
  using const_reference = const value_type &;

  using iterator = inner::list_iterator<value_type, TRAITS>;
  using const_iterator = inner::list_iterator<const value_type, TRAITS>;
  using difference_type = typename TRAITS::difference_type;
  using size_type = typename TRAITS::size_type;

  iterator begin() noexcept {
    return ++end();
  }
  iterator end() noexcept {
    return iterator(TRAITS::end_node(*this));
  }
  const_iterator begin() const noexcept {
    return ++end();
  }
  const_iterator end() const noexcept {
    return iterator(TRAITS::end_node(*this));
  }
  const_iterator cbegin() const noexcept {
    return begin();
  }
  const_iterator cend() const noexcept {
    return end();
  }

  size_type max_size() const noexcept {
    return container_regular_max_size<this_t>();
  }
  template <bool Y = TRAITS::store_size::value, class = enable_if_t<Y>>
  size_type size() const noexcept {
    return TRAITS::size(*this);
  }
  template <bool Y = TRAITS::store_size::value>
  enable_if_t<Y, bool> empty() const noexcept {
    return size() == 0u;
  }
  template <bool Y = TRAITS::store_size::value>
  enable_if_t<!Y, bool> empty() const noexcept {
    return begin() == end();
  }

private:
  // inner implements

  template <bool Y = !TRAITS::store_size::value>
  enable_if_t<Y> size(size_type) {}
  template <bool Y = !TRAITS::store_size::value>
  enable_if_t<Y> size_plus(size_type = 1) {}
  template <bool Y = !TRAITS::store_size::value>
  enable_if_t<Y> size_minus(size_type = 1) {}
  template <bool Y = !TRAITS::store_size::value>
  enable_if_t<Y> size_plus(const this_t &) {}
  template <bool Y = !TRAITS::store_size::value>
  enable_if_t<Y> size_minus(const this_t &) {}
  template <bool Y = !TRAITS::store_size::value>
  enable_if_t<Y, size_type>
  size_minus(const_iterator, const_iterator) {
    return 0;
  }

  template <bool Y = !TRAITS::store_size::value>
  enable_if_t<!Y> size(size_type n) {
    TRAITS::size(*this, n);
  }
  template <bool Y = !TRAITS::store_size::value>
  enable_if_t<!Y> size_plus(size_type n = 1) {
    TRAITS::size(*this, TRAITS::size(*this) + n);
  }
  template <bool Y = !TRAITS::store_size::value>
  enable_if_t<!Y> size_minus(size_type n = 1) {
    TRAITS::size(*this, TRAITS::size(*this) - n);
  }
  template <bool Y = !TRAITS::store_size::value>
  enable_if_t<!Y> size_plus(const this_t &x) {
    TRAITS::size(*this, TRAITS::size(*this) + TRAITS::size(x));
  }
  template <bool Y = !TRAITS::store_size::value>
  enable_if_t<!Y> size_minus(const this_t &x) {
    TRAITS::size(*this, TRAITS::size(*this) - TRAITS::size(x));
  }
  template <bool Y = !TRAITS::store_size::value>
  enable_if_t<!Y, size_type>
  size_minus(const_iterator from, const_iterator to) {
    const size_type n = distance(from, to);
    size_minus(n);
    return n;
  }

public:
  // extensions(node operations):

  using traits = TRAITS;
  using node_pointer = typename TRAITS::node_base_pointer;

  template <class...S>
  iterator new_node(S &&...s) {
    return iterator(TRAITS::new_node
                    (static_cast<alloc_t &>(*this), forward<S>(s)...));
  }
  void delete_node(const_iterator it) noexcept {
    TRAITS::delete_node(static_cast<alloc_t &>(*this), it.node());
  }
  iterator exchange_node(const_iterator i, const_iterator j) {
    j.next(i.next());
    j.next().prev(j);
    j.prev(i.prev());
    j.prev().next(j);
    return i.to_mutable();
  }

  iterator link(const_iterator next, const_iterator node) noexcept {
    const auto prev = next.prev();
    node.next(next);
    node.prev(prev);
    prev.next(node);
    next.prev(node);
    size_plus();
    return node.to_mutable();
  }
  iterator link(const_iterator next,
                const_iterator first_it, const_iterator last_it) noexcept {
    const auto prev = next.prev();

    prev.next(first_it);
    first_it.prev(prev);

    last_it.next(next);
    next.prev(last_it);

    size_plus(1 + distance(first_it, last_it));

    return first_it.to_mutable();
  }
  iterator link_front(const_iterator node) noexcept {
    return link(begin(), node);
  }
  iterator link_front(const_iterator it, const_iterator last_it) noexcept {
    return link(begin(), it, last_it);
  }
  iterator link_back(const_iterator node) noexcept {
    return link(end(), node);
  }
  iterator link_back(const_iterator it, const_iterator last_it) noexcept {
    return link(end(), it, last_it);
  }
  iterator unlink(const_iterator node) noexcept {
    const auto prev = node.prev();
    const auto next = node.next();
    prev.next(next);
    next.prev(prev);
    size_minus();
    return next.to_mutable();
  }
  iterator unlink(const_iterator from, const_iterator to) noexcept {
    const auto prev = from.prev();
    prev.next(to);
    to.prev(prev);
    size_minus(from, to);
    return to.to_mutable();
  }
  void unlink() noexcept {
    new_data();
  }
  iterator unlink_back() noexcept {
    return unlink(prev(end()));
  }
  iterator unlink_front() noexcept {
    return unlink(begin());
  }

  template <bool Y = traits::store_node_allocator::value>
  enable_if_t<Y, iterator> erase_or_unlink(const_iterator it) noexcept {
    return erase(it);
  }
  template <bool Y = traits::store_node_allocator::value>
  enable_if_t<!Y, iterator> erase_or_unlink(const_iterator it) noexcept {
    return unlink(it);
  }

private:
  // inner implements (continued)

  iterator erase_impl(iterator node) noexcept {
    const iterator ret = unlink(node);
    delete_node(node);
    return ret;
  }

  template <class IITR_RANGE>
  iterator insert_range_impl(iterator next, IITR_RANGE &&r) {
    iterator prev = next.prev();
    const iterator prev_bk = prev;
#ifndef RE_NOEXCEPT
    try {
#endif
      for (auto &it : iters(r)) {
        const iterator tmp = new_node(*it);
        size_plus();
        prev.next(tmp);
        tmp.prev(prev);
        prev = tmp;
      }
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      while (prev != prev_bk) {
        const iterator tmp = prev.prev();
        delete_node(prev);
        size_minus();
        prev = tmp;
      }
      prev_bk.next(next);
      throw;
    }
#endif
    prev.next(next);
    next.prev(prev);
    return prev_bk.next();
  }
  iterator erase_range_impl(iterator from, iterator to) noexcept {
    const iterator prev = from.prev();
    while (from != to) {
      const iterator tmp = from.next();
      delete_node(from);
      size_minus();
      from = tmp;
    }
    prev.next(to);
    to.prev(prev);
    return to;
  }

  template <class IITR_RANGE>
  void assign_range_impl(IITR_RANGE &&r) {
    auto rr = rng(r);
    iterator it = begin();
    for (;;) {
      if (empty(rr)) {
        erase_range_impl(it, end());
        return;
      }
      if (it == end()) {
        insert_range_impl(end(), rr);
        return;
      }
      *it = *rr.first;
      ++it;
      ++rr.first;
    }
  }

  template <class...S, bool Y = !TRAITS::store_size::value>
  enable_if_t<Y> resize_impl(size_type n, const S &...s) {
    const size_type sz = distance(begin(), end());
    if (n < sz) {
      auto last = --end();
      for (auto c = sz - n; c != 0; --c) {
        const iterator tmp = last.prev();
        delete_node(last);
        last = tmp;
      }
      last.next(end());
      end().prev(last);
    }
    else if (n > sz) {
      auto last = --end();
      const auto guard = exit_fn([&]() {
        last.next(end());
        end().prev(last);
      });
      for (n -= sz; n != 0; --n) {
        const auto tmp = new_node(s...);
        last.next(tmp);
        tmp.prev(last);
        last = tmp;
      }
    }
  }
  template <class...S, bool Y = !TRAITS::store_size::value>
  enable_if_t<!Y> resize_impl(size_type n, const S &...s) {
    if (n < size()) {
      auto last = --end();
      do {
        const iterator tmp = last.prev();
        delete_node(last);
        size_minus();
        last = tmp;
      } while (size() != n);
      last.next(end());
      end().prev(last);
    }
    else if (n > size()) {
      auto last = --end();
      const auto guard = exit_fn([&]() {
        last.next(end());
        end().prev(last);
      });
      for (n -= size(); n != 0; --n) {
        const auto tmp = new_node(s...);
        size_plus();
        last.next(tmp);
        tmp.prev(last);
        last = tmp;
      }
    }
  }

  void clear_impl() noexcept {
    for_each_node(*this, next, [&](iterator it) {delete_node(it);});
    new_data();
  }

  void splice_impl(iterator next, this_t &l) noexcept {
    if (!l.empty()) {
      const iterator prev = next.prev();
      const iterator l_first = l.begin();
      const iterator l_last = --l.end();

      prev.next(l_first);
      l_first.prev(prev);
      l_last.next(next);
      next.prev(l_last);
      size_plus(l);

      l.new_data();
    }
  }
  void splice_impl(iterator next, this_t &l, iterator i) noexcept {
    if (next != i) {
      const iterator i_prev = i.prev();
      const iterator i_next = i.next();
      i_prev.next(i_next);
      i_next.prev(i_prev);
      l.size_minus();

      const iterator prev = next.prev();
      prev.next(i);
      i.prev(prev);
      i.next(next);
      next.prev(i);
      size_plus();
    }
  }
  void splice_impl(iterator next, this_t &l,
                   iterator from, iterator to) noexcept {
    if (from != to) {
      if (addressof(l) != this)
        size_plus(l.size_minus(from, to));

      const iterator l_prev = from.prev();
      const iterator l_first = from;
      const iterator l_last = to.prev();
      const iterator l_next = to;
      l_prev.next(l_next);
      l_next.prev(l_prev);

      const iterator prev = next.prev();
      prev.next(l_first);
      l_first.prev(prev);
      l_last.next(next);
      next.prev(l_last);
    }
  }

  friend class allocator_aware_container_ownership<this_t>;
  const alloc_t &alloc_ref() const noexcept {
    return static_cast<const alloc_t &>(*this);
  }
  alloc_t &alloc_ref() noexcept {
    return static_cast<alloc_t &>(*this);
  }
  void new_data() noexcept {
    end().prev(end());
    end().next(end());
    size(0);
  }
  void delete_data() noexcept {
    for_each_node(*this, next, [&](auto it) {delete_node(it);});
  }
  void new_data(const this_t &v) {
    new_data();
    insert_range_impl(end(), v);
  }
  void assign_data(const this_t &v) {
    assign_range_impl(v);
  }
  void new_data(this_t &&v) noexcept {
    if (v.empty())
      new_data();
    else {
      data_t::operator =(static_cast<data_t &&>(v));
      end().next().prev(end());
      end().prev().next(end());
      v.new_data();
    }
  }
  void new_data_individually(this_t &&v) {
    new_data();
    insert_range_impl(end(), move_rng(v));
    v.delete_data();
    v.new_data();
  }
  void assign_data_individually(this_t &&v) {
    assign_range_impl(move_rng(v));
    v.delete_data();
    v.new_data();
  }
  void swap_data(this_t &v) noexcept {
    if (!empty()) {
      if (!v.empty()) {
        adl_swap(static_cast<data_t &>(*this), static_cast<data_t &>(v));
        end().next().prev(end());
        end().prev().next(end());
        v.end().next().prev(v.end());
        v.end().prev().next(v.end());
      }
      else {
        static_cast<data_t &>(v) = move(static_cast<data_t &>(*this));
        v.end().next().prev(v.end());
        v.end().prev().next(v.end());
        new_data();
      }
    }
    else {
      if (!v.empty()) {
        static_cast<data_t &>(*this) = static_cast<data_t &&>(v);
        end().next().prev(end());
        end().prev().next(end());
        v.new_data();
      }
    }
  }
  void swap_data_individually(this_t &v) {
    const auto ed = end();
    const auto ed2 = v.end();
    auto it = begin();
    auto it2 = v.begin();
    for (;;) {
      if (it == ed) {
        insert_range_impl(it, move_rng(rng(it2, ed2)));
        v.erase_range_impl(it2, ed2);
        return;
      }
      if (it2 == ed2) {
        v.insert_range_impl(it2, move_rng(rng(it, ed)));
        erase_range_impl(it, ed);
        return;
      }
      adl_swap(*it, *it2);
      ++it;
      ++it2;
    }
  }

  template <bool Y = TRAITS::store_node_allocator::value>
  enable_if_t<Y> destruct_impl() {
    delete_data();
  }
  template <bool Y = TRAITS::store_node_allocator::value>
  enable_if_t<Y> copy_construct_impl(const this_t &x) {
    new_data(x);
  }
  template <bool Y = TRAITS::store_node_allocator::value>
  enable_if_t<Y> copy_assign_impl(const this_t &x) {
    allocator_aware_container_ownership<this_t>::copy_assign(*this, x);
  }
  template <bool Y = TRAITS::store_node_allocator::value>
  enable_if_t<Y> move_construct_impl(this_t &x) {
    new_data(move(x));
  }
  template <bool Y = TRAITS::store_node_allocator::value>
  enable_if_t<Y> move_assign_impl(this_t &x) {
    allocator_aware_container_ownership<this_t>::move_assign(*this, x);
  }
  template <bool Y = TRAITS::store_node_allocator::value>
  enable_if_t<Y> swap_impl(this_t &x) {
    allocator_aware_container_ownership<this_t>::swap(*this, x);
  }

  template <bool Y = TRAITS::store_node_allocator::value>
  enable_if_t<!Y> destruct_impl() {}
  template <bool Y = TRAITS::store_node_allocator::value>
  enable_if_t<!Y> copy_construct_impl(const this_t &x) {
    static_assert(Y);
  }
  template <bool Y = TRAITS::store_node_allocator::value>
  enable_if_t<!Y> copy_assign_impl(const this_t &x) {
    static_assert(Y);
  }
  template <bool Y = TRAITS::store_node_allocator::value>
  enable_if_t<!Y> move_construct_impl(this_t &x) {
    new_data(move(x));
  }
  template <bool Y = TRAITS::store_node_allocator::value>
  enable_if_t<!Y> move_assign_impl(this_t &x) {
    if (this != addressof(x))
      new_data(move(x));
  }
  template <bool Y = TRAITS::store_node_allocator::value>
  enable_if_t<!Y> swap_impl(this_t &x) noexcept {
    swap_data(x);
  }

public:
  // container (continued)

  list_adaptor()
    noexcept(!TRAITS::store_node_allocator::value || noexcept(alloc_t{})) {
    new_data();
  }
  ~list_adaptor() {}
  list_adaptor(const this_t &) = delete;
  this_t &operator =(const this_t &) = delete;
  list_adaptor(this_t &&x) noexcept : alloc_t(move(x.alloc_ref())) {
    new_data(move(x));
  }
  this_t &operator =(this_t &&x) noexcept {
    if (this != addressof(x))
      new_data(move(x));
    return *this;
  }
  friend void swap(this_t &x, this_t &y) noexcept {
    x.swap_data(y);
  }

  ~list_adaptor()
    requires TRAITS::store_node_allocator::value {
    delete_data();
  }
  list_adaptor(const this_t &x)
    requires TRAITS::store_node_allocator::value
    : alloc_t(allocator_traits<alloc_t>
              ::select_on_container_copy_construction(x)) {
    new_data(x);
  }
  this_t &operator =(const this_t &x)
    requires TRAITS::store_node_allocator::value {
    allocator_aware_container_ownership<this_t>::copy_assign(*this, x);
    return *this;
  }
  this_t &operator =(this_t &&x)
    noexcept(alloc_move_prpg<alloc_t> || alloc_always_equal<alloc_t>)
    requires TRAITS::store_node_allocator::value {
    allocator_aware_container_ownership<this_t>::move_assign(*this, x);
    return *this;
  }
  friend void swap(this_t &x, this_t &y)
    noexcept(alloc_swap_prpg<alloc_t> || alloc_always_equal<alloc_t>)
    requires TRAITS::store_node_allocator::value {
    allocator_aware_container_ownership<this_t>::swap(x, y);
  }

  // optional container operations

  // reversible container

  using reverse_iterator = re::reverse_iterator<iterator>;
  using const_reverse_iterator = re::reverse_iterator<const_iterator>;

  reverse_iterator rbegin() noexcept {
    return reverse_iterator(end());
  }
  reverse_iterator rend() noexcept {
    return reverse_iterator(begin());
  }
  const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator(begin());
  }
  const_reverse_iterator crbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  const_reverse_iterator crend() const noexcept {
    return const_reverse_iterator(begin());
  }

  // allocator-aware container

  using allocator_type = typename TRAITS::allocator_type;
  alloc_t get_allocator() const noexcept {
    return static_cast<const alloc_t &>(*this);
  }

  explicit list_adaptor(const alloc_t &al) noexcept : alloc_t(al) {
    new_data();
  }
  list_adaptor(const this_t &x, const alloc_t &al) : alloc_t(al) {
    new_data(x);
  }
  list_adaptor(this_t &&x, const alloc_t &al) : alloc_t(al) {
    allocator_aware_container_ownership<this_t>::move_construct(*this, x);
  }

  // sequence container

  explicit list_adaptor(size_type n,
                        const alloc_t &al = alloc_t{}) : alloc_t(al) {
    new_data();
    for (; n != 0; --n)
      link(end(), new_node());
  }
  list_adaptor(size_type n, const value_type &x,
               const alloc_t &al = alloc_t{}) : alloc_t(al) {
    new_data();
    insert_range_impl(end(), rng(n, ref(x)));
  }
  void assign(size_type n, const value_type &x) {
    assign_range_impl(rng(n, x));
  }

  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  list_adaptor(IITR from, IITR to,
               const alloc_t &al = alloc_t{}) : alloc_t(al) {
    new_data();
    insert_range_impl(end(), rng(from, to));
  }
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  void assign(IITR from, IITR to) {
    assign_range_impl(rng(from, to));
  }

  list_adaptor(initializer_list<value_type> l,
               const alloc_t &al = alloc_t{}) : alloc_t(al) {
    new_data();
    insert_range_impl(end(), l);
  }
  this_t &operator =(initializer_list<value_type> l) {
    assign_range_impl(l);
    return *this;
  }
  void assign(initializer_list<value_type> l) {
    assign_range_impl(l);
  }

  template <class...S>
  iterator emplace(const_iterator pos, S &&...s) {
    return link(pos, new_node(forward<S>(s)...));
  }
  iterator insert(const_iterator pos, const value_type &x) {
    return link(pos, new_node(x));
  }
  template <bool Y = TRAITS::store_node_allocator::value,
            class = enable_if_t<Y>>
  iterator insert(const_iterator pos, value_type &&x) {
    return link(pos, new_node(move(x)));
  }
  iterator insert(const_iterator pos, size_type n, const value_type &x) {
    return insert_range_impl(pos.to_mutable(), rng(n, ref(x)));
  }
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  iterator insert(const_iterator pos, IITR from, IITR to) {
    return insert_range_impl(pos.to_mutable(), rng(from, to));
  }
  iterator insert(const_iterator pos, initializer_list<value_type> l) {
    return insert_range_impl(pos.to_mutable(), l);
  }

  iterator erase(const_iterator pos) {
    return erase_impl(pos.to_mutable());
  }
  iterator erase(const_iterator from, const_iterator to) {
    return erase_range_impl(from.to_mutable(), to.to_mutable());
  }
  void clear() noexcept {
    clear_impl();
  }

  // optional sequence container operations

  reference front() {
    return *begin();
  }
  reference back() {
    return *--end();
  }
  const_reference front() const {
    return *begin();
  }
  const_reference back() const {
    return *--end();
  }

  template <class...S>
  reference emplace_back(S &&...s) {
    return *link(end(), new_node(forward<S>(s)...));
  }
  void push_back(const value_type &x) {
    link(end(), new_node(x));
  }
  void push_back(value_type &&x) {
    link(end(), new_node(move(x)));
  }
  void pop_back() {
    erase_impl(--end());
  }

  template <class...S>
  reference emplace_front(S &&...s) {
    return *link(begin(), new_node(forward<S>(s)...));
  }
  void push_front(const value_type &x) {
    link(begin(), new_node(x));
  }
  void push_front(value_type &&x) {
    link(begin(), new_node(move(x)));
  }
  void pop_front() {
    erase_impl(begin());
  }

  // specialized operations

  void resize(size_type n) {
    resize_impl(n);
  }
  void resize(size_type n, const value_type &x) {
    resize_impl(n, x);
  }

  void splice(const_iterator next, this_t &l) noexcept {
    splice_impl(next.to_mutable(), l);
  }
  void splice(const_iterator next, this_t &&l) noexcept {
    splice_impl(next.to_mutable(), l);
  }
  void splice(const_iterator next,
              this_t &l, const_iterator i) noexcept {
    splice_impl(next.to_mutable(), l, i.to_mutable());
  }
  void splice(const_iterator next, this_t &&l, const_iterator i) noexcept {
    splice_impl(next.to_mutable(), l, i.to_mutable());
  }
  void splice(const_iterator next, this_t &l,
              const_iterator from, const_iterator to) noexcept {
    splice_impl(next.to_mutable(), l, from.to_mutable(), to.to_mutable());
  }
  void splice(const_iterator next, this_t &&l,
              const_iterator from, const_iterator to) noexcept {
    splice_impl(next.to_mutable(), l, from.to_mutable(), to.to_mutable());
  }

  void swap(const_iterator x, const_iterator y) noexcept {
    if (x != y) {
      if (next(x) == y) {
        const auto prev = re::prev(x);
        const auto next = re::next(y);
        prev.next(y);
        y.prev(prev);
        y.next(x);
        x.prev(y);
        x.next(next);
        next.prev(x);
      }
      else if (next(y) == x) {
        const auto prev = re::prev(y);
        const auto next = re::next(x);
        prev.next(x);
        x.prev(prev);
        x.next(y);
        y.prev(x);
        y.next(next);
        next.prev(y);
      }
      else {
        const auto x_prev = prev(x);
        const auto x_next = next(x);
        const auto y_prev = prev(y);
        const auto y_next = next(y);

        x_prev.next(y);
        y.prev(x_prev);
        y.next(x_next);
        x_next.prev(y);

        y_prev.next(x);
        x.prev(y_prev);
        x.next(y_next);
        y_next.prev(x);
      }
    }
  }
  void swap(const_iterator x, this_t &l, const_iterator y) noexcept {
    if (this == addressof(l))
      swap(x, y);
    else {
      const auto x_prev = prev(x);
      const auto x_next = next(x);
      const auto y_prev = prev(y);
      const auto y_next = next(y);

      x_prev.next(y);
      y.prev(x_prev);
      y.next(x_next);
      x_next.prev(y);

      y_prev.next(x);
      x.prev(y_prev);
      x.next(y_next);
      y_next.prev(x);
    }
  }

  template <class UPRED>
  size_type remove_if(UPRED eq) {
    size_type ret = 0;
    for (iterator it = begin(); it != end();) {
      if (eq(*it)) {
        it = erase_or_unlink(it);
        ++ret;
      }
      else
        ++it;
    }
    return ret;
  }
  template <class X>
  size_type remove(const X &x) {
    return remove_if([&x](const value_type &y) {return x == y;});
  }

  template <class BPRED>
  void unique(BPRED eq) {
    list_unique(*this, eq, [this](auto it) {return erase_or_unlink(it);});
  }
  void unique() {
    unique(equal_to<>());
  }

  template <class BPRED>
  void merge(this_t &l, BPRED less) {
    if (addressof(l) == this)
      return;
    iterator it = begin(), l_it = l.begin();
    if (l_it == l.end())
      return;
    if (it == end())
      return splice(it, l);
    for (;;) {
      if (less(*l_it, *it)) {
        const iterator bk = l_it.next();
        splice(it, l, l_it);
        l_it = bk;
        if (l_it == l.end())
          return;
      }
      else {
        ++it;
        if (it == end())
          return splice(it, l);
      }
    }
  }
  template <class BPRED>
  void merge(this_t &&l, BPRED less) {
    merge(l, less);
  }
  void merge(this_t &l) {
    merge(l, less<>{});
  }
  void merge(this_t &&l) {
    merge(l, less<>{});
  }

  void reverse() noexcept {
    iterator it = begin();
    while (it != end()) {
      const auto tmp = it.prev();
      it.prev(it.next());
      it.next(tmp);
      it = it.prev();
    }
    const auto tmp = end().prev();
    end().prev(end().next());
    end().next(tmp);
  }

  template <class BPRED>
  void sort(BPRED less) {
    if (begin() == end() || ++begin() == end())
      return;
    constexpr size_t max_depth = sizeof(ptrdiff_t) * 8;
    local_vector<this_t, max_depth> sorted; // the ith has 2 ^ i or 0 elements
    for (size_t n = max_depth; n != 0; --n)
      sorted.emplace_back(this_t(get_allocator()));
    this_t l(get_allocator());
    while (!empty()) {
      l.splice(l.begin(), *this, begin());
      for (this_t &x : sorted) {
        if (x.empty()) {
          x = move(l);
          break;
        }
        else {
          x.merge(l, less);
          l = move(x);
        }
      }
    }
    for (auto &x : rrng(sorted))
      merge(x, less);
  }
  void sort() {
    sort(less<>());
  }

  template <class R>
  iterator replace(const_iterator i1, const_iterator i2, R &&r)
    requires (!is_convertible_v<R &&, this_t &&>) {
    return inner::fns::seq_container_replace_impl
      (*this, i1.to_mutable(), i2.to_mutable(), r);
  }

  using node_type = inner::list_node_handle<traits>;
  template <class...S>
  node_type make_node(S &&...s) {
    return node_type(new_node(forward<S>(s)...).node(), get_allocator());
  }

  node_type extract(const_iterator ci) noexcept {
    unlink(ci);
    return node_type(ci.node(), get_allocator());
  }
  iterator insert(const_iterator ci, node_type &&x) noexcept {
    return (!x.empty()) ? link(ci, iterator(x.release())) : ci.to_mutable();
  }
  void push_back(node_type &&x) {
    insert(end(), move(x));
  }
  void push_front(node_type &&x) {
    insert(begin(), move(x));
  }
  node_type exchange(const_iterator ci, node_type &x) noexcept {
    (!x.empty()) ? exchange_node(ci, iterator(x.release())) : unlink(ci);
    return node_type(ci.node(), get_allocator());
  }
  node_type exchange(const_iterator ci, node_type &&x) noexcept {
    return exchange(ci, x);
  }
  iterator replace(const_iterator ci, node_type &&x) noexcept {
    if (!x.empty()) {
      const iterator it(x.release());
      delete_node(exchange_node(ci, it));
      return it;
    }
    else
      return erase(ci);
  }

  this_t extract(const_iterator ci, const_iterator ci2) noexcept {
    this_t l(get_allocator());
    l.splice(l.end(), *this, ci, ci2);
    return l;
  }
  iterator insert(const_iterator ci, this_t &&l) noexcept {
    if (l.empty())
      return ci.to_mutable();
    else {
      const auto it1 = l.begin();
      const auto it2 = prev(l.end());
      l.unlink();
      link(ci, it1, it2);
      return it1;
    }
  }
  void push_back(this_t &&x) {
    insert(end(), move(x));
  }
  void push_front(this_t &&x) {
    insert(begin(), move(x));
  }
  this_t exchange(const_iterator ci, const_iterator ci2,
                  this_t &x) noexcept {
    this_t ret = extract(ci, ci2);
    insert(ci2, move(x));
    return ret;
  }
  this_t exchange(const_iterator ci, const_iterator ci2,
                  this_t &&x) noexcept {
    return exchange(ci, ci2, x);
  }
  iterator replace(const_iterator ci, const_iterator ci2,
                   this_t &&x) noexcept {
    erase(ci, ci2);
    return insert(ci2, move(x));
  }

  // extensions

  template <class R>
  list_adaptor(from_range_t, R &&r, const alloc_t &al = alloc_t{})
    requires (is_rng<R> && is_constructible_v<value_type, rng_ref<R>>)
    : alloc_t(al) {
    new_data();
    insert_range_impl(end(), r);
  }
  template <class R, class = enable_if_t
            <!is_same_v<decay_t<R>, this_t>
             && !is_convertible_v<R &&, const alloc_t &>
             && is_rng<R> && is_constructible_v<value_type, rng_ref<R>>>>
  explicit list_adaptor(R &&r) : list_adaptor(r, alloc_t{}) {}
  template <class R, class = enable_if_t
            <!is_same_v<decay_t<R>, this_t>
             && is_rng<R> && is_constructible_v<value_type, rng_ref<R>>>>
  list_adaptor(R &&r, const alloc_t &al) : alloc_t(al) {
    new_data();
    insert_range_impl(end(), r);
  }
  template <class IITR_RANGE>
  enable_if_t<!is_same_v<decay_t<IITR_RANGE>, this_t>
              && is_rng<IITR_RANGE>
              && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
              && is_assignable_v<value_type &, rng_ref<IITR_RANGE>>, this_t &>
  operator =(IITR_RANGE &&r) {
    assign_range_impl(r);
    return *this;
  }
  template <class IITR_RANGE>
  void assign(IITR_RANGE &&r) {
    assign_range_impl(r);
  }
  template <class IITR_RANGE>
  void assign_range(IITR_RANGE &&r) {
    assign_range_impl(r);
  }

  template <class IITR_RANGE>
  enable_if_t<!is_convertible_v<IITR_RANGE &&, value_type &&>
              && !is_convertible_v<IITR_RANGE &&, const value_type &>
              && !is_convertible_v<IITR_RANGE &&, node_type &&>
              && !is_convertible_v<IITR_RANGE &&, this_t &&>,
              iterator>
  insert(const_iterator pos, IITR_RANGE &&r) {
    return insert_range_impl(pos.to_mutable(), r);
  }
  template <class IITR_RANGE>
  iterator insert_range(const_iterator pos, IITR_RANGE &&r) {
    return insert_range_impl(pos.to_mutable(), r);
  }

  template <class IITR_RANGE>
  enable_if_t<!is_convertible_v<IITR_RANGE &&, value_type &&>
              && !is_convertible_v<IITR_RANGE &&, const value_type &>
              && !is_convertible_v<IITR_RANGE &&, node_type &&>
              && !is_convertible_v<IITR_RANGE &&, this_t &&>>
  push_back(IITR_RANGE &&r) {
    insert_range_impl(end(), r);
  }
  template <class IITR_RANGE>
  void append_range(IITR_RANGE &&r) {
    insert_range_impl(end(), r);
  }
  void pop_back(size_type n) {
    for (; n != 0; --n)
      pop_back();
  }

  template <class IITR_RANGE>
  enable_if_t<!is_convertible_v<IITR_RANGE &&, value_type &&>
              && !is_convertible_v<IITR_RANGE &&, const value_type &>
              && !is_convertible_v<IITR_RANGE &&, node_type &&>
              && !is_convertible_v<IITR_RANGE &&, this_t &&>>
  push_front(IITR_RANGE &&r) {
    insert_range_impl(begin(), r);
  }
  template <class IITR_RANGE>
  void prepend_range(IITR_RANGE &&r) {
    insert_range_impl(begin(), r);
  }
  void pop_front(size_type n) {
    for (; n != 0; --n)
      pop_front();
  }

  this_t &append() {
    return *this;
  }
  template <class X, class...S>
  this_t &append(X &&x, S &&...s) {
    push_back(forward<X>(x));
    return append(forward<S>(s)...);
  }

  this_t &prepend() {
    return *this;
  }
  template <class X, class...S>
  this_t &prepend(X &&x, S &&...s) {
    prepend(forward<S>(s)...);
    push_front(forward<X>(x));
    return *this;
  }
};
template <class TRAITS>
bool operator ==(const list_adaptor<TRAITS> &x,
                 const list_adaptor<TRAITS> &y) {
  return equal(x, y);
}
template <class TRAITS>
synth_3way_result<typename TRAITS::value_type>
operator <=>(const list_adaptor<TRAITS> &x,
             const list_adaptor<TRAITS> &y) {
  return lexicographical_synth_3way(x, y);
}

}

// queue
namespace re {

template <class T, class CONTAINER = deque<T>>
class queue {
protected:
  CONTAINER c;

  friend re::inner::fo_base;

  const CONTAINER &base() const & {
    return c;
  }
  CONTAINER base() && {
    return move(c);
  }

public:
  using value_type = typename CONTAINER::value_type;
  using reference = typename CONTAINER::reference;
  using const_reference = typename CONTAINER::const_reference;
  using size_type = typename CONTAINER::size_type;
  using container_type = CONTAINER;

  queue() : queue(CONTAINER{}) {}
  ~queue() = default;
  queue(const queue &) = default;
  queue &operator =(const queue &) = default;
  queue(queue &&) = default;
  queue &operator =(queue &&) = default;
  friend void swap(queue &x, queue &y)
    noexcept(is_nothrow_swappable_v<CONTAINER>) {
    adl_swap(x.c, y.c);
  }

  template <class A, class B>
  friend bool operator ==(const queue<A, B> &, const queue<A, B> &);
  template <class A, class B>
  friend synth_3way_result<A> operator <=>(const queue<A, B> &,
                                           const queue<A, B> &);

  template <class ALLOC,
            class = enable_if_t<uses_allocator_v<CONTAINER, ALLOC>>>
  explicit queue(const ALLOC &a) : c(a) {}
  template <class ALLOC,
            class = enable_if_t<uses_allocator_v<CONTAINER, ALLOC>>>
  queue(const queue &x, const ALLOC &a) : c(x.c, a) {}
  template <class ALLOC,
            class = enable_if_t<uses_allocator_v<CONTAINER, ALLOC>>>
  queue(queue &&x, const ALLOC &a) : c(move(x.c), a) {}

  explicit queue(const CONTAINER &x) : c(x) {}
  explicit queue(CONTAINER &&x) : c(move(x)) {};
  template <class ALLOC,
            class = enable_if_t<uses_allocator_v<CONTAINER, ALLOC>>>
  queue(const CONTAINER &x, const ALLOC &a) : c(x, a) {}
  template <class ALLOC,
            class = enable_if_t<uses_allocator_v<CONTAINER, ALLOC>>>
  queue(CONTAINER &&x, const ALLOC &a) : c(move(x), a) {};

  template <class IITR>
  queue(IITR first, IITR last) : c(first, last) {}
  template <class IITR, class ALLOC,
            class = enable_if_t<uses_allocator_v<CONTAINER, ALLOC>>>
  queue(IITR first, IITR last, const ALLOC &a) : c(first, last, a) {}

  template <class R>
  queue(from_range_t, R &&r) : c(from_range, r) {};
  template <class R, class ALLOC,
            class = enable_if_t<uses_allocator_v<CONTAINER, ALLOC>>>
  queue(from_range_t, R &&r, const ALLOC &a) : c(from_range, r, a) {};

  bool empty() const {
    return c.empty();
  }
  size_type size() const {
    return c.size();
  }
  reference front() {
    return c.front();
  }
  const_reference front() const {
    return c.front();
  }
  reference back() {
    return c.back();
  }
  const_reference back() const {
    return c.back();
  }
  void push(const value_type &x) {
    c.push_back(x);
  }
  void push(value_type &&x) {
    c.push_back(move(x));
  }
  template <class R, class = enable_if_t
            <is_rng<R> && is_constructible_v<value_type, rng_ref<R>>>>
  void push_range(R &&r) {
    c.append_range(r);
  }
  template <class...S>
  reference emplace(S &&...s) {
    return c.emplace_back(forward<S>(s)...);
  }
  void pop() {
    c.pop_front();
  }
};
template <class A, class B>
bool operator ==(const queue<A, B> &x, const queue<A, B> &y) {
  return equal(x.base(), y.base());
}
template <class A, class B>
synth_3way_result<A> operator <=>(const queue<A, B> &x,
                                  const queue<A, B> &y) {
  return lexicographical_synth_3way(x.base(), y.base());
}
template <class A, class B, class ALLOC>
struct uses_allocator<queue<A, B>, ALLOC> : uses_allocator<B, ALLOC>::type {};

}

// stack
namespace re {

template <class T, class CONTAINER = deque<T>>
class stack {
protected:
  CONTAINER c;

  friend struct re::inner::fo_base;

  const CONTAINER base() const & {
    return c;
  }
  CONTAINER base() && {
    return move(c);
  }

public:
  using value_type = typename CONTAINER::value_type;
  using reference = typename CONTAINER::reference;
  using const_reference = typename CONTAINER::const_reference;
  using size_type = typename CONTAINER::size_type;
  using container_type = CONTAINER;

  stack() : stack(CONTAINER{}) {}
  ~stack() = default;
  stack(const stack &) = default;
  stack &operator =(const stack &) = default;
  stack(stack &&) = default;
  stack &operator =(stack &&) = default;
  friend void swap(stack &x, stack &y)
    noexcept(is_nothrow_swappable_v<CONTAINER>) {
    adl_swap(x.c, y.c);
  }

  template <class A, class B>
  friend bool operator ==(const stack<A, B> &, const stack<A, B> &);
  template <class A, class B>
  friend synth_3way_result<A> operator <=>(const stack<A, B> &,
                                           const stack<A, B> &);

  template <class ALLOC,
            class = enable_if_t<uses_allocator_v<CONTAINER, ALLOC>>>
  explicit stack(const ALLOC &a) : c(a) {}
  template <class ALLOC,
            class = enable_if_t<uses_allocator_v<CONTAINER, ALLOC>>>
  stack(const stack &x, const ALLOC &a) : c(x.c, a) {}
  template <class ALLOC,
            class = enable_if_t<uses_allocator_v<CONTAINER, ALLOC>>>
  stack(stack &&x, const ALLOC &a) : c(move(x.c), a) {}

  explicit stack(const CONTAINER &x) : c(x) {}
  explicit stack(CONTAINER &&x) : c(move(x)) {};
  template <class ALLOC,
            class = enable_if_t<uses_allocator_v<CONTAINER, ALLOC>>>
  stack(const CONTAINER &x, const ALLOC &a) : c(x, a) {}
  template <class ALLOC,
            class = enable_if_t<uses_allocator_v<CONTAINER, ALLOC>>>
  stack(CONTAINER &&x, const ALLOC &a) : c(move(x), a) {};

  template <class IITR, class = enable_if_t<is_iitr<IITR>>>
  stack(IITR from, IITR to) : c(from, to) {}
  template <class IITR, class ALLOC, class = enable_if_t
            <is_iitr<IITR> && uses_allocator_v<CONTAINER, ALLOC>>>
  stack(IITR from, IITR to, const ALLOC &a) : c(from, to, a) {}
  template <class R, class = enable_if_t
            <is_rng<R> && is_constructible_v<T, rng_ref<R>>>>
  stack(from_range_t, R &&r) : c(from_range, r) {}
  template <class R, class ALLOC, class = enable_if_t
            <is_rng<R> && is_constructible_v<T, rng_ref<R>>
             && uses_allocator_v<CONTAINER, ALLOC>>>
  stack(from_range_t, R &&r, const ALLOC &a) : c(from_range, r, a) {}

  bool empty() const {
    return c.empty();
  }
  size_type size() const {
    return c.size();
  }
  reference top() {
    return c.back();
  }
  const_reference top() const {
    return c.back();
  }
  void push(const value_type &x) {
    c.push_back(x);
  }
  void push(value_type &&x) {
    c.push_back(move(x));
  }
  template <class R, class = enable_if_t
            <is_rng<R> && is_constructible_v<value_type, rng_ref<R>>>>
  void push_range(R &&r) {
    c.append_range(r);
  }
  template <class...S>
  reference emplace(S &&...s) {
    return c.emplace_back(forward<S>(s)...);
  }
  void pop() {
    c.pop_back();
  }
};
template <class A, class B>
bool operator ==(const stack<A, B> &x, const stack<A, B> &y) {
  return equal(x.base(), y.base());
}
template <class A, class B>
synth_3way_result<A> operator <=>(const stack<A, B> &x,
                                  const stack<A, B> &y) {
  return lexicographical_synth_3way(x.base(), y.base());
}
template <class A, class B, class ALLOC>
struct uses_allocator<stack<A, B>, ALLOC> : uses_allocator<B, ALLOC>::type {};

}

// priority_queue
namespace re {

template <class T, class CONTAINER = vector<T>,
          class COMPARE = less<typename CONTAINER::value_type>>
class priority_queue {
protected:
  CONTAINER c;
  COMPARE comp;

  friend struct re::inner::fo_base;

  const CONTAINER &base() const & {
    return c;
  }
  CONTAINER base() && {
    return move(c);
  }

public:
  using value_type = typename CONTAINER::value_type;
  using reference = typename CONTAINER::reference;
  using const_reference = typename CONTAINER::const_reference;
  using size_type = typename CONTAINER::size_type;
  using container_type = CONTAINER;
  using value_compare = COMPARE;

  priority_queue() : priority_queue(COMPARE{}) {}
  ~priority_queue() = default;
  priority_queue(const priority_queue &) = default;
  priority_queue &operator =(const priority_queue &) = default;
  priority_queue(priority_queue &&) = default;
  priority_queue &operator =(priority_queue &&) = default;
  friend void swap(priority_queue &x, priority_queue &y)
    noexcept(is_nothrow_swappable_v<CONTAINER>
             && is_nothrow_swappable_v<COMPARE>) {
    adl_swap(x.c, y.c);
    adl_swap(x.comp, y.comp);
  }

  template <class ALLOC,
            class = enable_if_t<uses_allocator_v<CONTAINER, ALLOC>>>
  explicit priority_queue(const ALLOC &a) : c(a), comp() {}
  template <class ALLOC,
            class = enable_if_t<uses_allocator_v<CONTAINER, ALLOC>>>
  priority_queue(const priority_queue &x, const ALLOC &a)
    : c(x.c, a), comp(x.comp) {}
  template <class ALLOC,
            class = enable_if_t<uses_allocator_v<CONTAINER, ALLOC>>>
  priority_queue(priority_queue &&x, const ALLOC &a)
    : c(move(x.c), a), comp(move(x.comp)) {}

  explicit priority_queue(const COMPARE &cmp)
    : priority_queue(cmp, CONTAINER{}) {}
  priority_queue(const COMPARE &cmp, const CONTAINER &x)
    : c(x), comp(cmp) {
    make_heap(c, comp);
  }
  priority_queue(const COMPARE &cmp, CONTAINER &&x)
    : c(move(x)), comp(cmp) {
    make_heap(c, comp);
  }
  template <class ALLOC,
            class = enable_if_t<uses_allocator_v<CONTAINER, ALLOC>>>
  priority_queue(const COMPARE &cmp, const ALLOC &a) : c(a), comp(cmp) {
    make_heap(c, ref(comp));
  }
  template <class ALLOC,
            class = enable_if_t<uses_allocator_v<CONTAINER, ALLOC>>>
  priority_queue(const COMPARE &cmp, const CONTAINER &x, const ALLOC &a)
    : c(x, a), comp(cmp) {
    make_heap(c, ref(comp));
  }
  template <class ALLOC,
            class = enable_if_t<uses_allocator_v<CONTAINER, ALLOC>>>
  priority_queue(const COMPARE &cmp, CONTAINER &&x, const ALLOC &a)
    : c(move(x), a), comp(cmp) {
    make_heap(c, ref(comp));
  }

  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  priority_queue(IITR first, IITR last, const COMPARE &cmp = COMPARE{})
    : c(), comp(cmp) {
    c.insert(c.end(), first, last);
    make_heap(c, comp);
  }
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  priority_queue(IITR first, IITR last,
                 const COMPARE &cmp, const CONTAINER &x)
    : c(x), comp(cmp) {
    c.insert(c.end(), first, last);
    make_heap(c, comp);
  }
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  priority_queue(IITR first, IITR last,
                 const COMPARE &cmp, CONTAINER &&x)
    : c(move(x)), comp(cmp) {
    c.insert(c.end(), first, last);
    make_heap(c, comp);
  }
  template <class IITR, class ALLOC,
            class = enable_if_t
            <is_itr<IITR> && uses_allocator_v<CONTAINER, ALLOC>>>
  priority_queue(IITR first, IITR last, const ALLOC &a)
    : c(a), comp() {
    c.insert(c.end(), first, last);
    make_heap(c, comp);
  }
  template <class IITR, class ALLOC,
            class = enable_if_t
            <is_itr<IITR> && uses_allocator_v<CONTAINER, ALLOC>>>
  priority_queue(IITR first, IITR last, const COMPARE &cmp, const ALLOC &a)
    : c(a), comp(cmp) {
    c.insert(c.end(), first, last);
    make_heap(c, comp);
  }
  template <class IITR, class ALLOC,
            class = enable_if_t
            <is_itr<IITR> && uses_allocator_v<CONTAINER, ALLOC>>>
  priority_queue(IITR first, IITR last,
                 const COMPARE &cmp, const CONTAINER &x,
                 const ALLOC &a)
    : c(x, a), comp(cmp) {
    c.insert(c.end(), first, last);
    make_heap(c, comp);
  }
  template <class IITR, class ALLOC,
            class = enable_if_t
            <is_itr<IITR> && uses_allocator_v<CONTAINER, ALLOC>>>
  priority_queue(IITR first, IITR last,
                 const COMPARE &cmp, CONTAINER &&x,
                 const ALLOC &a)
    : c(move(x), a), comp(cmp) {
    c.insert(c.end(), first, last);
    make_heap(c, comp);
  }

  template <class R>
  priority_queue(from_range_t, R &&r, const COMPARE &cmp = COMPARE{})
    requires (is_rng<R> && is_constructible_v<T, rng_ref<R>>)
    : c(from_range, r), comp(cmp) {
    make_heap(c, comp);
  }
  template <class R, class ALLOC,
            class = enable_if_t<uses_allocator_v<CONTAINER, ALLOC>>>
  priority_queue(from_range_t, R &&r, const ALLOC &a)
    requires (is_rng<R> && is_constructible_v<T, rng_ref<R>>)
    : c(from_range, r, a), comp() {
    make_heap(c, comp);
  }
  template <class R, class ALLOC,
            class = enable_if_t<uses_allocator_v<CONTAINER, ALLOC>>>
  priority_queue(from_range_t, R &&r, const COMPARE &cmp, const ALLOC &a)
    requires (is_rng<R> && is_constructible_v<T, rng_ref<R>>)
    : c(from_range, r, a), comp(cmp) {
    make_heap(c, comp);
  }

  bool empty() const {
    return c.empty();
  }
  size_type size() const {
    return c.size();
  }
  const_reference top() const {
    return c.front();
  }
  void push(const value_type &x) {
    c.push_back(x);
    push_heap(c, ref(comp));
  }
  void push(value_type &&x) {
    c.push_back(move(x));
    push_heap(c, ref(comp));
  }
  template <class R, class = enable_if_t
            <is_rng<R> && is_constructible_v<value_type, rng_ref<R>>>>
  void push_range(R &&r) {
    for (auto &it : iters(r))
      push(*it);
  }
  template <class...S>
  void emplace(S &&...s) {
    c.emplace_back(forward<S>(s)...);
    push_heap(c, ref(comp));
  }
  void pop() {
    pop_heap(c, ref(comp));
    c.pop_back();
  }
};
template <class A, class B, class C, class D>
struct uses_allocator<priority_queue<A, B, C>, D>
  : uses_allocator<B, D>::type {};

}

// flat_(set/map/multiset/multimap)
namespace re {

template <class T, class LESS = less<T>, class CONTAINER = vector<T>>
class flat_set
  : derivable_wrapper<LESS>
  , public conditional_allocator_type<CONTAINER> {
  template <class R>
  static auto begin(R &&r) {return re::begin(r);}
  template <class R>
  static auto end(R &&r) {return re::end(r);}
  template <class R>
  static auto rbegin(R &&r) {return re::rbegin(r);}
  template <class R>
  static auto rend(R &&r) {return re::rend(r);}
  template <class R>
  static auto size(R &&r) {return re::size(r);}
  template <class R>
  static auto empty(R &&r) {return re::empty(r);}

  using this_t = flat_set;
  using base_t = CONTAINER;

  CONTAINER c;

  using less_wrapper = derivable_wrapper<LESS>;
  LESS &less_ref() {
    return *static_cast<less_wrapper &>(*this);
  }
  const LESS &less_ref() const {
    return *static_cast<const less_wrapper &>(*this);
  }

  bool less(const typename CONTAINER::value_type &x,
            const typename CONTAINER::value_type &y) const {
    return less_ref()(x, y);
  }
  template <class X, class Y,
            class LESS2 = LESS, class = typename LESS2::is_transparent>
  bool less(const X &x, const Y &y) const {
    return less_ref()(x, y);
  }
  auto less_fn() const {
    return ref(less_ref());
  }

  using base_type = CONTAINER;
  const base_t &base() const {
    return c;
  }
  base_t &base() {
    return c;
  }

public:
  using container_type = CONTAINER;
  container_type extract() && {
    return move(c);
  }
  void replace(container_type &&cont) {
    c = move(cont);
  }

  // container

  using value_type = typename base_t::value_type;
  using reference = typename base_t::reference;
  using const_reference = typename base_t::const_reference;

  using iterator = typename base_t::iterator;
  using const_iterator = typename base_t::const_iterator;
  using difference_type = typename base_t::difference_type;
  using size_type = typename base_t::size_type;

  iterator begin() noexcept {
    return c.begin();
  }
  iterator end() noexcept {
    return c.end();
  }
  const_iterator begin() const noexcept {
    return c.begin();
  }
  const_iterator end() const noexcept {
    return c.end();
  }
  const_iterator cbegin() const noexcept {
    return begin();
  }
  const_iterator cend() const noexcept {
    return end();
  }

  size_type max_size() const noexcept {
    return c.max_size();
  }
  size_type size() const noexcept {
    return c.size();
  }
  bool empty() const noexcept {
    return c.empty();
  }

  flat_set() = default;
  ~flat_set() = default;
  flat_set(const flat_set &) = default;
  flat_set &operator =(const flat_set &) = default;
  flat_set(flat_set &&) = default;
  flat_set &operator =(flat_set &&) = default;
  friend void swap(flat_set &x, flat_set &y)
    noexcept(is_nothrow_swappable_v<CONTAINER>
             && is_nothrow_swappable_v<LESS>) {
    adl_swap(x.c, y.c);
    adl_swap(x.less_ref(), y.less_ref());
  }

  // optional container operations

  // reversible container

  using reverse_iterator = re::reverse_iterator<iterator>;
  using const_reverse_iterator = re::reverse_iterator<const_iterator>;

  reverse_iterator rbegin() noexcept {
    return reverse_iterator(end());
  }
  reverse_iterator rend() noexcept {
    return reverse_iterator(begin());
  }
  const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator(begin());
  }
  const_reverse_iterator crbegin() const noexcept {
    return rbegin();
  }
  const_reverse_iterator crend() const noexcept {
    return rend();
  }

  // allocator-aware container

  auto get_allocator() const noexcept
    ->decltype(declval<const CONTAINER &>().get_allocator()) {
    return c.get_allocator();
  }

  template <class ALLOC,
            class = enable_if_t<uses_allocator_v<CONTAINER, ALLOC>>>
  explicit flat_set(const ALLOC &a) : c(a) {}
  template <class ALLOC,
            class = enable_if_t<uses_allocator_v<CONTAINER, ALLOC>>>
  flat_set(const flat_set &x, const ALLOC &a)
    : less_wrapper(x.less_ref()), c(x.c, a) {}
  template <class ALLOC,
            class = enable_if_t<uses_allocator_v<CONTAINER, ALLOC>>>
  flat_set(flat_set &&x, const ALLOC &a)
    : less_wrapper(move(x.less_ref())), c(move(x.c), a) {}

  // associative container

  using key_type = T;
  using key_compare = LESS;
  using value_compare = LESS;
  LESS key_comp() const {
    return less_ref();
  }
  LESS value_comp() const {
    return less_ref();
  }

  explicit flat_set(const LESS &l) : less_wrapper(l) {}
  template <class ALLOC,
            class = enable_if_t<uses_allocator_v<CONTAINER, ALLOC>>>
  flat_set(const LESS &l, const ALLOC &a) : less_wrapper(l), c(a) {}

  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  flat_set(IITR first, IITR last, const LESS &l = LESS{})
    : less_wrapper(l), c(first, last) {
    sort_c();
  }
  template <class IITR, class ALLOC,
            class = enable_if_t<is_itr<IITR>
                                && uses_allocator_v<CONTAINER, ALLOC>>>
  flat_set(IITR first, IITR last, const ALLOC &a) : c(first, last, a) {
    sort_c();
  }
  template <class IITR, class ALLOC,
            class = enable_if_t<is_itr<IITR>
                                && uses_allocator_v<CONTAINER, ALLOC>>>
  flat_set(IITR first, IITR last, const LESS &l, const ALLOC &a)
    : less_wrapper(l), c(first, last, a) {
    sort_c();
  }
  template <class IITR>
  enable_if_t<is_itr<IITR>> assign(IITR from, IITR to) {
    c.assign(from, to);
    sort_c();
  }

  flat_set(initializer_list<value_type> il, const LESS &l = LESS{})
    : less_wrapper(l), c(il) {
    sort_c();
  }
  template <class ALLOC,
            class = enable_if_t<uses_allocator_v<CONTAINER, ALLOC>>>
  flat_set(initializer_list<value_type> il, const ALLOC &alloc)
    : c(il, alloc) {
    sort_c();
  }
  template <class ALLOC,
            class = enable_if_t<uses_allocator_v<CONTAINER, ALLOC>>>
  flat_set(initializer_list<value_type> il,
           const LESS &l, const ALLOC &alloc)
    : less_wrapper(l), c(il, alloc) {
    sort_c();
  }
  flat_set &operator =(initializer_list<value_type> il) {
    c = il;
    sort_c();
    return *this;
  }
  void assign(initializer_list<value_type> il) {
    c = il;
    sort_c();
  }

private:
  template <class...S>
  value_type make_value(S &&...s) {
    return value_type(forward<S>(s)...);
  }
  template <class...S>
  value_type make_value(S &&...s)
    requires (requires {typename CONTAINER::allocator_type;}) {
    return value_type
      (move(*allocator_wrapper<typename CONTAINER::allocator_type>
            (c.get_allocator()).make_temporary(forward<S>(s)...)));
  }
  template <class X>
  pair<iterator, bool> insert_impl(X &&x) {
    const auto it = upper_bound(x);
    if (it != c.begin() && !less(*prev(it), x))
      return {prev(it), false};
    else
      return {c.insert(it, forward<X>(x)), true};
  }
  template <class X>
  iterator insert_impl(const_iterator hint, X &&x) {
    if (c.empty())
      return c.insert(c.end(), forward<X>(x));
    else if (hint == c.end()) {
      const iterator back_i = prev(c.end());
      if (less(*back_i, x))
        return c.insert(hint, forward<X>(x));
      else if (!less(x, *back_i))
        return back_i;
    }
    else if (hint == c.begin()) {
      const iterator front_i = c.begin();
      if (less(x, *front_i))
        return c.insert(hint, forward<X>(x));
      else if (!less(*front_i, x))
        return front_i;
    }
    else if (less(*prev(hint), x) && less(x, *hint))
      return c.insert(hint, forward<X>(x));

    return insert(forward<X>(x)).first;
  }
public:
  template <class...S>
  pair<iterator, bool> emplace(S &&...s) {
    return insert_impl(make_value(forward<S>(s)...));
  }
  template <class...S>
  iterator emplace_hint(const_iterator hint, S &&...s) {
    return insert_impl(hint, make_value(forward<S>(s)...));
  }
  pair<iterator, bool> insert(const value_type &x) {
    return insert_impl(x);
  }
  pair<iterator, bool> insert(value_type &&x) {
    return insert_impl(move(x));
  }
  template <class K, class X = LESS, class = typename X::is_transparent,
            class = enable_if_t<is_constructible_v<value_type, K &&>>>
  pair<iterator, bool> insert(K &&k) {
    return insert_impl(forward<K>(k));
  }
  iterator insert(const_iterator hint, const value_type &x) {
    return insert_impl(hint, x);
  }
  iterator insert(const_iterator hint, value_type &&x) {
    return insert_impl(hint, move(x));
  }
  template <class K, class X = LESS, class = typename X::is_transparent,
            class = enable_if_t<is_constructible_v<value_type, K &&>>>
  iterator insert(const_iterator hint, K &&k) {
    return insert_impl(hint, forward<K>(k));
  }
  template <class IITR>
  void insert(IITR first, IITR last) {
    insert_range(rng(first, last));
  }
  void insert(initializer_list<value_type> il) {
    insert_range(il);
  }

  iterator erase(const_iterator pos) {
    return c.erase(pos);
  }
  iterator erase(const_iterator first, const_iterator last) {
    return c.erase(first, last);
  }
  void clear() noexcept {
    c.clear();
  }

  size_type erase(const key_type &key) {
    if (const auto i = find(key); i != end()) {
      c.erase(i);
      return 1;
    }
    return 0;
  }
  template <class K, class X = LESS, class = typename X::is_transparent,
            class = enable_if_t<!is_convertible_v<K &&, iterator>
                                && !is_convertible_v<K &&, const_iterator>>>
  size_type erase(K &&key) {
    if (const auto i = find(key); i != end()) {
      c.erase(i);
      return 1;
    }
    return 0;
  }

  template <class K, class X = LESS, class = typename X::is_transparent>
  size_type remove(const K &key) {
    if (const auto i = find(key); i != end()) {
      c.erase(i);
      return 1;
    }
    return 0;
  }
  size_type remove(const key_type &key) {
    if (const auto i = find(key); i != end()) {
      c.erase(i);
      return 1;
    }
    return 0;
  }
  template <class UF>
  size_type remove_if(UF eq) {
    size_type ret = 0;
    for (iterator it = begin(); it != end();) {
      if (eq(*it)) {
        it = erase(it);
        ++ret;
      }
      else
        ++it;
    }
    return ret;
  }

  template <class K, class X = LESS, class = typename X::is_transparent>
  iterator find(const K &key) {
    const auto i = lower_bound(key);
    const auto ed = end();
    return (i != ed && !less(key, *i)) ? i : ed;
  }
  iterator find(const key_type &key) {
    const auto i = lower_bound(key);
    const auto ed = end();
    return (i != ed && !less(key, *i)) ? i : ed;
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  const_iterator find(const K &key) const {
    const auto i = lower_bound(key);
    const auto ed = end();
    return (i != ed && !less(key, *i)) ? i : ed;
  }
  const_iterator find(const key_type &key) const {
    const auto i = lower_bound(key);
    const auto ed = end();
    return (i != ed && !less(key, *i)) ? i : ed;
  }

  template <class K, class X = LESS, class = typename X::is_transparent>
  bool contains(const K &key) const {
    return find(key) != end();
  }
  bool contains(const key_type &key) const {
    return find(key) != end();
  }

  size_type count(const key_type &key) const {
    return find(key) != end();
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  size_type count(const K &key) const {
    return find(key) != end();
  }

  iterator lower_bound(const key_type &key) {
    return re::lower_bound(c, key, less_fn());
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  iterator lower_bound(const K &key) {
    return re::lower_bound(c, key, less_fn());
  }
  const_iterator lower_bound(const key_type &key) const {
    return re::lower_bound(c, key, less_fn());
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  const_iterator lower_bound(const K &key) const {
    return re::lower_bound(c, key, less_fn());
  }

  iterator upper_bound(const key_type &key) {
    return re::upper_bound(c, key, less_fn());
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  iterator upper_bound(const K &key) {
    return re::upper_bound(c, key, less_fn());
  }
  const_iterator upper_bound(const key_type &key) const {
    return re::upper_bound(c, key, less_fn());
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  const_iterator upper_bound(const K &key) const {
    return re::upper_bound(c, key, less_fn());
  }

  iter_pair<iterator> equal_range(const key_type &key) {
    return re::equal_range(c, key, less_fn());
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  iter_pair<iterator> equal_range(const K &key) {
    return re::equal_range(c, key, less_fn());
  }
  iter_pair<const_iterator> equal_range(const key_type &key) const {
    return re::equal_range(c, key, less_fn());
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  iter_pair<const_iterator> equal_range(const K &key) const {
    return re::equal_range(c, key, less_fn());
  }

  // extensions

  template <class K, class K2,
            class X = LESS, class = typename X::is_transparent>
  iter_pair<iterator> find_range(const K &key, const K2 &key2) {
    return {lower_bound(key), upper_bound(key2)};
  }
  iter_pair<iterator> find_range(const key_type &key,
                                 const key_type &key2) {
    return {lower_bound(key), upper_bound(key2)};
  }
  template <class K, class K2,
            class X = LESS, class = typename X::is_transparent>
  iter_pair<const_iterator> find_range(const K &key, const K2 &key2) const {
    return {lower_bound(key), upper_bound(key2)};
  }
  iter_pair<const_iterator> find_range(const key_type &key,
                                       const key_type &key2) const {
    return {lower_bound(key), upper_bound(key2)};
  }

  reference front() {
    return c.front();
  }
  const_reference front() const {
    return c.front();
  }
  reference back() {
    return c.back();
  }
  const_reference back() const {
    return c.back();
  }

  template <class RANGE>
  void merge(RANGE &&r) requires (!is_convertible_v<RANGE &&, this_t &&>) {
    c.insert_range(c.end(), r);
    sort_c();
  }
  void merge(this_t &&x) {
    c.insert_range(c.end(), move_rng(x));
    sort_c();
    x.clear();
  }

  void unique() {}
  template <class EQL>
  void unique(EQL eql) {
    c.erase(re::unique(*this, eql), c.end());
  }

  void reserve(size_type n) {
    c.reserve(n);
  }
  size_type capacity() const noexcept {
    return c.capacity();
  }
  void shrink_to_fit() {
    c.shrink_to_fit();
  }

private:
  void sort_c() {
#ifndef RE_NOEXCEPT
    try {
#endif
      sort(c, less_fn());
      const auto i = re::unique(c, not_fn(less_fn()));
      c.erase(i, c.end());
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      clear();
      throw;
    }
#endif
  }
public:
  template <class R, class = enable_if_t
            <is_rng<R> && is_constructible_v<value_type, rng_ref<R>>>>
  flat_set(from_range_t, R &&r, const LESS &l = LESS{})
    : less_wrapper(l), c(from_range, r) {
    sort_c();
  }
  template <class R, class ALLOC, class = enable_if_t
            <is_rng<R> && is_constructible_v<value_type, rng_ref<R>>
             && uses_allocator_v<CONTAINER, ALLOC>>>
  flat_set(from_range_t, R &&r, const LESS &l, const ALLOC &a)
    : less_wrapper(l), c(from_range, r, a) {
    sort_c();
  }
  template <class R, class ALLOC, class = enable_if_t
            <is_rng<R> && is_constructible_v<value_type, rng_ref<R>>
             && uses_allocator_v<CONTAINER, ALLOC>>>
  flat_set(from_range_t, R &&r, const ALLOC &a) : c(from_range, r, a) {
    sort_c();
  }
  template <class IITR_RANGE, class = enable_if_t
            <((is_rng<IITR_RANGE>
               && is_constructible_v<value_type, rng_ref<IITR_RANGE>>))
             && !is_same_v<decay_t<IITR_RANGE>, this_t>
             && !is_convertible_v<IITR_RANGE &&, const LESS &>
             && !uses_allocator_v<CONTAINER, IITR_RANGE &&>>>
  explicit flat_set(IITR_RANGE &&r) : c(r) {
    sort_c();
  }
  template <class IITR_RANGE, class = enable_if_t
            <((is_rng<IITR_RANGE>
               && is_constructible_v<value_type, rng_ref<IITR_RANGE>>))
             && !is_same_v<decay_t<IITR_RANGE>, this_t>
             && !is_convertible_v<IITR_RANGE &&, const LESS &>>>
  flat_set(IITR_RANGE &&r, const LESS &l)
    : less_wrapper(l), c(r) {
    sort_c();
  }
  template <class IITR_RANGE, class ALLOC, class = enable_if_t
            <((is_rng<IITR_RANGE>
               && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
               && uses_allocator_v<CONTAINER, ALLOC>))
             && !is_same_v<decay_t<IITR_RANGE>, this_t>
             && !is_convertible_v<IITR_RANGE &&, const LESS &>>>
  flat_set(IITR_RANGE &&r, const ALLOC &a) : c(r, a) {
    sort_c();
  }
  template <class IITR_RANGE, class ALLOC, class = enable_if_t
            <((is_rng<IITR_RANGE>
               && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
               && uses_allocator_v<CONTAINER, ALLOC>))
             && !is_same_v<decay_t<IITR_RANGE>, this_t>
             && !is_convertible_v<IITR_RANGE, const LESS &>>>
  flat_set(IITR_RANGE &&r, const LESS &l, const ALLOC &a)
    : less_wrapper(l), c(r, a) {
    sort_c();
  }
  template <class IITR_RANGE>
  enable_if_t<is_rng<IITR_RANGE>
              && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
              && is_assignable_v<value_type &, rng_ref<IITR_RANGE>>
              && !is_same_v<decay_t<IITR_RANGE>, this_t>,
              this_t &>
  operator =(IITR_RANGE &&r) {
    assign_range(r);
    return *this;
  }
  template <class IITR_RANGE>
  void assign_range(IITR_RANGE &&r) {
    c.assign_range(r);
    sort_c();
  }
  template <class IITR_RANGE>
  void assign(IITR_RANGE &&r) {
    assign_range(r);
  }

  template <class IITR_RANGE>
  enable_if_t<(!is_transparent_function_v<LESS>
               && !is_convertible_v<IITR_RANGE &&, value_type &&>
               && !is_convertible_v<IITR_RANGE &&, const value_type &>)
              || !is_constructible_v<value_type, IITR_RANGE &&>>
  insert(IITR_RANGE &&r) {
    insert_range(r);
  }
  template <class IITR_RANGE>
  void insert_range(IITR_RANGE &&r) {
    for (auto &i : iters(r))
      insert(*i);
  }

  this_t &append() {
    return *this;
  }
  template <class X, class...S>
  this_t &append(X &&x, S &&...s) {
    insert(forward<X>(x));
    return append(forward<S>(s)...);
  }
};
template <class A, class B, class C>
bool operator ==(const flat_set<A, B, C> &x,
                 const flat_set<A, B, C> &y) {
  return equal(x, y);
}
template <class A, class B, class C>
synth_3way_result<A> operator <=>(const flat_set<A, B, C> &x,
                                  const flat_set<A, B, C> &y) {
  return lexicographical_synth_3way(x, y);
}

template <class T, class LESS = less<T>, class CONTAINER = vector<T>>
class flat_multiset
  : derivable_wrapper<LESS>
  , public conditional_allocator_type<CONTAINER> {
  template <class R>
  static auto begin(R &&r) {return re::begin(r);}
  template <class R>
  static auto end(R &&r) {return re::end(r);}
  template <class R>
  static auto rbegin(R &&r) {return re::rbegin(r);}
  template <class R>
  static auto rend(R &&r) {return re::rend(r);}
  template <class R>
  static auto size(R &&r) {return re::size(r);}
  template <class R>
  static auto empty(R &&r) {return re::empty(r);}

  using this_t = flat_multiset;
  using base_t = CONTAINER;

  CONTAINER c;

  using less_wrapper = derivable_wrapper<LESS>;
  LESS &less_ref() {
    return *static_cast<less_wrapper &>(*this);
  }
  const LESS &less_ref() const {
    return *static_cast<const less_wrapper &>(*this);
  }

  bool less(const typename CONTAINER::value_type &x,
            const typename CONTAINER::value_type &y) const {
    return less_ref()(x, y);
  }
  template <class X, class Y,
            class LESS2 = LESS, class = typename LESS2::is_transparent>
  bool less(const X &x, const Y &y) const {
    return less_ref()(x, y);
  }
  auto less_fn() const {
    return ref(less_ref());
  }

  using base_type = CONTAINER;
  const base_t &base() const {
    return c;
  }
  base_t &base() {
    return c;
  }

public:
  using container_type = CONTAINER;
  container_type extract() && {
    return move(c);
  }
  void replace(container_type &&cont) {
    c = move(cont);
  }

  // container

  using value_type = typename base_t::value_type;
  using reference = typename base_t::reference;
  using const_reference = typename base_t::const_reference;

  using iterator = typename base_t::iterator;
  using const_iterator = typename base_t::const_iterator;
  using difference_type = typename base_t::difference_type;
  using size_type = typename base_t::size_type;

  iterator begin() noexcept {
    return c.begin();
  }
  iterator end() noexcept {
    return c.end();
  }
  const_iterator begin() const noexcept {
    return c.begin();
  }
  const_iterator end() const noexcept {
    return c.end();
  }
  const_iterator cbegin() const noexcept {
    return begin();
  }
  const_iterator cend() const noexcept {
    return end();
  }

  size_type max_size() const noexcept {
    return c.max_size();
  }
  size_type size() const noexcept {
    return c.size();
  }
  bool empty() const noexcept {
    return c.empty();
  }  

  flat_multiset() = default;
  ~flat_multiset() = default;
  flat_multiset(const flat_multiset &) = default;
  flat_multiset &operator =(const flat_multiset &) = default;
  flat_multiset(flat_multiset &&) = default;
  flat_multiset &operator =(flat_multiset &&) = default;
  friend void swap(flat_multiset &x, flat_multiset &y)
    noexcept(is_nothrow_swappable_v<CONTAINER>
             && is_nothrow_swappable_v<LESS>) {
    adl_swap(x.c, y.c);
    adl_swap(x.less_ref(), y.less_ref());
  }

  // optional container operations

  // reversible container

  using reverse_iterator = re::reverse_iterator<iterator>;
  using const_reverse_iterator = re::reverse_iterator<const_iterator>;

  reverse_iterator rbegin() noexcept {
    return reverse_iterator(end());
  }
  reverse_iterator rend() noexcept {
    return reverse_iterator(begin());
  }
  const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator(begin());
  }
  const_reverse_iterator crbegin() const noexcept {
    return rbegin();
  }
  const_reverse_iterator crend() const noexcept {
    return rend();
  }

  // allocator-aware container

  auto get_allocator() const noexcept
    ->decltype(declval<const CONTAINER &>().get_allocator()) {
    return c.get_allocator();
  }

  template <class ALLOC,
            class = enable_if_t<uses_allocator_v<CONTAINER, ALLOC>>>
  explicit flat_multiset(const ALLOC &a) : c(a) {}
  template <class ALLOC,
            class = enable_if_t<uses_allocator_v<CONTAINER, ALLOC>>>
  flat_multiset(const flat_multiset &x, const ALLOC &a)
    : less_wrapper(x.less_ref()), c(x.c, a) {}
  template <class ALLOC,
            class = enable_if_t<uses_allocator_v<CONTAINER, ALLOC>>>
  flat_multiset(flat_multiset &&x, const ALLOC &a)
    : less_wrapper(move(x.less_ref())), c(move(x.c), a) {}

  // associative container

  using key_type = T;
  using key_compare = LESS;
  using value_compare = LESS;
  LESS key_comp() const {
    return less_ref();
  }
  LESS value_comp() const {
    return less_ref();
  }

  explicit flat_multiset(const LESS &l) : less_wrapper(l) {}
  template <class ALLOC,
            class = enable_if_t<uses_allocator_v<CONTAINER, ALLOC>>>
  flat_multiset(const LESS &l, const ALLOC &a)
    : less_wrapper(l), c(a) {}

  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  flat_multiset(IITR first, IITR last, const LESS &l = LESS{})
    : less_wrapper(l), c(first, last) {
    sort_c();
  }
  template <class IITR, class ALLOC,
            class = enable_if_t<is_itr<IITR>
                                && uses_allocator_v<CONTAINER, ALLOC>>>
  flat_multiset(IITR first, IITR last, const ALLOC &a) : c(first, last, a) {
    sort_c();
  }
  template <class IITR, class ALLOC,
            class = enable_if_t<is_itr<IITR>
                                && uses_allocator_v<CONTAINER, ALLOC>>>
  flat_multiset(IITR first, IITR last, const LESS &l, const ALLOC &a)
    : less_wrapper(l), c(first, last, a) {
    sort_c();
  }
  template <class IITR>
  enable_if_t<is_itr<IITR>> assign(IITR from, IITR to) {
    c.assign(from, to);
    sort_c();
  }

  flat_multiset(initializer_list<value_type> il, const LESS &l = LESS{})
    : less_wrapper(l), c(il) {
    sort_c();
  }
  template <class ALLOC,
            class = enable_if_t<uses_allocator_v<CONTAINER, ALLOC>>>
  flat_multiset(initializer_list<value_type> il, const ALLOC &alloc)
    : c(il, alloc) {
    sort_c();
  }
  template <class ALLOC,
            class = enable_if_t<uses_allocator_v<CONTAINER, ALLOC>>>
  flat_multiset(initializer_list<value_type> il,
                const LESS &l, const ALLOC &alloc)
    : less_wrapper(l), c(il, alloc) {
    sort_c();
  }
  flat_multiset &operator =(initializer_list<value_type> il) {
    c = il;
    sort_c();
    return *this;
  }
  void assign(initializer_list<value_type> il) {
    c = il;
    sort_c();
  }

private:
  template <class...S>
  value_type make_value(S &&...s) {
    return value_type(forward<S>(s)...);
  }
  template <class...S>
  value_type make_value(S &&...s)
    requires (requires {typename CONTAINER::allocator_type;}) {
    return value_type
      (move(*allocator_wrapper<typename CONTAINER::allocator_type>
            (c.get_allocator()).make_temporary(forward<S>(s)...)));
  }
  template <class X>
  iterator insert_impl(X &&x) {
    return c.insert(upper_bound(x), forward<X>(x));
  }
  template <class X>
  iterator insert_impl(const_iterator hint_iter, X &&x) {
    const iterator hint = hint_iter - begin() + begin();

    if (c.empty())
      return c.insert(c.end(), forward<X>(x));
    else if (hint == c.end()) {
      if (!less(x, *prev(hint)))
        return c.insert(hint, forward<X>(x));
    }
    else if (hint == c.begin()) {
      if (!less(*hint, x))
        return c.insert(hint, forward<X>(x));
    }
    else if (!less(x, *prev(hint)) && !less(*hint, x))
      return c.insert(hint, forward<X>(x));

    return insert(forward<X>(x));
  }
public:
  template <class...S>
  iterator emplace(S &&...s) {
    return insert_impl(make_value(forward<S>(s)...));
  }
  template <class...S>
  iterator emplace_hint(const_iterator hint, S &&...s) {
    return insert_impl(hint, make_value(forward<S>(s)...));
  }
  iterator insert(const value_type &x) {
    return insert_impl(x);
  }
  iterator insert(value_type &&x) {
    return insert_impl(move(x));
  }
  template <class K, class X = LESS, class = typename X::is_transparent,
            class = enable_if_t<is_constructible_v<value_type, K &&>>>
  iterator insert(K &&k) {
    return insert_impl(forward<K>(k));
  }
  iterator insert(const_iterator hint, const value_type &x) {
    return insert_impl(hint, x);
  }
  iterator insert(const_iterator hint, value_type &&x) {
    return insert_impl(hint, move(x));
  }
  template <class K, class X = LESS, class = typename X::is_transparent,
            class = enable_if_t<is_constructible_v<value_type, K &&>>>
  iterator insert(const_iterator hint, K &&k) {
    return insert_impl(hint, forward<K>(k));
  }
  template <class IITR>
  void insert(IITR first, IITR last) {
    insert_range(rng(first, last));
  }
  void insert(initializer_list<value_type> il) {
    insert_range(il);
  }

  iterator erase(const_iterator pos) {
    return c.erase(pos);
  }
  iterator erase(const_iterator first, const_iterator last) {
    return c.erase(first, last);
  }
  void clear() noexcept {
    c.clear();
  }

  size_type erase(const key_type &key) {
    const auto r = equal_range(key);
    const size_type ret = size(r);
    c.erase(begin(r), end(r));
    return ret;
  }
  template <class K, class X = LESS, class = typename X::is_transparent,
            class = enable_if_t<!is_convertible_v<K &&, iterator>
                                && !is_convertible_v<K &&, const_iterator>>>
  size_type erase(K &&key) {
    const auto r = equal_range(key);
    const size_type ret = size(r);
    c.erase(begin(r), end(r));
    return ret;
  }

  size_type remove(const key_type &key) {
    const auto r = equal_range(key);
    const size_type ret = size(r);
    c.erase(begin(r), end(r));
    return ret;
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  size_type remove(const K &key) {
    const auto r = equal_range(key);
    const size_type ret = size(r);
    c.erase(begin(r), end(r));
    return ret;
  }
  template <class UF>
  size_type remove_if(UF eq) {
    size_type ret = 0;
    for (iterator it = begin(); it != end();) {
      if (eq(*it)) {
        it = erase(it);
        ++ret;
      }
      else
        ++it;
    }
    return ret;
  }

  template <class K, class X = LESS, class = typename X::is_transparent>
  iterator find(const K &key) {
    const auto i = lower_bound(key);
    const auto ed = end();
    return (i != ed && !less(key, *i)) ? i : ed;
  }
  iterator find(const key_type &key) {
    const auto i = lower_bound(key);
    const auto ed = end();
    return (i != ed && !less(key, *i)) ? i : ed;
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  const_iterator find(const K &key) const {
    const auto i = lower_bound(key);
    const auto ed = end();
    return (i != ed && !less(key, *i)) ? i : ed;
  }
  const_iterator find(const key_type &key) const {
    const auto i = lower_bound(key);
    const auto ed = end();
    return (i != ed && !less(key, *i)) ? i : ed;
  }

  template <class K, class X = LESS, class = typename X::is_transparent>
  bool contains(const K &key) const {
    return find(key) != end();
  }
  bool contains(const key_type &key) const {
    return find(key) != end();
  }

  size_type count(const key_type &key) const {
    return equal_range(key).size();
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  size_type count(const K &key) const {
    return equal_range(key).size();
  }

  iterator lower_bound(const key_type &key) {
    return re::lower_bound(c, key, less_fn());
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  iterator lower_bound(const K &key) {
    return re::lower_bound(c, key, less_fn());
  }
  const_iterator lower_bound(const key_type &key) const {
    return re::lower_bound(c, key, less_fn());
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  const_iterator lower_bound(const K &key) const {
    return re::lower_bound(c, key, less_fn());
  }

  iterator upper_bound(const key_type &key) {
    return re::upper_bound(c, key, less_fn());
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  iterator upper_bound(const K &key) {
    return re::upper_bound(c, key, less_fn());
  }
  const_iterator upper_bound(const key_type &key) const {
    return re::upper_bound(c, key, less_fn());
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  const_iterator upper_bound(const K &key) const {
    return re::upper_bound(c, key, less_fn());
  }

  iter_pair<iterator> equal_range(const key_type &key) {
    return re::equal_range(c, key, less_fn());
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  iter_pair<iterator> equal_range(const K &key) {
    return re::equal_range(c, key, less_fn());
  }
  iter_pair<const_iterator> equal_range(const key_type &key) const {
    return re::equal_range(c, key, less_fn());
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  iter_pair<const_iterator> equal_range(const K &key) const {
    return re::equal_range(c, key, less_fn());
  }

  // extensions

  template <class K, class K2,
            class X = LESS, class = typename X::is_transparent>
  iter_pair<iterator> find_range(const K &key, const K2 &key2) {
    return {lower_bound(key), upper_bound(key2)};
  }
  iter_pair<iterator> find_range(const key_type &key,
                                 const key_type &key2) {
    return {lower_bound(key), upper_bound(key2)};
  }
  template <class K, class K2,
            class X = LESS, class = typename X::is_transparent>
  iter_pair<const_iterator>
  find_range(const K &key, const K2 &key2) const {
    return {lower_bound(key), upper_bound(key2)};
  }
  iter_pair<const_iterator> find_range(const key_type &key,
                                       const key_type &key2) const {
    return {lower_bound(key), upper_bound(key2)};
  }

  reference front() {
    return c.front();
  }
  const_reference front() const {
    return c.front();
  }
  reference back() {
    return c.back();
  }
  const_reference back() const {
    return c.back();
  }

  template <class RANGE>
  void merge(RANGE &&r) requires (!is_convertible_v<RANGE &&, this_t &&>) {
    this_t tmp(move(*this));
    clear();
    re::merge(move_rng(tmp), r, back_inserter(c), less_fn());
  }
  void merge(this_t &&x) {
    this_t tmp(move(*this));
    clear();
    re::merge(move_rng(tmp), move_rng(x), back_inserter(c), less_fn());
    x.clear();
  }

  void unique() {
    c.erase(re::unique(*this, not_fn(less_fn())), c.end());
  }
  template <class EQL>
  void unique(EQL eql) {
    c.erase(re::unique(*this, eql), c.end());
  }

  void reserve(size_type n) {
    c.reserve(n);
  }
  size_type capacity() const noexcept {
    return c.capacity();
  }
  void shrink_to_fit() {
    c.shrink_to_fit();
  }

private:
  void sort_c() {
#ifndef RE_NOEXCEPT
    try {
#endif
      stable_sort(c, less_fn());
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      clear();
      throw;
    }
#endif
  }
public:
  template <class R, class = enable_if_t
            <is_rng<R> && is_constructible_v<value_type, rng_ref<R>>>>
  flat_multiset(from_range_t, R &&r, const LESS &l = LESS{})
    : less_wrapper(l), c(from_range, r) {
    sort_c();
  }
  template <class R, class ALLOC, class = enable_if_t
            <is_rng<R> && is_constructible_v<value_type, rng_ref<R>>
             && uses_allocator_v<CONTAINER, ALLOC>>>
  flat_multiset(from_range_t, R &&r, const LESS &l, const ALLOC &a)
    : less_wrapper(l), c(from_range, r, a) {
    sort_c();
  }
  template <class R, class ALLOC, class = enable_if_t
            <is_rng<R> && is_constructible_v<value_type, rng_ref<R>>
             && uses_allocator_v<CONTAINER, ALLOC>>>
  flat_multiset(from_range_t, R &&r, const ALLOC &a) : c(from_range, r, a) {
    sort_c();
  }
  template <class IITR_RANGE, class = enable_if_t
            <((is_rng<IITR_RANGE>
               && is_constructible_v<value_type, rng_ref<IITR_RANGE>>))
             && !is_same_v<decay_t<IITR_RANGE>, this_t>
             && !is_convertible_v<IITR_RANGE &&, const LESS &>
             && !uses_allocator_v<CONTAINER, IITR_RANGE &&>>>
  explicit flat_multiset(IITR_RANGE &&r) : c(r) {
    sort_c();
  }
  template <class IITR_RANGE, class = enable_if_t
            <((is_rng<IITR_RANGE>
               && is_constructible_v<value_type, rng_ref<IITR_RANGE>>))
             && !is_same_v<decay_t<IITR_RANGE>, this_t>
             && !is_convertible_v<IITR_RANGE, const LESS &>>>
  flat_multiset(IITR_RANGE &&r, const LESS &l)
    : less_wrapper(l), c(r) {
    sort_c();
  }
  template <class IITR_RANGE, class ALLOC, class = enable_if_t
            <((is_rng<IITR_RANGE>
               && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
               && uses_allocator_v<CONTAINER, ALLOC>))
             && !is_same_v<decay_t<IITR_RANGE>, this_t>
             && !is_convertible_v<IITR_RANGE &&, const LESS &>>>
  flat_multiset(IITR_RANGE &&r, const ALLOC &a) : c(r, a) {
    sort_c();
  }
  template <class IITR_RANGE, class ALLOC, class = enable_if_t
            <((is_rng<IITR_RANGE>
               && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
               && uses_allocator_v<CONTAINER, ALLOC>))
             && !is_same_v<decay_t<IITR_RANGE>, this_t>
             && !is_convertible_v<IITR_RANGE &&, const LESS &>>>
  flat_multiset(IITR_RANGE &&r, const LESS &l, const ALLOC &a)
    : less_wrapper(l), c(r, a) {
    sort_c();
  }
  template <class IITR_RANGE>
  enable_if_t<is_rng<IITR_RANGE>
              && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
              && is_assignable_v<value_type &, rng_ref<IITR_RANGE>>
              && !is_same_v<decay_t<IITR_RANGE>, this_t>,
              this_t &>
  operator =(IITR_RANGE &&r) {
    assign_range(r);
    return *this;
  }
  template <class IITR_RANGE>
  void assign_range(IITR_RANGE &&r) {
    c.assign_range(r);
    sort_c();
  }
  template <class IITR_RANGE>
  void assign(IITR_RANGE &&r) {
    assign_range(r);
  }

  template <class IITR_RANGE>
  enable_if_t<(!is_transparent_function_v<LESS>
               && !is_convertible_v<IITR_RANGE &&, value_type &&>
               && !is_convertible_v<IITR_RANGE &&, const value_type &>)
              || !is_constructible_v<value_type, IITR_RANGE &&>>
  insert(IITR_RANGE &&r) {
    insert_range(r);
  }
  template <class IITR_RANGE>
  void insert_range(IITR_RANGE &&r) {
    for (auto &i : iters(r))
      emplace(*i);
  }

  this_t &append() {
    return *this;
  }
  template <class X, class...S>
  this_t &append(X &&x, S &&...s) {
    insert(forward<X>(x));
    return append(forward<S>(s)...);
  }
};
template <class A, class B, class C>
bool operator ==(const flat_multiset<A, B, C> &x,
                 const flat_multiset<A, B, C> &y) {
  return equal(x, y);
}
template <class A, class B, class C>
synth_3way_result<A> operator <=>(const flat_multiset<A, B, C> &x,
                                  const flat_multiset<A, B, C> &y) {
  return lexicographical_synth_3way(x, y);
}

template <class KEY, class MAPPED, class LESS = less<KEY>,
          class CONTAINER = vector<pair<KEY, MAPPED>>>
class flat_map
  : derivable_wrapper<LESS>
  , public conditional_allocator_type<CONTAINER> {
  template <class R>
  static auto begin(R &&r) {return re::begin(r);}
  template <class R>
  static auto end(R &&r) {return re::end(r);}
  template <class R>
  static auto rbegin(R &&r) {return re::rbegin(r);}
  template <class R>
  static auto rend(R &&r) {return re::rend(r);}
  template <class R>
  static auto size(R &&r) {return re::size(r);}
  template <class R>
  static auto empty(R &&r) {return re::empty(r);}

  using this_t = flat_map;
  using base_t = CONTAINER;

  CONTAINER c;

  using less_wrapper = derivable_wrapper<LESS>;
  LESS &less_ref() {
    return *static_cast<less_wrapper &>(*this);
  }
  const LESS &less_ref() const {
    return *static_cast<const less_wrapper &>(*this);
  }

  bool less(const KEY &x, const KEY &y) const {
    return less_ref()(x, y);
  }
  template <class X, class Y,
            class LESS2 = LESS, class = typename LESS2::is_transparent>
  bool less(const X &x, const Y &y) const {
    return less_ref()(x, y);
  }
  auto less_fn() const {
    return ref(less_ref());
  }

  bool value_less(const typename CONTAINER::value_type &x,
                  const typename CONTAINER::value_type &y) const {
    return less_ref()(x.first, y.first);
  }
  auto value_less_fn() const {
    return [&](const typename CONTAINER::value_type &x,
               const typename CONTAINER::value_type &y) {
      return less_ref()(x.first, y.first);
    };
  }

  using base_type = CONTAINER;
  const base_t &base() const {
    return c;
  }
  base_t &base() {
    return c;
  }

public:
  using container_type = CONTAINER;
  container_type extract() && {
    return move(c);
  }
  void replace(container_type &&cont) {
    c = move(cont);
  }

  // container

  using value_type = typename base_t::value_type;
  using reference = typename base_t::reference;
  using const_reference = typename base_t::const_reference;

  using iterator = typename base_t::iterator;
  using const_iterator = typename base_t::const_iterator;
  using difference_type = typename base_t::difference_type;
  using size_type = typename base_t::size_type;

  iterator begin() noexcept {
    return c.begin();
  }
  iterator end() noexcept {
    return c.end();
  }
  const_iterator begin() const noexcept {
    return c.begin();
  }
  const_iterator end() const noexcept {
    return c.end();
  }
  const_iterator cbegin() const noexcept {
    return begin();
  }
  const_iterator cend() const noexcept {
    return end();
  }

  size_type max_size() const noexcept {
    return c.max_size();
  }
  size_type size() const noexcept {
    return c.size();
  }
  bool empty() const noexcept {
    return c.empty();
  }  

  flat_map() = default;
  ~flat_map() = default;
  flat_map(const flat_map &) = default;
  flat_map &operator =(const flat_map &) = default;
  flat_map(flat_map &&) = default;
  flat_map &operator =(flat_map &&) = default;
  friend void swap(flat_map &x, flat_map &y)
    noexcept(is_nothrow_swappable_v<CONTAINER>
             && is_nothrow_swappable_v<LESS>) {
    adl_swap(x.c, y.c);
    adl_swap(x.less_ref(), y.less_ref());
  }

  // optional container operations

  // reversible container

  using reverse_iterator = re::reverse_iterator<iterator>;
  using const_reverse_iterator = re::reverse_iterator<const_iterator>;

  reverse_iterator rbegin() noexcept {
    return reverse_iterator(end());
  }
  reverse_iterator rend() noexcept {
    return reverse_iterator(begin());
  }
  const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator(begin());
  }
  const_reverse_iterator crbegin() const noexcept {
    return rbegin();
  }
  const_reverse_iterator crend() const noexcept {
    return rend();
  }

  // allocator-aware container

  auto get_allocator() const noexcept
    ->decltype(declval<const CONTAINER &>().get_allocator()) {
    return c.get_allocator();
  }

  template <class ALLOC,
            class = enable_if_t<uses_allocator_v<CONTAINER, ALLOC>>>
  explicit flat_map(const ALLOC &a) : c(a) {}
  template <class ALLOC,
            class = enable_if_t<uses_allocator_v<CONTAINER, ALLOC>>>
  flat_map(const flat_map &x, const ALLOC &a)
    : less_wrapper(x.less_ref()), c(x.c, a) {}
  template <class ALLOC,
            class = enable_if_t<uses_allocator_v<CONTAINER, ALLOC>>>
  flat_map(flat_map &&x, const ALLOC &a)
    : less_wrapper(move(x.less_ref())), c(move(x.c), a) {}

  // associative container

  using key_type = KEY;
  using mapped_type = MAPPED;
  using key_compare = LESS;
  class value_compare {
    friend class flat_map;

    LESS l;
    explicit value_compare(const LESS &x) : l(x) {}

  public:
    value_compare() = delete;
    ~value_compare() = default;
    value_compare(const value_compare &) = default;
    value_compare &operator =(const value_compare &) = default;
    value_compare(value_compare &&) = default;
    value_compare &operator =(value_compare &&) = default;
    friend void swap(value_compare &x, value_compare &y)
      noexcept(is_nothrow_swappable_v<LESS>) {
      adl_swap(x.l, y.l);
    }

    bool operator ()(const value_type &x, const value_type &y) const {
      return l(x.first, y.first);
    }
  };
  LESS key_comp() const {
    return less_ref();
  }
  value_compare value_comp() const {
    return value_compare(less_ref());
  }

  explicit flat_map(const LESS &l) : less_wrapper(l) {}
  template <class ALLOC,
            class = enable_if_t<uses_allocator_v<CONTAINER, ALLOC>>>
  flat_map(const LESS &l, const ALLOC &a) : less_wrapper(l), c(a) {}

  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  flat_map(IITR first, IITR last, const LESS &l = LESS{})
    : less_wrapper(l), c(first, last) {
    sort_c();
  }
  template <class IITR, class ALLOC,
            class = enable_if_t<is_itr<IITR>
                                && uses_allocator_v<CONTAINER, ALLOC>>>
  flat_map(IITR first, IITR last, const ALLOC &a) : c(first, last, a) {
    sort_c();
  }
  template <class IITR, class ALLOC,
            class = enable_if_t<is_itr<IITR>
                                && uses_allocator_v<CONTAINER, ALLOC>>>
  flat_map(IITR first, IITR last, const LESS &l, const ALLOC &a)
    : less_wrapper(l), c(first, last, a) {
    sort_c();
  }
  template <class IITR>
  enable_if_t<is_itr<IITR>> assign(IITR from, IITR to) {
    c.assign(from, to);
    sort_c();
  }

  flat_map(initializer_list<value_type> il, const LESS &l = LESS{})
    : less_wrapper(l), c(il) {
    sort_c();
  }
  template <class ALLOC,
            class = enable_if_t<uses_allocator_v<CONTAINER, ALLOC>>>
  flat_map(initializer_list<value_type> il, const ALLOC &alloc)
    : c(il, alloc) {
    sort_c();
  }
  template <class ALLOC,
            class = enable_if_t<uses_allocator_v<CONTAINER, ALLOC>>>
  flat_map(initializer_list<value_type> il, const LESS &l, const ALLOC &alloc)
    : less_wrapper(l), c(il, alloc) {
    sort_c();
  }
  flat_map &operator =(initializer_list<value_type> il) {
    c = il;
    sort_c();
    return *this;
  }
  void assign(initializer_list<value_type> il) {
    c = il;
    sort_c();
  }

private:
  template <class...S>
  value_type make_value(S &&...s) {
    return value_type(forward<S>(s)...);
  }
  template <class...S>
  value_type make_value(S &&...s)
    requires (requires {typename CONTAINER::allocator_type;}) {
    return value_type
      (move(*allocator_wrapper<typename CONTAINER::allocator_type>
            (c.get_allocator()).make_temporary(forward<S>(s)...)));
  }
  template <class X>
  pair<iterator, bool> insert_impl(X &&x) {
    const auto it = upper_bound(x.first);
    if (it != c.begin() && !value_less(*prev(it), x))
      return {prev(it), false};
    else
      return {c.insert(it, forward<X>(x)), true};
  }
  template <class X>
  iterator insert_impl(const_iterator hint, X &&x) {
    if (c.empty())
      return c.insert(c.end(), forward<X>(x));
    else if (hint == c.end()) {
      const iterator back_i = prev(c.end());
      if (value_less(*back_i, x))
        return c.insert(hint, forward<X>(x));
      else if (!value_less(x, *back_i))
        return back_i;
    }
    else if (hint == c.begin()) {
      const iterator front_i = c.begin();
      if (value_less(x, *front_i))
        return c.insert(hint, forward<X>(x));
      else if (!value_less(*front_i, x))
        return front_i;
    }
    else if (value_less(*prev(hint), x) && value_less(x, *hint))
      return c.insert(hint, forward<X>(x));

    return insert(forward<X>(x)).first;
  }
public:
  template <class...S>
  pair<iterator, bool> emplace(S &&...s) {
    return insert_impl(make_value(forward<S>(s)...));
  }
  template <class...S>
  iterator emplace_hint(const_iterator hint, S &&...s) {
    return insert_impl(hint, make_value(forward<S>(s)...));
  }
  pair<iterator, bool> insert(const value_type &x) {
    return insert_impl(x);
  }
  pair<iterator, bool> insert(value_type &&x) {
    return insert_impl(move(x));
  }
  iterator insert(const_iterator hint, const value_type &x) {
    return insert_impl(hint, x);
  }
  iterator insert(const_iterator hint, value_type &&x) {
    return insert_impl(hint, move(x));
  }
  template <class IITR>
  void insert(IITR first, IITR last) {
    insert_range(rng(first, last));
  }
  void insert(initializer_list<value_type> il) {
    insert_range(il);
  }

private:
  template <class F, class K, class...S>
  pair<iterator, bool>
  try_emplace_impl(F do_when_equal, K &&key, S &&...s) {
    const auto it = upper_bound(key);
    if (it != c.begin()) {
      if (auto prev_it = prev(it); !less(prev_it->first, key)) {
        do_when_equal(prev_it, forward<S>(s)...);
        return {prev_it, false};
      }
    }
    return {c.emplace(it, piecewise_construct,
                      forward_as_tuple(forward<K>(key)),
                      forward_as_tuple(forward<S>(s)...)), true};
  }
  template <class F, class K, class...S>
  iterator try_emplace_hint_impl(F do_when_equal, const_iterator hint,
                                 K &&key, S &&...s) {
    if (c.empty())
      return c.emplace(c.end(), piecewise_construct,
                       forward_as_tuple(forward<K>(key)),
                       forward_as_tuple(forward<S>(s)...));
    else if (hint == c.end()) {
      if (const auto back_i = prev(hint); less(back_i->first, key))
        return c.emplace(hint, piecewise_construct,
                         forward_as_tuple(forward<K>(key)),
                         forward_as_tuple(forward<S>(s)...));
    }
    else if (hint == c.begin()) {
      if (less(key, hint->first))
        return c.emplace(hint, piecewise_construct,
                         forward_as_tuple(forward<K>(key)),
                         forward_as_tuple(forward<S>(s)...));
    }
    else if (less(prev(hint)->first, key) && less(key, hint->first))
      return c.emplace(hint, piecewise_construct,
                       forward_as_tuple(forward<K>(key)),
                       forward_as_tuple(forward<S>(s)...));

    return try_emplace_impl(do_when_equal, forward<K>(key),
                            forward<S>(s)...).first;
  }
  static auto value_assign_fn() {
    return []<class X>(const_iterator i, X &&x) {
      const_cast<mapped_type &>(i->second) = forward<X>(x);
    };
  };
public:
  template <class...S>
  pair<iterator, bool> try_emplace(const key_type &key, S &&...s) {
    return try_emplace_impl(empty_function{}, key, forward<S>(s)...);
  }
  template <class...S>
  pair<iterator, bool> try_emplace(key_type &&key, S &&...s) {
      return try_emplace_impl(empty_function{}, move(key), forward<S>(s)...);
  }
  template <class K, class...S,
            class X = LESS, class = typename X::is_transparent,
            class = enable_if_t<!is_convertible_v<K &&, const_iterator>
                                && !is_convertible_v<K &&, iterator>>>
  pair<iterator, bool> try_emplace(K &&key, S &&...s) {
    return try_emplace_impl(empty_function{}, forward<K>(key),
                            forward<S>(s)...);
  }
  template <class...S>
  iterator try_emplace(const_iterator hint, const key_type &key, S &&...s) {
    return try_emplace_hint_impl(empty_function{}, hint, key, forward<S>(s)...);
  }
  template <class...S>
  iterator try_emplace(const_iterator hint, key_type &&key, S &&...s) {
    return try_emplace_hint_impl(empty_function{}, hint, move(key),
                                 forward<S>(s)...);
  }
  template <class K, class...S,
            class X = LESS, class = typename X::is_transparent>
  iterator try_emplace(const_iterator hint, K &&key, S &&...s) {
    return try_emplace_hint_impl(empty_function{}, hint, forward<K>(key),
                                 forward<S>(s)...);
  }
  template <class X>
  pair<iterator, bool> insert_or_assign(const key_type &key, X &&x) {
    return try_emplace_impl(value_assign_fn(), key, forward<X>(x));
  }
  template <class X>
  pair<iterator, bool> insert_or_assign(key_type &&key, X &&x) {
    return try_emplace_impl(value_assign_fn(), move(key), forward<X>(x));
  }
  template <class K, class X,
            class XX = LESS, class = typename XX::is_transparent>
  pair<iterator, bool> insert_or_assign(K &&key, X &&x) {
    return try_emplace_impl(value_assign_fn(), forward<K>(key), forward<X>(x));
  }
  template <class X>
  iterator insert_or_assign(const_iterator hint,
                            const key_type &key, X &&x) {
    return try_emplace_hint_impl(value_assign_fn(), hint, key, forward<X>(x));
  }
  template <class X>
  iterator insert_or_assign(const_iterator hint,
                            key_type &&key, X &&x) {
    return try_emplace_hint_impl(value_assign_fn(), hint, move(key),
                                 forward<X>(x));
  }
  template <class K, class X,
            class XX = LESS, class = typename XX::is_transparent>
  iterator insert_or_assign(const_iterator hint, K &&key, X &&x) {
    return try_emplace_hint_impl(value_assign_fn(), hint,
                                 forward<K>(key), forward<X>(x));
  }

  mapped_type &operator [](const key_type &key) {
    return try_emplace(key).first->second;
  }
  mapped_type &operator [](key_type &&key) {
    return try_emplace(move(key)).first->second;
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  mapped_type &operator [](K &&key) {
    return try_emplace(forward<K>(key)).first->second;
  }
  const mapped_type &operator [](const key_type &key) const {
    return find(key)->second;
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  const mapped_type &operator [](K &&key) const {
    return find(key)->second;
  }

  mapped_type &at(const key_type &key) {
    const iterator it = find(key);
    if (it == end())
      throw_or_terminate<out_of_range>("re::flat_map: at(key) failed\n");
    return it->second;
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  mapped_type &at(const K &key) {
    const iterator it = find(key);
    if (it == end())
      throw_or_terminate<out_of_range>("re::flat_map: at(key) failed\n");
    return it->second;
  }
  const mapped_type &at(const key_type &key) const {
    const const_iterator it = find(key);
    if (it == end())
      throw_or_terminate<out_of_range>("re::flat_map: at(key) failed\n");
    return it->second;
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  const mapped_type &at(const K &key) const {
    const const_iterator it = find(key);
    if (it == end())
      throw_or_terminate<out_of_range>("re::flat_map: at(key) failed\n");
    return it->second;
  }

  iterator erase(const_iterator pos) {
    return c.erase(pos);
  }
  iterator erase(const_iterator first, const_iterator last) {
    return c.erase(first, last);
  }
  void clear() noexcept {
    c.clear();
  }

  size_type erase(const key_type &key) {
    if (const auto i = find(key); i != end()) {
      c.erase(i);
      return 1;
    }
    return 0;
  }
  template <class K, class X = LESS, class = typename X::is_transparent,
            class = enable_if_t<!is_convertible_v<K &&, iterator>
                                && !is_convertible_v<K &&, const_iterator>>>
  size_type erase(K &&key) {
    if (const auto i = find(key); i != end()) {
      c.erase(i);
      return 1;
    }
    return 0;
  }

  size_type remove(const key_type &key) {
    if (const auto i = find(key); i != end()) {
      c.erase(i);
      return 1;
    }
    return 0;
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  size_type remove(const K &key) {
    if (const auto i = find(key); i != end()) {
      c.erase(i);
      return 1;
    }
    return 0;
  }
  template <class UF>
  size_type remove_if(UF eq) {
    size_type ret = 0;
    for (iterator it = begin(); it != end();) {
      if (eq(*it)) {
        it = erase(it);
        ++ret;
      }
      else
        ++it;
    }
    return ret;
  }

  iterator find(const key_type &key) {
    const auto i = lower_bound(key);
    const auto ed = end();
    return (i != ed && !less(key, i->first)) ? i : ed;
  }
  const_iterator find(const key_type &key) const {
    const auto i = lower_bound(key);
    const auto ed = end();
    return (i != ed && !less(key, i->first)) ? i : ed;
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  iterator find(const K &key) {
    const auto i = lower_bound(key);
    const auto ed = end();
    return (i != ed && !less(key, i->first)) ? i : ed;
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  const_iterator find(const K &key) const {
    const auto i = lower_bound(key);
    const auto ed = end();
    return (i != ed && !less(key, i->first)) ? i : ed;
  }

  template <class K, class X = LESS, class = typename X::is_transparent>
  bool contains(const K &key) const {
    return find(key) != end();
  }
  bool contains(const key_type &key) const {
    return find(key) != end();
  }

  size_type count(const key_type &key) const {
    return (find(key) != end()) ? 1u : 0u;
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  size_type count(const K &key) const {
    return (find(key) != end()) ? 1u : 0u;
  }

  iterator lower_bound(const key_type &key) {
    return re::lower_bound(bind_rng(c, re::at<0>), key, less_fn()).base();
  }
  const_iterator lower_bound(const key_type &key) const {
    return re::lower_bound(bind_rng(c, re::at<0>), key, less_fn()).base();
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  iterator lower_bound(const K &key) {
    return re::lower_bound(bind_rng(c, re::at<0>), key, less_fn()).base();
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  const_iterator lower_bound(const K &key) const {
    return re::lower_bound(bind_rng(c, re::at<0>), key, less_fn()).base();
  }

  iterator upper_bound(const key_type &key) {
    return re::upper_bound(bind_rng(c, re::at<0>), key, less_fn()).base();
  }
  const_iterator upper_bound(const key_type &key) const {
    return re::upper_bound(bind_rng(c, re::at<0>), key, less_fn()).base();
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  iterator upper_bound(const K &key) {
    return re::upper_bound(bind_rng(c, re::at<0>), key, less_fn()).base();
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  const_iterator upper_bound(const K &key) const {
    return re::upper_bound(bind_rng(c, re::at<0>), key, less_fn()).base();
  }

  iter_pair<iterator> equal_range(const key_type &key) {
    return rng(base_rng
               (re::equal_range(bind_rng(c, re::at<0>), key, less_fn())));
  }
  iter_pair<const_iterator> equal_range(const key_type &key) const {
    return rng(base_rng
               (re::equal_range(bind_rng(c, re::at<0>), key, less_fn())));
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  iter_pair<iterator> equal_range(const K &key) {
    return rng(base_rng
               (re::equal_range(bind_rng(c, re::at<0>), key, less_fn())));
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  iter_pair<const_iterator> equal_range(const K &key) const {
    return rng(base_rng
               (re::equal_range(bind_rng(c, re::at<0>), key, less_fn())));
  }

  // extensions

  iter_pair<iterator> find_range(const key_type &key,
                                 const key_type &key2) {
    return {lower_bound(key), upper_bound(key2)};
  }
  iter_pair<const_iterator> find_range(const key_type &key,
                                       const key_type &key2) const {
    return {lower_bound(key), upper_bound(key2)};
  }
  template <class K, class K2,
            class X = LESS, class = typename X::is_transparent>
  iter_pair<iterator> find_range(const K &key, const K2 &key2) {
    return {lower_bound(key), upper_bound(key2)};
  }
  template <class K, class K2,
            class X = LESS, class = typename X::is_transparent>
  iter_pair<const_iterator> find_range(const K &key, const K2 &key2) const {
    return {lower_bound(key), upper_bound(key2)};
  }

  reference front() {
    return c.front();
  }
  const_reference front() const {
    return c.front();
  }
  reference back() {
    return c.back();
  }
  const_reference back() const {
    return c.back();
  }

  template <class RANGE>
  void merge(RANGE &&r) requires (!is_convertible_v<RANGE &&, this_t &&>) {
    c.insert_range(c.end(), r);
    sort_c();
  }
  void merge(this_t &&x) {
    c.insert_range(c.end(), move_rng(x));
    sort_c();
    x.clear();
  }

  void unique() {}
  template <class EQL>
  void unique(EQL eql) {
    c.erase(re::unique(*this, eql), c.end());
  }

  void reserve(size_type n) {
    c.reserve(n);
  }
  size_type capacity() const noexcept {
    return c.capacity();
  }
  void shrink_to_fit() {
    c.shrink_to_fit();
  }

private:
  void sort_c() {
#ifndef RE_NOEXCEPT
    try {
#endif
      sort(c, value_less_fn());
      const auto i = re::unique(c, not_fn(value_less_fn()));
      c.erase(i, c.end());
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      clear();
      throw;
    }
#endif
  }
public:
  template <class R, class = enable_if_t
            <is_rng<R> && is_constructible_v<value_type, rng_ref<R>>>>
  flat_map(from_range_t, R &&r, const LESS &l = LESS{})
    : less_wrapper(l), c(from_range, r) {
    sort_c();
  }
  template <class R, class ALLOC, class = enable_if_t
            <is_rng<R> && is_constructible_v<value_type, rng_ref<R>>
             && uses_allocator_v<CONTAINER, ALLOC>>>
  flat_map(from_range_t, R &&r, const LESS &l, const ALLOC &a)
    : less_wrapper(l), c(from_range, r, a) {
    sort_c();
  }
  template <class R, class ALLOC, class = enable_if_t
            <is_rng<R> && is_constructible_v<value_type, rng_ref<R>>
             && uses_allocator_v<CONTAINER, ALLOC>>>
  flat_map(from_range_t, R &&r, const ALLOC &a) : c(from_range, r, a) {
    sort_c();
  }
  template <class IITR_RANGE, class = enable_if_t
            <((is_rng<IITR_RANGE>
               && is_constructible_v<value_type, rng_ref<IITR_RANGE>>))
             && !is_same_v<decay_t<IITR_RANGE>, this_t>
             && !is_convertible_v<IITR_RANGE &&, const LESS &>
             && !uses_allocator_v<CONTAINER, IITR_RANGE &&>>>
  explicit flat_map(IITR_RANGE &&r) : c(r) {
    sort_c();
  }
  template <class IITR_RANGE, class = enable_if_t
            <((is_rng<IITR_RANGE>
               && is_constructible_v<value_type, rng_ref<IITR_RANGE>>))
             && !is_same_v<decay_t<IITR_RANGE>, this_t>
             && !is_convertible_v<IITR_RANGE &&, const LESS &>>>
  flat_map(IITR_RANGE &&r, const LESS &l)
    : less_wrapper(l), c(r) {
    sort_c();
  }
  template <class IITR_RANGE, class ALLOC, class = enable_if_t
            <((is_rng<IITR_RANGE>
               && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
               && uses_allocator_v<CONTAINER, ALLOC>))
             && !is_same_v<decay_t<IITR_RANGE>, this_t>
             && !is_convertible_v<IITR_RANGE &&, const LESS &>>>
  flat_map(IITR_RANGE &&r, const ALLOC &a) : c(r, a) {
    sort_c();
  }
  template <class IITR_RANGE, class ALLOC, class = enable_if_t
            <((is_rng<IITR_RANGE>
               && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
               && uses_allocator_v<CONTAINER, ALLOC>))
             && !is_same_v<decay_t<IITR_RANGE>, this_t>
             && !is_convertible_v<IITR_RANGE &&, const LESS &>>>
  flat_map(IITR_RANGE &&r, const LESS &l, const ALLOC &a)
    : less_wrapper(l), c(r, a) {
    sort_c();
  }
  template <class IITR_RANGE>
  enable_if_t<is_rng<IITR_RANGE>
              && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
              && is_assignable_v<value_type &, rng_ref<IITR_RANGE>>
              && !is_same_v<decay_t<IITR_RANGE>, this_t>,
              this_t &>
  operator =(IITR_RANGE &&r) {
    assign_range(r);
    return *this;
  }
  template <class IITR_RANGE>
  void assign_range(IITR_RANGE &&r) {
    c.assign_range(r);
    sort_c();
  }
  template <class IITR_RANGE>
  void assign(IITR_RANGE &&r) {
    assign_range(r);
  }

  template <class IITR_RANGE>
  enable_if_t<!is_convertible_v<IITR_RANGE &&, value_type &&>
              && !is_convertible_v<IITR_RANGE &&, const value_type &>>
  insert(IITR_RANGE &&r) {
    insert_range(r);
  }
  template <class IITR_RANGE>
  void insert_range(IITR_RANGE &&r) {
    for (auto &i : iters(r))
      emplace(*i);
  }

  this_t &append() {
    return *this;
  }
  template <class X, class...S>
  this_t &append(X &&x, S &&...s) {
    insert(forward<X>(x));
    return append(forward<S>(s)...);
  }
};
template <class A, class B, class C, class D>
bool operator ==(const flat_map<A, B, C, D> &x,
                 const flat_map<A, B, C, D> &y) {
  return equal(x, y);
}
template <class A, class B, class C, class D>
synth_3way_result<pair<A, B>> operator <=>(const flat_map<A, B, C, D> &x,
                                           const flat_map<A, B, C, D> &y) {
  return lexicographical_synth_3way(x, y);
}

template <class KEY, class MAPPED, class LESS = less<KEY>,
          class CONTAINER = vector<pair<KEY, MAPPED>>>
class flat_multimap
  : derivable_wrapper<LESS>
  , public conditional_allocator_type<CONTAINER> {
  template <class R>
  static auto begin(R &&r) {return re::begin(r);}
  template <class R>
  static auto end(R &&r) {return re::end(r);}
  template <class R>
  static auto rbegin(R &&r) {return re::rbegin(r);}
  template <class R>
  static auto rend(R &&r) {return re::rend(r);}
  template <class R>
  static auto size(R &&r) {return re::size(r);}
  template <class R>
  static auto empty(R &&r) {return re::empty(r);}

  using this_t = flat_multimap;
  using base_t = CONTAINER;

  CONTAINER c;

  using less_wrapper = derivable_wrapper<LESS>;
  LESS &less_ref() {
    return *static_cast<less_wrapper &>(*this);
  }
  const LESS &less_ref() const {
    return *static_cast<const less_wrapper &>(*this);
  }

  bool less(const KEY &x, const KEY &y) const {
    return less_ref()(x, y);
  }
  template <class X, class Y,
            class LESS2 = LESS, class = typename LESS2::is_transparent>
  bool less(const X &x, const Y &y) const {
    return less_ref()(x, y);
  }
  auto less_fn() const {
    return ref(less_ref());
  }

  bool value_less(const typename CONTAINER::value_type &x,
                  const typename CONTAINER::value_type &y) const {
    return less_ref()(x.first, y.first);
  }
  auto value_less_fn() const {
    return [&](const typename CONTAINER::value_type &x,
               const typename CONTAINER::value_type &y) {
      return value_less(x, y);
    };
  }

  using base_type = CONTAINER;
  const base_t &base() const {
    return c;
  }
  base_t &base() {
    return c;
  }

public:
  using container_type = CONTAINER;
  container_type extract() && {
    return move(c);
  }
  void replace(container_type &&cont) {
    c = move(cont);
  }

  // container

  using value_type = typename base_t::value_type;
  using reference = typename base_t::reference;
  using const_reference = typename base_t::const_reference;

  using iterator = typename base_t::iterator;
  using const_iterator = typename base_t::const_iterator;
  using difference_type = typename base_t::difference_type;
  using size_type = typename base_t::size_type;

  iterator begin() noexcept {
    return c.begin();
  }
  iterator end() noexcept {
    return c.end();
  }
  const_iterator begin() const noexcept {
    return c.begin();
  }
  const_iterator end() const noexcept {
    return c.end();
  }
  const_iterator cbegin() const noexcept {
    return begin();
  }
  const_iterator cend() const noexcept {
    return end();
  }

  size_type max_size() const noexcept {
    return c.max_size();
  }
  size_type size() const noexcept {
    return c.size();
  }
  bool empty() const noexcept {
    return c.empty();
  }  

  flat_multimap() = default;
  ~flat_multimap() = default;
  flat_multimap(const flat_multimap &) = default;
  flat_multimap &operator =(const flat_multimap &) = default;
  flat_multimap(flat_multimap &&) = default;
  flat_multimap &operator =(flat_multimap &&) = default;
  friend void swap(flat_multimap &x, flat_multimap &y)
    noexcept(is_nothrow_swappable_v<CONTAINER>
             && is_nothrow_swappable_v<LESS>) {
    adl_swap(x.c, y.c);
    adl_swap(x.less_ref(), y.less_ref());
  }

  // optional container operations

  // reversible container

  using reverse_iterator = re::reverse_iterator<iterator>;
  using const_reverse_iterator = re::reverse_iterator<const_iterator>;

  reverse_iterator rbegin() noexcept {
    return reverse_iterator(end());
  }
  reverse_iterator rend() noexcept {
    return reverse_iterator(begin());
  }
  const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator(begin());
  }
  const_reverse_iterator crbegin() const noexcept {
    return rbegin();
  }
  const_reverse_iterator crend() const noexcept {
    return rend();
  }

  // allocator-aware container

  auto get_allocator() const noexcept
    ->decltype(declval<const CONTAINER &>().get_allocator()) {
    return c.get_allocator();
  }

  template <class ALLOC,
            class = enable_if_t<uses_allocator_v<CONTAINER, ALLOC>>>
  explicit flat_multimap(const ALLOC &a) : c(a) {}
  template <class ALLOC,
            class = enable_if_t<uses_allocator_v<CONTAINER, ALLOC>>>
  flat_multimap(const flat_multimap &x, const ALLOC &a)
    : less_wrapper(x.less_ref()), c(x.c, a) {}
  template <class ALLOC,
            class = enable_if_t<uses_allocator_v<CONTAINER, ALLOC>>>
  flat_multimap(flat_multimap &&x, const ALLOC &a)
    : less_wrapper(move(x.less_ref())), c(move(x.c), a) {}

  // associative container

  using key_type = KEY;
  using mapped_type = MAPPED;
  using key_compare = LESS;
  class value_compare {
    friend class flat_multimap;

    LESS l;
    explicit value_compare(const LESS &x) : l(x) {}

  public:
    value_compare() = delete;
    ~value_compare() = default;
    value_compare(const value_compare &) = default;
    value_compare &operator =(const value_compare &) = default;
    value_compare(value_compare &&) = default;
    value_compare &operator =(value_compare &&) = default;
    friend void swap(value_compare &x, value_compare &y)
      noexcept(is_nothrow_swappable_v<LESS>) {
      adl_swap(x.l, y.l);
    }

    bool operator ()(const value_type &x, const value_type &y) const {
      return l(x.first, y.first);
    }
  };
  LESS key_comp() const {
    return less_ref();
  }
  value_compare value_comp() const {
    return value_compare(less_ref());
  }

  explicit flat_multimap(const LESS &l) : less_wrapper(l) {}
  template <class ALLOC,
            class = enable_if_t<uses_allocator_v<CONTAINER, ALLOC>>>
  flat_multimap(const LESS &l, const ALLOC &a)
    : less_wrapper(l), c(a) {}

  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  flat_multimap(IITR first, IITR last, const LESS &l = LESS{})
    : less_wrapper(l), c(first, last) {
    sort_c();
  }
  template <class IITR, class ALLOC,
            class = enable_if_t<is_itr<IITR>
                                && uses_allocator_v<CONTAINER, ALLOC>>>
  flat_multimap(IITR first, IITR last, const ALLOC &a) : c(first, last, a) {
    sort_c();
  }
  template <class IITR, class ALLOC,
            class = enable_if_t<is_itr<IITR>
                                && uses_allocator_v<CONTAINER, ALLOC>>>
  flat_multimap(IITR first, IITR last,
                const LESS &l = LESS{}, const ALLOC &a = ALLOC())
    : less_wrapper(l), c(first, last, a) {
    sort_c();
  }
  template <class IITR>
  enable_if_t<is_itr<IITR>> assign(IITR from, IITR to) {
    c.assign(from, to);
    sort_c();
  }

  flat_multimap(initializer_list<value_type> il, const LESS &l = LESS{})
    : less_wrapper(l), c(il) {
    sort_c();
  }
  template <class ALLOC,
            class = enable_if_t<uses_allocator_v<CONTAINER, ALLOC>>>
  flat_multimap(initializer_list<value_type> il, const ALLOC &alloc)
    : c(il, alloc) {
    sort_c();
  }
  template <class ALLOC,
            class = enable_if_t<uses_allocator_v<CONTAINER, ALLOC>>>
  flat_multimap(initializer_list<value_type> il,
                const LESS &l, const ALLOC &alloc)
    : less_wrapper(l), c(il, alloc) {
    sort_c();
  }
  flat_multimap &operator =(initializer_list<value_type> il) {
    c = il;
    sort_c();
    return *this;
  }
  void assign(initializer_list<value_type> il) {
    c.assign(il);
    sort_c();
  }

private:
  template <class...S>
  value_type make_value(S &&...s) {
    return value_type(forward<S>(s)...);
  }
  template <class...S>
  value_type make_value(S &&...s)
    requires (requires {typename CONTAINER::allocator_type;}) {
    return value_type
      (move(*allocator_wrapper<typename CONTAINER::allocator_type>
            (c.get_allocator()).make_temporary(forward<S>(s)...)));
  }
  template <class X>
  iterator insert_impl(X &&x) {
    return c.insert(upper_bound(x.first), forward<X>(x));
  }
  template <class X>
  iterator insert_impl(const_iterator hint, X &&x) {
    if (c.empty())
      return c.insert(c.end(), forward<X>(x));
    else if (hint == c.end()) {
      if (!value_less(x, *prev(hint)))
        return c.insert(hint, forward<X>(x));
    }
    else if (hint == c.begin()) {
      if (!value_less(*hint, x))
        return c.insert(hint, forward<X>(x));
    }
    else if (!value_less(x, *prev(hint)) && !value_less(*hint, x))
      return c.insert(hint, forward<X>(x));

    return insert(forward<X>(x));
  }
public:
  template <class...S>
  iterator emplace(S &&...s) {
    return insert_impl(make_value(forward<S>(s)...));
  }
  template <class...S>
  iterator emplace_hint(const_iterator hint, S &&...s) {
    return insert_impl(hint, make_value(forward<S>(s)...));
  }
  iterator insert(const value_type &x) {
    return insert_impl(x);
  }
  iterator insert(value_type &&x) {
    return insert_impl(move(x));
  }
  iterator insert(const_iterator hint, const value_type &x) {
    return insert_impl(hint, x);
  }
  iterator insert(const_iterator hint, value_type &&x) {
    return insert_impl(hint, move(x));
  }
  template <class IITR>
  void insert(IITR first, IITR last) {
    insert_range(rng(first, last));
  }
  void insert(initializer_list<value_type> il) {
    insert_range(il);
  }

  iterator erase(const_iterator pos) {
    return c.erase(pos);
  }
  iterator erase(const_iterator first, const_iterator last) {
    return c.erase(first, last);
  }
  void clear() noexcept {
    c.clear();
  }

  size_type erase(const key_type &key) {
    const auto r = equal_range(key);
    const size_type ret = size(r);
    c.erase(begin(r), end(r));
    return ret;
  }
  template <class K, class X = LESS, class = typename X::is_transparent,
            class = enable_if_t<!is_convertible_v<K &&, iterator>
                                && !is_convertible_v<K &&, const_iterator>>>
  size_type erase(K &&key) {
    const auto r = equal_range(key);
    const size_type ret = size(r);
    c.erase(begin(r), end(r));
    return ret;
  }

  size_type remove(const key_type &key) {
    const auto r = equal_range(key);
    const size_type ret = size(r);
    c.erase(begin(r), end(r));
    return ret;
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  size_type remove(const K &key) {
    const auto r = equal_range(key);
    const size_type ret = size(r);
    c.erase(begin(r), end(r));
    return ret;
  }
  template <class UF>
  size_type remove_if(UF eq) {
    size_type ret = 0;
    for (iterator it = begin(); it != end();) {
      if (eq(*it)) {
        it = erase(it);
        ++ret;
      }
      else
        ++it;
    }
    return ret;
  }

  iterator find(const key_type &key) {
    const auto i = lower_bound(key);
    const auto ed = end();
    return (i != ed && !less(key, i->first)) ? i : ed;
  }
  const_iterator find(const key_type &key) const {
    const auto i = lower_bound(key);
    const auto ed = end();
    return (i != ed && !less(key, i->first)) ? i : ed;
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  iterator find(const K &key) {
    const auto i = lower_bound(key);
    const auto ed = end();
    return (i != ed && !less(key, i->first)) ? i : ed;
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  const_iterator find(const K &key) const {
    const auto i = lower_bound(key);
    const auto ed = end();
    return (i != ed && !less(key, i->first)) ? i : ed;
  }

  template <class K, class X = LESS, class = typename X::is_transparent>
  bool contains(const K &key) const {
    return find(key) != end();
  }
  bool contains(const key_type &key) const {
    return find(key) != end();
  }

  size_type count(const key_type &key) const {
    return equal_range(key).size();
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  size_type count(const K &key) const {
    return equal_range(key).size();
  }

  iterator lower_bound(const key_type &key) {
    return re::lower_bound(bind_rng(c, re::at<0>), key, less_fn()).base();
  }
  const_iterator lower_bound(const key_type &key) const {
    return re::lower_bound(bind_rng(c, re::at<0>), key, less_fn()).base();
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  iterator lower_bound(const K &key) {
    return re::lower_bound(bind_rng(c, re::at<0>), key, less_fn()).base();
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  const_iterator lower_bound(const K &key) const {
    return re::lower_bound(bind_rng(c, re::at<0>), key, less_fn()).base();
  }

  iterator upper_bound(const key_type &key) {
    return re::upper_bound(bind_rng(c, re::at<0>), key, less_fn()).base();
  }
  const_iterator upper_bound(const key_type &key) const {
    return re::upper_bound(bind_rng(c, re::at<0>), key, less_fn()).base();
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  iterator upper_bound(const K &key) {
    return re::upper_bound(bind_rng(c, re::at<0>), key, less_fn()).base();
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  const_iterator upper_bound(const K &key) const {
    return re::upper_bound(bind_rng(c, re::at<0>), key, less_fn()).base();
  }

  iter_pair<iterator> equal_range(const key_type &key) {
    return rng(base_rng
               (re::equal_range(bind_rng(c, re::at<0>), key, less_fn())));
  }
  iter_pair<const_iterator> equal_range(const key_type &key) const {
    return rng(base_rng
               (re::equal_range(bind_rng(c, re::at<0>), key, less_fn())));
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  iter_pair<iterator> equal_range(const K &key) {
    return rng(base_rng
               (re::equal_range(bind_rng(c, re::at<0>), key, less_fn())));
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  iter_pair<const_iterator> equal_range(const K &key) const {
    return rng(base_rng
               (re::equal_range(bind_rng(c, re::at<0>), key, less_fn())));
  }

  // extensions

  iter_pair<iterator> find_range(const key_type &key,
                                 const key_type &key2) {
    return {lower_bound(key), upper_bound(key2)};
  }
  iter_pair<const_iterator> find_range(const key_type &key,
                                       const key_type &key2) const {
    return {lower_bound(key), upper_bound(key2)};
  }
  template <class K, class K2,
            class X = LESS, class = typename X::is_transparent>
  iter_pair<iterator> find_range(const K &key, const K2 &key2) {
    return {lower_bound(key), upper_bound(key2)};
  }
  template <class K, class K2,
            class X = LESS, class = typename X::is_transparent>
  iter_pair<const_iterator>
  find_range(const K &key, const K2 &key2) const {
    return {lower_bound(key), upper_bound(key2)};
  }

  reference front() {
    return c.front();
  }
  const_reference front() const {
    return c.front();
  }
  reference back() {
    return c.back();
  }
  const_reference back() const {
    return c.back();
  }

  template <class RANGE>
  void merge(RANGE &&r) requires (!is_convertible_v<RANGE &&, this_t &&>) {
    this_t tmp(move(*this));
    clear();
    re::merge(move_rng(tmp), r, back_inserter(c),
              [&](const auto &x, const auto &y) {
                return less_ref()(x.first, y.first);
              });
  }
  void merge(this_t &&x) {
    this_t tmp(move(*this));
    clear();
    re::merge(move_rng(tmp), move_rng(x), back_inserter(c), value_less_fn());
    x.clear();
  }

  void unique() {
    c.erase(re::unique(*this, not_fn(value_comp())), c.end());
  }
  template <class EQL>
  void unique(EQL eql) {
    c.erase(re::unique(*this, eql), c.end());
  }

  void reserve(size_type n) {
    c.reserve(n);
  }
  size_type capacity() const noexcept {
    return c.capacity();
  }
  void shrink_to_fit() {
    c.shrink_to_fit();
  }

private:
  void sort_c() {
#ifndef RE_NOEXCEPT
    try {
#endif
      stable_sort(c, value_less_fn());
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      clear();
      throw;
    }
#endif
  }
public:
  template <class R, class = enable_if_t
            <is_rng<R> && is_constructible_v<value_type, rng_ref<R>>>>
  flat_multimap(from_range_t, R &&r, const LESS &l = LESS{})
    : less_wrapper(l), c(from_range, r) {
    sort_c();
  }
  template <class R, class ALLOC, class = enable_if_t
            <is_rng<R> && is_constructible_v<value_type, rng_ref<R>>
             && uses_allocator_v<CONTAINER, ALLOC>>>
  flat_multimap(from_range_t, R &&r, const LESS &l, const ALLOC &a)
    : less_wrapper(l), c(from_range, r, a) {
    sort_c();
  }
  template <class R, class ALLOC, class = enable_if_t
            <is_rng<R> && is_constructible_v<value_type, rng_ref<R>>
             && uses_allocator_v<CONTAINER, ALLOC>>>
  flat_multimap(from_range_t, R &&r, const ALLOC &a)
    : c(from_range, r, a) {
    sort_c();
  }
  template <class IITR_RANGE, class = enable_if_t
            <((is_rng<IITR_RANGE>
               && is_constructible_v<value_type, rng_ref<IITR_RANGE>>))
             && !is_same_v<decay_t<IITR_RANGE>, this_t>
             && !is_convertible_v<IITR_RANGE &&, const LESS &>
             && !uses_allocator_v<CONTAINER, IITR_RANGE &&>>>
  explicit flat_multimap(IITR_RANGE &&r) : c(r) {
    sort_c();
  }
  template <class IITR_RANGE, class = enable_if_t
            <((is_rng<IITR_RANGE>
               && is_constructible_v<value_type, rng_ref<IITR_RANGE>>))
             && !is_same_v<decay_t<IITR_RANGE>, this_t>
             && !is_convertible_v<IITR_RANGE &&, const LESS &>>>
  flat_multimap(IITR_RANGE &&r, const LESS &l)
    : less_wrapper(l), c(r) {
    sort_c();
  }
  template <class IITR_RANGE, class ALLOC, class = enable_if_t
            <((is_rng<IITR_RANGE>
               && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
               && uses_allocator_v<CONTAINER, ALLOC>))
             && !is_same_v<decay_t<IITR_RANGE>, this_t>
             && !is_convertible_v<IITR_RANGE &&, const LESS &>>>
  flat_multimap(IITR_RANGE &&r, const ALLOC &a) : c(r, a) {
    sort_c();
  }
  template <class IITR_RANGE, class ALLOC, class = enable_if_t
            <((is_rng<IITR_RANGE>
               && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
               && uses_allocator_v<CONTAINER, ALLOC>))
             && !is_same_v<decay_t<IITR_RANGE>, this_t>
             && !is_convertible_v<IITR_RANGE &&, const LESS &>>>
  flat_multimap(IITR_RANGE &&r, const LESS &l, const ALLOC &a)
    : less_wrapper(l), c(r, a) {
    sort_c();
  }
  template <class IITR_RANGE>
  enable_if_t<is_rng<IITR_RANGE>
              && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
              && is_assignable_v<value_type &, rng_ref<IITR_RANGE>>
              && !is_same_v<decay_t<IITR_RANGE>, this_t>,
              this_t &>
  operator =(IITR_RANGE &&r) {
    assign_range(r);
    return *this;
  }
  template <class IITR_RANGE>
  void assign_range(IITR_RANGE &&r) {
    c.assign_range(r);
    sort_c();
  }
  template <class IITR_RANGE>
  void assign(IITR_RANGE &&r) {
    assign_range(r);
  }

  template <class IITR_RANGE>
  enable_if_t<!is_convertible_v<IITR_RANGE &&, value_type &&>
              && !is_convertible_v<IITR_RANGE &&, const value_type &>>
  insert(IITR_RANGE &&r) {
    insert_range(r);
  }
  template <class IITR_RANGE>
  void insert_range(IITR_RANGE &&r) {
    for (auto &i : iters(r))
      emplace(*i);
  }

  this_t &append() {
    return *this;
  }
  template <class X, class...S>
  this_t &append(X &&x, S &&...s) {
    insert(forward<X>(x));
    return append(forward<S>(s)...);
  }
};
template <class A, class B, class C, class D>
bool operator ==(const flat_multimap<A, B, C, D> &x,
                 const flat_multimap<A, B, C, D> &y) {
  return equal(x, y);
}
template <class A, class B, class C, class D>
synth_3way_result<pair<A, B>>
operator <=>(const flat_multimap<A, B, C, D> &x,
             const flat_multimap<A, B, C, D> &y) {
  return lexicographical_synth_3way(x, y);
}

}

// rbtree_adaptor
namespace re {

// red-black tree
//   0) root is black
//   1) red or black
//   2) nil is black
//   3) no double red
//   4) every two ways from a node to nil have the same amount of black nodes

// rotate_left
//     *                   *
//   ?   *       ->      *   ?
//      ? ?             ? ?
// rotate_right
//     *                   *
//   *   ?       ->      ?   *
//  ? ?                     ? ?
// rotate_right_left
//      *                  *
//   ?     *     ->     *     *
//       *   ?         ? ?   ? ?
//      ? ?
// rotate_left_right
//      *                  *
//   *     ?     ->     *     *
// ?   *               ? ?   ? ?
//    ? ?

template <size_t ID = 0, class VOID_PTR = void *>
struct rbt_node_base {
  pointer_rebind_t<VOID_PTR, rbt_node_base> left_child;
  pointer_rebind_t<VOID_PTR, rbt_node_base> right_child;
  pointer_rebind_t<VOID_PTR, rbt_node_base> parent;
};
template <size_t ID = 0, class VOID_PTR = void *>
struct join_rbtree : rbt_node_base<ID, VOID_PTR> {
  bool red;
};
template <class T, class VOID_PTR = void *>
struct rbtree_node : join_rbtree<0, VOID_PTR> {
  alignas(T) byte data[sizeof(T)];

  T &operator *() const {
    return *reinterpret_cast<T *>(addressof(data));
  }
  T *operator ->() const {
    return reinterpret_cast<T *>(addressof(data));
  }
};
namespace inner {

template <class NODE_BASE_TYPE, class SIZE_TYPE, bool STORE>
struct rbtree_header_data {
  mutable NODE_BASE_TYPE ed;
  SIZE_TYPE sz;
};
template <class NODE_BASE_TYPE, class SIZE_TYPE>
struct rbtree_header_data<NODE_BASE_TYPE, SIZE_TYPE, false> {
  mutable NODE_BASE_TYPE ed;
};

}

template <class NODE_T, size_t ID = 0,
          bool STORE_SIZE = true, bool STORE_NODE_ALLOCATOR = false,
          class AL = default_allocator<NODE_T>>
struct rbtree_traits {
  using value_type = alloc_vt<AL>;
  using allocator_type = AL;
  using node_type = NODE_T;
  using node_pointer = alloc_rebind_ptr<AL, node_type>;
  using node_base_type = rbt_node_base<ID, alloc_void_ptr<AL>>;
  using node_base_pointer = alloc_rebind_ptr<AL, node_base_type>;
  using difference_type = alloc_dft<AL>;
  using size_type = alloc_szt<AL>;

  using id = size_constant<ID>;
  using store_size = bool_constant<STORE_SIZE>;
  using store_node_allocator = bool_constant<STORE_NODE_ALLOCATOR>;
  using store_allocator = bool_constant<STORE_NODE_ALLOCATOR>;

  static node_base_pointer left_child(node_base_pointer p) {
    return p->left_child;
  }
  static void left_child(node_base_pointer p, node_base_pointer p2) {
    p->left_child = p2;
  }

  static node_base_pointer right_child(node_base_pointer p) {
    return p->right_child;
  }
  static void right_child(node_base_pointer p, node_base_pointer p2) {
    p->right_child = p2;
  }

  static node_base_pointer parent(node_base_pointer p) {
    return p->parent;
  }
  static void parent(node_base_pointer p, node_base_pointer p2) {
    p->parent = p2;
  }

  static bool red(node_base_pointer p) {
    return static_cast<join_rbtree<ID, alloc_void_ptr<AL>> &>(*p).red;
  }
  static void red(node_base_pointer p, bool y) {
    static_cast<join_rbtree<ID, alloc_void_ptr<AL>> &>(*p).red = y;
  }

  template <class VT = value_type>
  static enable_if_t<!is_same_v<VT, node_type>, value_type *>
  data(node_base_pointer p) {
    return reinterpret_cast<value_type *>
      (addressof(static_cast<node_type &>(*p).data));
  }
  template <class VT = value_type>
  static enable_if_t<is_same_v<VT, node_type>, value_type *>
  data(node_base_pointer p) {
    return to_address(static_cast<node_pointer>(p));
  }

  using header_type = inner::rbtree_header_data
    <node_base_type, size_type, store_size::value>;
  static node_base_pointer end_node(const header_type &h) {
    return pointer_to<node_base_pointer>(static_cast<node_base_type &>(h.ed));
  }
  template <bool Y = store_size::value>
  static enable_if_t<Y, size_type> size(const header_type &h) {
    return h.sz;
  }
  template <bool Y = store_size::value>
  static enable_if_t<Y> size(header_type &h, size_type n) {
    h.sz = n;
  }

  template <class...S, class VT = value_type>
  static enable_if_t<!is_same_v<VT, node_type>, node_base_pointer>
  new_node(AL &al, S &&...s) {
    return allocator_wrapper<AL>(al)
      .template new_node<node_type>(forward<S>(s)...);
  }
  template <class VT = value_type>
  static enable_if_t<!is_same_v<VT, node_type>>
  delete_node(AL &al, node_base_pointer p) noexcept {
    allocator_wrapper<AL>(al).delete_node(static_cast<node_pointer>(p));
  }

  template <class...S, class VT = value_type>
  static enable_if_t<is_same_v<VT, node_type>, node_base_pointer>
  new_node(AL &al, S &&...s) {
    return static_cast<node_base_pointer>
      (allocator_wrapper<AL>(al).new_1(forward<S>(s)...));
  }
  template <class VT = value_type>
  static enable_if_t<is_same_v<VT, node_type>>
  delete_node(AL &al, node_base_pointer p) noexcept {
    allocator_wrapper<AL>(al).delete_1(static_cast<node_pointer>(p));
  }
};

template <class>
class rbtree_adaptor;
template <class>
class avltree_adaptor;
namespace inner {

struct bst_helper;
template <class T, class TRAITS>
class bst_iterator {
  static_assert(is_same_v<remove_const_t<T>, typename TRAITS::value_type>);

  using this_t = bst_iterator;

  template <class, class>
  friend class bst_iterator;

public:
  using node_pointer = typename TRAITS::node_base_pointer;
private:
  node_pointer p{};

public:
  using value_type = remove_const_t<T>;
  using pointer = T *;
  using reference = T &;
  using difference_type = typename TRAITS::difference_type;
  using iterator_category = bidirectional_iterator_tag;

  bst_iterator() = default;
  bst_iterator(const this_t &) = default;
  bst_iterator &operator =(const this_t &) = default;
  bst_iterator(this_t &&) = default;
  bst_iterator &operator =(this_t &&) = default;
  friend void swap(this_t &x, this_t &y) noexcept {
    adl_swap(x.p, y.p);
  }

  template <class TT = T, class = enable_if_t<is_const_v<TT>>>
  bst_iterator(bst_iterator<remove_const_t<TT>, TRAITS> it) : p(it.p) {}
  template <class TT = T, class = enable_if_t<is_const_v<TT>>>
  this_t &operator =(bst_iterator<remove_const_t<TT>, TRAITS> it) {
    p = it.p;
    return *this;
  }

  explicit bst_iterator(node_pointer p) : p(p) {}
  node_pointer node() const {
    return p;
  }
  auto to_mutable() const requires is_const_v<T> {
    return bst_iterator<remove_const_t<T>, TRAITS>(p);
  }

private:
  template <class>
  friend class re::rbtree_adaptor;
  template <class>
  friend class re::avltree_adaptor;
  friend struct re::inner::bst_helper;

  this_t left_child() const {
    return this_t(TRAITS::left_child(p));
  }
  void left_child(bst_iterator<add_const_t<T>, TRAITS> p2) const {
    TRAITS::left_child(p, p2.node());
  }
  this_t right_child() const {
    return this_t(TRAITS::right_child(p));
  }
  void right_child(bst_iterator<add_const_t<T>, TRAITS> p2) const {
    TRAITS::right_child(p, p2.node());
  }
  this_t parent() const {
    return this_t(TRAITS::parent(p));
  }
  void parent(bst_iterator<add_const_t<T>, TRAITS> p2) const {
    TRAITS::parent(p, p2.node());
  }
  bool red() const {
    return TRAITS::red(p);
  }
  void red(bool y) const {
    TRAITS::red(p, y);
  }
  int factor() const {
    return TRAITS::factor(p);
  }
  void factor(int f) const {
    TRAITS::factor(p, f);
  }

  void rotate_left(this_t b) const {
    const auto &a = *this;

    const auto b_l = b.left_child();
    if (b_l != nullptr)
      b_l.parent(a);
    a.right_child(b_l);

    const auto a_p = a.parent();
    a_p.right_child() == a ? a_p.right_child(b) : a_p.left_child(b);
    b.parent(a_p);

    b.left_child(a);
    a.parent(b);
  }
  void rotate_right(this_t b) const {
    const auto &a = *this;

    const auto b_r = b.right_child();
    if (b_r != nullptr)
      b_r.parent(a);
    a.left_child(b_r);

    const auto a_p = a.parent();
    a_p.right_child() == a ? a_p.right_child(b) : a_p.left_child(b);
    b.parent(a_p);

    b.right_child(a);
    a.parent(b);
  }
  void rotate_right_left(this_t b, this_t c) const {
    const auto &a = *this;
    const auto a_p = a.parent();
    const auto c_l = c.left_child();
    const auto c_r = c.right_child();

    a_p.right_child() == a ? a_p.right_child(c) : a_p.left_child(c);
    c.parent(a_p);

    a.right_child(c_l);
    if (c_l != nullptr)
      c_l.parent(a);

    b.left_child(c_r);
    if (c_r != nullptr)
      c_r.parent(b);

    c.left_child(a);
    a.parent(c);

    c.right_child(b);
    b.parent(c);
  }
  void rotate_left_right(this_t b, this_t c) const {
    const auto &a = *this;
    const auto a_p = a.parent();
    const auto c_l = c.left_child();
    const auto c_r = c.right_child();

    a_p.right_child() == a ? a_p.right_child(c) : a_p.left_child(c);
    c.parent(a_p);

    a.left_child(c_r);
    if (c_r != nullptr)
      c_r.parent(a);

    b.right_child(c_l);
    if (c_l != nullptr)
      c_l.parent(b);

    c.right_child(a);
    a.parent(c);

    c.left_child(b);
    b.parent(c);
  }

  void calc_max_depth(typename TRAITS::size_type &result,
                      typename TRAITS::size_type now = 1) const {
    if (p == nullptr)
      return;
    if (now > result)
      result = now;
    left_child().calc_max_depth(result, now + 1);
    right_child().calc_max_depth(result, now + 1);
  }
  void calc_min_depth(typename TRAITS::size_type &result,
                      typename TRAITS::size_type now = 0) const {
    if (p == nullptr) {
      if (result == 0u)
        result = now;
      else if (now < result)
        result = now;
      return;
    }
    left_child().calc_min_depth(result, now + 1);
    right_child().calc_min_depth(result, now + 1);
  }

  typename TRAITS::size_type max_depth() const {
    typename TRAITS::size_type result = 0;
    calc_max_depth(result);
    return result;
  }
  typename TRAITS::size_type min_depth() const {
    typename TRAITS::size_type result = 0;
    calc_min_depth(result);
    return result;
  }

public:
  reference operator *() const {
    return *TRAITS::data(p);
  }
  pointer operator ->() const {
    return TRAITS::data(p);
  }

  this_t &operator ++() {
    if (right_child() != nullptr) {
      *this = right_child();
      while (left_child() != nullptr)
        *this = left_child();
    }
    else {
      while (*this == parent().right_child())
        *this = parent();
      if (*this == parent().left_child())
        *this = parent();
    }
    return *this;
  }
  this_t operator ++(int) {
    return iter_post_increment(*this);
  }

  this_t &operator --() {
    if (left_child() != nullptr) {
      *this = left_child();
      while (right_child() != nullptr)
        *this = right_child();
    }
    else {
      while (*this == parent().left_child())
        *this = parent();
      *this = parent();
    }
    return *this;
  }
  this_t operator --(int) {
    return iter_post_decrement(*this);
  }
};
template <class A, class AA, class B>
enable_if_t<is_same_v<remove_const_t<A>, remove_const_t<AA>>, bool>
operator ==(bst_iterator<A, B> x, bst_iterator<AA, B> y) {
  return x.node() == y.node();
}
template <class A, class B>
bool operator ==(bst_iterator<A, B> x, nullptr_t) {
  return x.node() == nullptr;
}

template <class TRAITS>
class set_node_handle : node_handle<TRAITS> {
  using base_t = node_handle<TRAITS>;

public:
  using base_t::allocator_type;

  set_node_handle() noexcept = default;
  set_node_handle(const set_node_handle &) = delete;
  set_node_handle &operator =(const set_node_handle &) = delete;
  set_node_handle(set_node_handle &&) noexcept = default;
  set_node_handle &operator =(set_node_handle &&) = default;
  friend void swap(set_node_handle &x, set_node_handle &y)
    noexcept(is_nothrow_swappable_v<base_t>) {
    adl_swap(static_cast<base_t &>(x), static_cast<base_t &>(y));
  }

  explicit set_node_handle(typename base_t::node_pointer p,
                           const typename base_t::alloc_t &al)
    : base_t(p, al) {}

  using base_t::get_allocator;
  using base_t::empty;
  using base_t::operator bool;
  using base_t::get;
  using base_t::release;
  using base_t::operator *;

  using value_type = typename TRAITS::value_type;
  value_type &value() const {
    return *TRAITS::data(base_t::p);
  }
};

template <class TRAITS>
class map_node_handle : node_handle<TRAITS> {
  using base_t = node_handle<TRAITS>;

public:
  using base_t::allocator_type;

  map_node_handle() noexcept = default;
  map_node_handle(const map_node_handle &) = delete;
  map_node_handle &operator =(const map_node_handle &) = delete;
  map_node_handle(map_node_handle &&) noexcept = default;
  map_node_handle &operator =(map_node_handle &&) = default;
  friend void swap(map_node_handle &x, map_node_handle &y)
    noexcept(is_nothrow_swappable_v<base_t>) {
    adl_swap(static_cast<base_t &>(x), static_cast<base_t &>(y));
  }

  explicit map_node_handle(typename base_t::node_pointer p,
                           const typename base_t::alloc_t &al)
    : base_t(p, al) {}

  using base_t::get_allocator;
  using base_t::empty;
  using base_t::operator bool;
  using base_t::get;
  using base_t::release;
  using base_t::operator *;

  using key_type = typename TRAITS::value_type::first_type;
  using mapped_type = typename TRAITS::value_type::second_type;
  key_type &key() const {
    return TRAITS::data(base_t::p)->first;
  }
  mapped_type &mapped() const {
    return TRAITS::data(base_t::p)->second;
  }
};

template <class IT, class NODE>
struct node_handle_insert_return_type {
  IT position;
  bool inserted;
  NODE node;
};

struct bst_helper {
  template <class C_ITER, class DF>
  static void delete_bst_node_recursively(C_ITER it, DF delete_node) {
    if (it != nullptr) {
      C_ITER l = it;
      while (l.left_child() != nullptr)
        l = l.left_child();
      for (;;) {
        if (l != it) {
          if (l.right_child() != nullptr) {
            l.parent().left_child(l.right_child());
            l.right_child().parent(l.parent());
            delete_node(exchange(l, l.right_child()));
            while (l.left_child() != nullptr)
              l = l.left_child();
          }
          else {
            l.parent().left_child(C_ITER{});
            delete_node(exchange(l, l.parent()));
          }
        }
        else {
          it = l.right_child();
          delete_node(exchange(l, it));
          if (l == nullptr)
            break;
          while (l.left_child() != nullptr)
            l = l.left_child();
        }
      }
    }
  }
  template <class ITER_T>
  static void link_bst_to_forward_list(ITER_T before_begin, ITER_T it) {
    if (it != nullptr) {
      link_bst_to_forward_list(before_begin, it.left_child());
      link_bst_to_forward_list(before_begin, it.right_child());
      forward_list_fns([](ITER_T it) {return it.right_child();},
                       [](ITER_T it, ITER_T x) {it.right_child(x);})
        .link_after(before_begin, it);
    }
  }

  template <class THIS_T0, class THIS_T, class GET_VAL>
  static void bst_clone_data_impl(THIS_T0 &s0, THIS_T &s,
                                  GET_VAL get_val) {
    s0.new_data();
    auto it = s.begin();
    const auto ed = s.end();
    if (it != ed) {
      s0.insert_to_null(s0.new_node(get_val(*it)));
      for (++it; it != ed; ++it) {
        const auto tmp = s0.new_node(get_val(*it));
        s0.insert_right(tmp, s0.rightmost());
        s0.rightmost(tmp);
      }
    }
  }
  template <class THIS_T0, class THIS_T, class GET_VAL>
  static void bst_assign_data_impl(THIS_T0 &s0, THIS_T &s,
                                   GET_VAL get_val) {
    using iter_t = typename THIS_T0::iterator;
    using s_iter_t = rng_itr<THIS_T>;

    typename THIS_T0::traits::header_type h;
    iter_t fwd_l(THIS_T0::traits::end_node(h));
    fwd_l.right_child(iter_t{});
    inner::bst_helper::link_bst_to_forward_list(fwd_l, s0.root());
    const auto guard = exit_fn([fwd_l, &s0]() {
      for_each_node(rng(fwd_l.right_child(), iter_t{}),
                    [](iter_t it) {return it.right_child();},
                    [&s0](iter_t it) {s0.delete_node(it);});
    });
    const auto get_node = [fwd_l, get_val, &s0](s_iter_t i) {
      if (fwd_l.right_child() == nullptr)
        return s0.new_node(get_val(*i));
      else {
        const iter_t tmp = fwd_l.right_child();
        *tmp = get_val(*i);
        fwd_l.right_child(tmp.right_child());
        return tmp;
      }
    };

    s0.new_data();
    s_iter_t it = s.begin();
    const s_iter_t ed = s.end();
    if (it != ed) {
      s0.insert_to_null(get_node(it));
      for (++it; it != ed; ++it) {
        const iter_t tmp = get_node(it);
        s0.insert_right(tmp, s0.rightmost());
        s0.rightmost(tmp);
      }
    }
  }
};

}
template <class TRAITS>
class rbtree_adaptor
  : TRAITS::header_type
  , conditional_t<!TRAITS::store_node_allocator::value,
                  inner::empty_type, typename TRAITS::allocator_type> {
  using this_t = rbtree_adaptor;

  using data_t = typename TRAITS::header_type;
  data_t &data_ref() {
    return static_cast<data_t &>(*this);
  }
  const data_t &data_ref() const {
    return static_cast<const data_t &>(*this);
  }

  using alloc_t = conditional_t<!TRAITS::store_node_allocator::value,
                                inner::empty_type,
                                typename TRAITS::allocator_type>;

  template <class R>
  static auto begin(R &&r) {return re::begin(r);}
  template <class R>
  static auto end(R &&r) {return re::end(r);}
  template <class R>
  static auto rbegin(R &&r) {return re::rbegin(r);}
  template <class R>
  static auto rend(R &&r) {return re::rend(r);}
  template <class R>
  static auto size(R &&r) {return re::size(r);}
  template <class R>
  static auto empty(R &&r) {return re::empty(r);}

public:

  using traits = TRAITS;
  using node_pointer = typename traits::node_base_pointer;

  // container

  using value_type = typename traits::value_type;
  using reference = value_type &;
  using const_reference = const value_type &;

  using iterator = inner::bst_iterator<value_type, traits>;
  using const_iterator = inner::bst_iterator<const value_type, traits>;
  using difference_type = typename traits::difference_type;
  using size_type = typename traits::size_type;

  iterator begin() noexcept {
    return leftmost();
  }
  iterator end() noexcept {
    return iterator(traits::end_node(data_ref()));
  }
  const_iterator begin() const noexcept {
    return leftmost();
  }
  const_iterator end() const noexcept {
    return const_iterator(traits::end_node(data_ref()));
  }
  const_iterator cbegin() const noexcept {
    return begin();
  }
  const_iterator cend() const noexcept {
    return end();
  }

  size_type max_size() const noexcept {
    return container_regular_max_size<this_t>();
  }
  template <bool Y = traits::store_size::value>
  enable_if_t<Y, size_type> size() const noexcept {
    return traits::size(data_ref());
  }
  bool empty() const noexcept {
    return root() == nullptr;
  }

  // node operations

  template <class...S>
  iterator new_node(S &&...s) {
    return iterator(traits::new_node(alloc_ref(), forward<S>(s)...));
  }
  void delete_node(const_iterator it) noexcept {
    traits::delete_node(alloc_ref(), it.node());
  }
  void delete_tree(const_iterator it) noexcept {
    inner::bst_helper::delete_bst_node_recursively
      (it, [&](auto i) {delete_node(i);});
  }

  iterator root() const noexcept {
    return end().to_mutable().right_child();
  }
  iterator leftmost() const noexcept {
    return end().to_mutable().parent();
  }
  iterator rightmost() const noexcept {
    return end().to_mutable().left_child();
  }
private:
  // inner implements

  void root(iterator it) noexcept {
    end().right_child(it);
  }
  void leftmost(iterator it) noexcept {
    end().parent(it);
  }
  void rightmost(iterator it) noexcept {
    end().left_child(it);
  }

  template <bool Y = traits::store_size::value>
  enable_if_t<Y> set_size(size_type n) noexcept {
    traits::size(data_ref(), n);
  }
  template <bool Y = traits::store_size::value>
  enable_if_t<Y, size_type> get_size() const noexcept {
    return traits::size(data_ref());
  }

  template <bool Y = traits::store_size::value>
  enable_if_t<!Y> set_size(size_type) noexcept {}
  template <bool Y = traits::store_size::value>
  enable_if_t<!Y, size_type> get_size() const noexcept {
    return 0;
  }

  void relink(iterator root_node) noexcept {
    if (root_node == nullptr)
      new_data();
    else {
      root(root_node);
      root().parent(end());

      iterator it;
      for (it = root(); it.left_child() != nullptr;)
        it = it.left_child();
      leftmost(it);
      for (it = root(); it.right_child() != nullptr;)
        it = it.right_child();
      rightmost(it);
    }
  }
  void relink_end() noexcept {
    if (root() != nullptr)
      root().parent(end()); // relink root node with end node
    else {
      leftmost(end());
      rightmost(end());
    }
  }

  friend struct inner::bst_helper;

  friend class allocator_aware_container_ownership<this_t>;
  const alloc_t &alloc_ref() const noexcept {
    return static_cast<const alloc_t &>(*this);
  }
  alloc_t &alloc_ref() noexcept {
    return static_cast<alloc_t &>(*this);
  }
  void new_data() noexcept {
    leftmost(end());
    root(iterator{});
    rightmost(end());
    set_size(0);
  }
  void delete_data() noexcept {
    delete_tree(root());
  }
  void new_data(const this_t &x) {
    inner::bst_helper::bst_clone_data_impl(*this, x, identity{});
  }
  void assign_data(const this_t &x) {
    inner::bst_helper::bst_assign_data_impl(*this, x, identity{});
  }
  void new_data(this_t &&x) noexcept {
    data_ref() = move(x.data_ref());
    relink_end();
    x.new_data();
  }
  void new_data_individually(this_t &&x) {
    const auto guard = exit_fn([&]() {
      x.delete_data();
      x.new_data();
    });
    inner::bst_helper::bst_clone_data_impl(*this, x, move);
  }
  void assign_data_individually(this_t &&x) {
    const auto guard = exit_fn([&]() {
      x.delete_data();
      x.new_data();
    });
    inner::bst_helper::bst_assign_data_impl(*this, x, move);
  }
  void swap_data(this_t &x) noexcept {
    adl_swap(data_ref(), x.data_ref());
    relink_end();
    x.relink_end();
  }

  // ins_rebalance(new_it, it) requires:
  //   1) it != end(),
  //   2) it is the parent of new_it, it is red
  //   3) new_it is red
  //   4) every path except those via new_it conform to the rule of rbtree
  void ins_rebalance(iterator new_it, iterator it) noexcept {
    for (iterator p, u; it.red();) {
      p = it.parent(); // p is impossible to be end node

      if (it == p.right_child()) {
        u = p.left_child();
        if (u == nullptr || !u.red()) {
          if (new_it == it.left_child()) {
            p.rotate_right_left(it, new_it);
            new_it.red(false);
            p.red(true);
          }
          else {
            p.rotate_left(it);
            it.red(false);
            p.red(true);
          }
          return;
        }
      }
      else {
        u = p.right_child();
        if (u == nullptr || !u.red()) {
          if (new_it == it.right_child()) {
            p.rotate_left_right(it, new_it);
            new_it.red(false);
            p.red(true);
          }
          else {
            p.rotate_right(it);
            it.red(false);
            p.red(true);
          }
          return;
        }
      }

      it.red(false);
      u.red(false);
      if (p == root())
        return;
      p.red(true);
      new_it = p;
      it = p.parent();
    }
  }
  // del_rebalance(p, c) requires:
  //   1) p is the parent of c
  //   2) c is black (if c is red, just change it to black)
  //   3) the whole tree is legal except every path via c lost one black node
  //   4) c may be nullptr
  void del_rebalance(iterator p, iterator c) noexcept {
    iterator u;
    while (p != end()) {
      if (c == p.right_child()) {
        u = p.left_child();
        if (p.red()) {
        P_IS_RED:
          if (u.right_child() == nullptr || !u.right_child().red())
            p.rotate_right(u);
          else {
            p.red(false);
            p.rotate_left_right(u, u.right_child());
          }
          return;
        }
        else {
          if (u.red()) {
            p.red(true);
            u.red(false);
            p.rotate_right(u);
            u = p.left_child();
            goto P_IS_RED;
          }
          else {
            if (u.left_child() == nullptr || !u.left_child().red()) {
              if (u.right_child() == nullptr || !u.right_child().red()) {
                u.red(true);
                c = p;
                p = p.parent();
              }
              else {
                u.right_child().red(false);
                p.rotate_left_right(u, u.right_child());
                return;
              }
            }
            else {
              u.left_child().red(false);
              p.rotate_right(u);
              return;
            }
          }
        }
      }
      else {
        u = p.right_child();
        if (p.red()) {
        P_IS_RED_2:
          if (u.left_child() == nullptr || !u.left_child().red())
            p.rotate_left(u);
          else {
            p.red(false);
            p.rotate_right_left(u, u.left_child());
          }
          return;
        }
        else {
          if (u.red()) {
            p.red(true);
            u.red(false);
            p.rotate_left(u);
            u = p.right_child();
            goto P_IS_RED_2;
          }
          else {
            if (u.right_child() == nullptr || !u.right_child().red()) {
              if (u.left_child() == nullptr || !u.left_child().red()) {
                u.red(true);
                c = p;
                p = p.parent();
              }
              else {
                u.left_child().red(false);
                p.rotate_right_left(u, u.left_child());
                return;
              }
            }
            else {
              u.right_child().red(false);
              p.rotate_left(u);
              return;
            }
          }
        }
      }
    }
  }

  // insert_right(new_it, it) requires: it.right_child() == nullptr
  // insert_left(new_it, it) requires: it.left_child() == nullptr
  void insert_right(iterator new_it, iterator it) noexcept {
    new_it.left_child(iterator{});
    new_it.right_child(iterator{});
    new_it.parent(it);
    it.right_child(new_it);
    set_size(get_size() + 1u);
    new_it.red(true);
    ins_rebalance(new_it, it);
  }
  void insert_left(iterator new_it, iterator it) noexcept {
    new_it.left_child(iterator{});
    new_it.right_child(iterator{});
    new_it.parent(it);
    it.left_child(new_it);
    set_size(get_size() + 1u);
    new_it.red(true);
    ins_rebalance(new_it, it);
  }

  // insert_to_null(it) requires: root() == nullptr
  // insert_right/left():
  //   call insert_right/left() and update rightmost or leftmost record
  iterator insert_to_null(iterator new_it) noexcept {
    leftmost(new_it);
    rightmost(new_it);
    root(new_it);
    new_it.left_child(iterator{});
    new_it.right_child(iterator{});
    new_it.parent(end());
    new_it.red(false);
    set_size(1);
    return new_it;
  }
  iterator insert_to_left(iterator new_it, iterator it) noexcept {
    if (it == leftmost())
      leftmost(new_it);
    insert_left(new_it, it);
    return new_it;
  }
  iterator insert_to_right(iterator new_it, iterator it) noexcept {
    if (it == rightmost())
      rightmost(new_it);
    insert_right(new_it, it);
    return new_it;
  }

public:
  // container (continued)

  rbtree_adaptor()
    noexcept(!traits::store_node_allocator::value || noexcept(alloc_t{})) {
    new_data();
  }
  ~rbtree_adaptor() {}
  rbtree_adaptor(const rbtree_adaptor &) = delete;
  rbtree_adaptor &operator =(const rbtree_adaptor &) = delete;
  rbtree_adaptor(rbtree_adaptor &&x) noexcept
    : alloc_t(move(x.alloc_ref())) {
    new_data(move(x));
  }
  rbtree_adaptor &operator =(rbtree_adaptor &&x) noexcept {
    if (this != addressof(x))
      new_data(move(x));
    return *this;
  }
  friend void swap(rbtree_adaptor &x, rbtree_adaptor &y) noexcept {
    x.swap_data(y);
  }

  ~rbtree_adaptor()
    requires traits::store_node_allocator::value {
    delete_data();
  }
  rbtree_adaptor(const rbtree_adaptor &x)
    requires traits::store_node_allocator::value
    : alloc_t(allocator_traits<alloc_t>
              ::select_on_container_copy_construction(x.alloc_ref())) {
    new_data(x);
  }
  rbtree_adaptor &operator =(const rbtree_adaptor &x)
    requires traits::store_node_allocator::value {
    allocator_aware_container_ownership<this_t>::copy_assign(*this, x);
    return *this;
  }
  rbtree_adaptor &operator =(rbtree_adaptor &&x)
    noexcept(alloc_move_prpg<alloc_t> || alloc_always_equal<alloc_t>)
    requires traits::store_node_allocator::value {
    allocator_aware_container_ownership<this_t>::move_assign(*this, x);
    return *this;
  }
  friend void swap(rbtree_adaptor &x, rbtree_adaptor &y)
    noexcept(alloc_swap_prpg<alloc_t> || alloc_always_equal<alloc_t>)
    requires traits::store_node_allocator::value {
    allocator_aware_container_ownership<this_t>::swap(x, y);
  }

  // optional container operations

  // reversible container

  using reverse_iterator = re::reverse_iterator<iterator>;
  using const_reverse_iterator = re::reverse_iterator<const_iterator>;

  reverse_iterator rbegin() noexcept {
    return reverse_iterator(end());
  }
  reverse_iterator rend() noexcept {
    return reverse_iterator(begin());
  }
  const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator(begin());
  }
  const_reverse_iterator crbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  const_reverse_iterator crend() const noexcept {
    return const_reverse_iterator(begin());
  }

  // allocator-aware container

  using allocator_type = typename TRAITS::allocator_type;
  alloc_t get_allocator() const noexcept {
    return alloc_ref();
  }

  explicit rbtree_adaptor(const alloc_t &al) noexcept : alloc_t(al) {
    new_data();
  }
  rbtree_adaptor(const this_t &x, const alloc_t &al) : alloc_t(al) {
    new_data(x);
  }
  rbtree_adaptor(this_t &&x, const alloc_t &al) : alloc_t(al) {
    allocator_aware_container_ownership<this_t>::move_construct(*this, x);
  }

  // bst specilized operations

  template <class UPRED>
  iterator partition_point(UPRED eq) const {
    iterator ret = end().to_mutable();
    iterator it = root();
    for (;;) {
      if (it == nullptr)
        return ret;
      if (eq(*it))
        it = it.right_child();
      else {
        ret = it;
        it = it.left_child();
      }
    }
  }
  template <class GET_KEY, class KEY_LESS, class KEY>
  iterator find(GET_KEY get_key, KEY_LESS key_less, const KEY &key) const {
    const iterator it = lower_bound(get_key, key_less, key);
    if (it != end() && !key_less(key, get_key(*it)))
      return it;
    return end().to_mutable();
  }
  template <class GET_KEY, class KEY_LESS, class KEY>
  iterator lower_bound(GET_KEY get_key, KEY_LESS key_less,
                       const KEY &key) const {
    return partition_point(bind(key_less, bind(get_key, _1), ref(key)));
  }
  template <class GET_KEY, class KEY_LESS, class KEY>
  iterator upper_bound(GET_KEY get_key, KEY_LESS key_less,
                       const KEY &key) const {
    return partition_point(bind(not_fn(key_less), ref(key), bind(get_key, _1)));
  }
  template <class GET_KEY, class KEY_LESS, class KEY>
  iter_pair<iterator> equal_range(GET_KEY get_key, KEY_LESS key_less,
                                  const KEY &key) const {
    return {
      lower_bound(get_key, key_less, key),
      upper_bound(get_key, key_less, key)
    };
  }
  template <class GET_KEY, class KEY_LESS, class KEY>
  size_type count(GET_KEY get_key, KEY_LESS key_less,
                  const KEY &key) const {
    return size(equal_range(get_key, key_less, key));
  }
  template <class GET_KEY, class KEY_LESS, class KEY, class KEY2>
  iter_pair<iterator> find_range(GET_KEY get_key, KEY_LESS key_less,
                                 const KEY &key, const KEY2 &key2) const {
    return {
      lower_bound(get_key, key_less, key),
      upper_bound(get_key, key_less, key2)
    };
  }

private:
  iterator unlink_impl(iterator it) noexcept {
    const iterator ret = next(it);
    if (it == leftmost()) {
      leftmost(ret);
      if (it == rightmost())
        rightmost(end());
    }
    else if (it == rightmost())
      rightmost(prev(it));

    const iterator parent = it.parent();
    if (it.left_child() == nullptr) {
      if (it.right_child() == nullptr) {
        if (it == parent.right_child()) {
          parent.right_child(iterator{});
          if (!it.red())
            del_rebalance(parent, parent.right_child());
        }
        else {
          parent.left_child(iterator{});
          if (!it.red())
            del_rebalance(parent, parent.left_child());
        }
      }
      else {
        const iterator rchild = it.right_child();
        rchild.parent(parent);
        if (it == parent.right_child())
          parent.right_child(rchild);
        else
          parent.left_child(rchild);
        rchild.red(false);
      }
    }
    else {
      if (it.right_child() == nullptr) {
        const iterator lchild = it.left_child();
        lchild.parent(parent);
        if (it == parent.right_child())
          parent.right_child(lchild);
        else
          parent.left_child(lchild);
        lchild.red(false);
      }
      else {
        const bool c = it.red();
        const iterator next = ret;
        if (next.parent() == it) {
          if (it == parent.right_child())
            parent.right_child(next);
          else
            parent.left_child(next);
          next.parent(parent);

          next.left_child(it.left_child());
          next.left_child().parent(next);

          if (!next.red()) {
            next.red(c);
            if (next.right_child() != nullptr)
              next.right_child().red(false);
            else
              del_rebalance(next, next.right_child());
          }
          else
            next.red(c);
        }
        else {
          const iterator p = next.parent();

          p.left_child(next.right_child());
          if (next.right_child() != nullptr)
            next.right_child().parent(p);

          if (it == parent.right_child())
            parent.right_child(next);
          else
            parent.left_child(next);
          next.parent(it.parent());

          next.left_child(it.left_child());
          next.left_child().parent(next);

          next.right_child(it.right_child());
          next.right_child().parent(next);

          if (!next.red()) {
            next.red(c);
            if (p.left_child() != nullptr)
              p.left_child().red(false);
            else
              del_rebalance(p, p.left_child());
          }
          else
            next.red(c);
        }
      }
    }
    set_size(get_size() - 1u);

    return ret;
  }
public:
  iterator unlink(const_iterator it) noexcept {
    return unlink_impl(it.to_mutable());
  }
  iterator unlink(const_iterator from, const_iterator to) noexcept  {
    while (from != to)
      from = unlink(from);
    return to.to_mutable();
  }
  void unlink() noexcept {
    new_data();
  }
  template <class GET_KEY, class KEY_LESS, class KEY>
  size_type unlink(GET_KEY get_key, KEY_LESS key_less, const KEY &key) {
    auto it = lower_bound(get_key, key_less, key);
    size_type c = 0;
    while (it != end() && !key_less(key, get_key(*it))) {
      it = unlink(it);
      ++c;
    }
    return c;
  }
  iterator erase(const_iterator it) {
    const auto ret = unlink(it);
    delete_node(it);
    return ret;
  }
  iterator erase(const_iterator from, const_iterator to) {
    while (from != to)
      from = erase(from);
    return to.to_mutable();
  }
  template <class GET_KEY, class KEY_LESS, class KEY>
  size_type erase(GET_KEY get_key, KEY_LESS key_less, const KEY &key) {
    auto it = lower_bound(get_key, key_less, key);
    size_type c = 0;
    while (it != end() && !key_less(key, get_key(*it))) {
      it = erase(it);
      ++c;
    }
    return c;
  }
  template <class NODE_HANDLE>
  NODE_HANDLE extract(const_iterator it) {
    NODE_HANDLE ret(it.node(), alloc_ref());
    unlink(it);
    return ret;
  }
  template <class NODE_HANDLE, class GET_KEY, class KEY_LESS, class KEY>
  NODE_HANDLE extract(GET_KEY getkey, KEY_LESS keyless, const KEY &key) {
    const iterator it = lower_bound(getkey, keyless, key);
    return (it != end() && !keyless(key, getkey(*it)))
      ? extract<NODE_HANDLE>(it) : NODE_HANDLE{};
  }
  void clear() noexcept {
    delete_data();
    new_data();
  }

private:
  iterator link_impl(iterator pos, iterator node) {
    if (root() == nullptr)
      return insert_to_null(node);
    if (pos == end()) {
      insert_right(node, rightmost());
      rightmost(node);
    }
    else if (pos == begin()) {
      insert_left(node, leftmost());
      leftmost(node);
    }
    else {
      if (pos.left_child() == nullptr)
        insert_left(node, pos);
      else
        insert_right(node, prev(pos));
    }
    return node;
  }
public:
  iterator link(const_iterator pos, const_iterator node) {
    return link_impl(pos.to_mutable(), node.to_mutable());
  }
  template <class...S>
  iterator emplace(const_iterator i, S &&...s) {
    return link(i, new_node(forward<S>(s)...));
  }
  iterator insert(const_iterator i, const value_type &x) {
    return link(i, new_node(x));
  }
  iterator insert(const_iterator i, value_type &&x) {
    return link(i, new_node(move(x)));
  }
  template <class IITR_RANGE>
  enable_if_t<!is_convertible_v<IITR_RANGE &&, value_type &&>
              && !is_convertible_v<IITR_RANGE &&, const value_type &>,
              iterator>
  insert(const_iterator pos, IITR_RANGE &&r) {
    return insert_range(pos, r);
  }
  template <class IITR_RANGE>
  iterator insert_range(const_iterator pos, IITR_RANGE &&r) {
    if (empty(r))
      return pos.to_mutable();
    auto it = begin(r);
    const iterator ret = insert(pos, *it);
    for (auto &i : iters(++it, end(r)))
      insert(pos, *i);
    return ret;
  }
  template <class IITR_RANGE>
  void assign_range(IITR_RANGE &&r) {
    auto rr = rng(r);
    iterator it = begin();
    for (;;) {
      if (empty(rr)) {
        erase(it, end());
        return;
      }
      if (it == end()) {
        insert_range(end(), rr);
        return;
      }
      *it = *rr.first;
      ++it;
      ++rr.first;
    }
  }

  template <class GET_KEY, class KEY_LESS, class KEY,
            class GET_NEW_NODE, class DO_WHEN_EQUAL>
  pair<iterator, bool>
  insert(GET_KEY get_key, KEY_LESS key_less, const KEY &key,
         GET_NEW_NODE get_new_node, DO_WHEN_EQUAL do_when_equal) {
    if (root() == nullptr)
      return {insert_to_null(get_new_node()), true};
    const iterator it = lower_bound(get_key, key_less, key);
    if (it == end()) {
      const iterator new_it = get_new_node();
      insert_right(new_it, rightmost());
      rightmost(new_it);
      return {new_it, true};
    }
    else if (key_less(key, get_key(*it))) {
      if (it.left_child() == nullptr)
        return {insert_to_left(get_new_node(), it), true};
      else {
        const iterator new_it = get_new_node();
        insert_right(new_it, prev(it));
        return {new_it, true};
      }
    }
    else {
      do_when_equal(it);
      return {it, false};
    }
  }
  template <class GET_KEY, class KEY_LESS, class KEY, class GET_NEW_NODE>
  iterator insert_equal(GET_KEY get_key, KEY_LESS key_less, const KEY &key,
                        GET_NEW_NODE get_new_node) {
    if (root() == nullptr)
      return insert_to_null(get_new_node());
    iterator it = root();
    for (;;) {
      if (key_less(key, get_key(*it))) {
        if (it.left_child() == nullptr)
          return insert_to_left(get_new_node(), it);
        else
          it = it.left_child();
      }
      else {
        if (it.right_child() == nullptr)
          return insert_to_right(get_new_node(), it);
        else
          it = it.right_child();
      }
    }
  }

  template <class GET_KEY, class KEY_LESS, class KEY,
            class GET_NEW_NODE, class DO_WHEN_EQUAL>
  iterator insert(GET_KEY get_key, KEY_LESS key_less,
                  iterator hint, const KEY &key,
                  GET_NEW_NODE get_new_node, DO_WHEN_EQUAL do_when_equal) {
    if (root() == nullptr)
      return insert_to_null(get_new_node());
    else if (hint == end()) {
      if (key_less(get_key(*rightmost()), key)) {
        const iterator new_it = get_new_node();
        insert_right(new_it, rightmost());
        rightmost(new_it);
        return new_it;
      }
    }
    else if (hint == begin()) {
      if (key_less(key, get_key(*hint))) {
        const iterator new_it = get_new_node();
        insert_left(new_it, leftmost());
        leftmost(new_it);
        return new_it;
      }
    }
    else {
      const iterator it = prev(hint);
      if (key_less(get_key(*it), key) && key_less(key, get_key(*hint))) {
        const iterator new_it = get_new_node();
        if (hint.left_child() == nullptr)
          insert_left(new_it, hint);
        else
          insert_right(new_it, it);
        return new_it;
      }
    }
    return insert(get_key, key_less, key, get_new_node, do_when_equal).first;
  }
  template <class GET_KEY, class KEY_LESS, class KEY, class GET_NEW_NODE>
  iterator insert_equal(GET_KEY get_key, KEY_LESS key_less,
                        iterator hint, const KEY &key,
                        GET_NEW_NODE get_new_node) {
    if (root() == nullptr)
      return insert_to_null(get_new_node());
    else if (hint == end()) {
      if (!key_less(key, get_key(*rightmost()))) {
        const iterator new_it = get_new_node();
        insert_right(new_it, rightmost());
        rightmost(new_it);
        return new_it;
      }
    }
    else if (hint == begin()) {
      if (!key_less(get_key(*hint), key)) {
        const iterator new_it = get_new_node();
        insert_left(new_it, leftmost());
        leftmost(new_it);
        return new_it;
      }
    }
    else {
      const iterator it = prev(hint);
      if (!key_less(key, get_key(*it)) && !key_less(get_key(*hint), key)) {
        const iterator new_it = get_new_node();
        if (hint.left_child() == nullptr)
          insert_left(new_it, hint);
        else
          insert_right(new_it, it);
        return new_it;
      }
    }
    return insert_equal(get_key, key_less, key, get_new_node);
  }

  template <class GET_KEY, class KEY_LESS>
  pair<iterator, bool> link(GET_KEY get_key, KEY_LESS key_less,
                            iterator it) {
    return insert(get_key, key_less, get_key(*it), bind(copy, it),
                  empty_function{});
  }
  template <class GET_KEY, class KEY_LESS, class...S>
  enable_if_t<!is_convertible_v<GET_KEY &&, const_iterator>,
              pair<iterator, bool>>
  emplace(GET_KEY &&get_key, KEY_LESS key_less, S &&...s) {
    const auto it = new_node(forward<S>(s)...);
#ifndef RE_NOEXCEPT
    try {
#endif
      return insert(get_key, key_less, get_key(*it), bind(copy, it),
                    [=, this](auto) {delete_node(it);});
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      delete_node(it);
      throw;
    }
#endif
  }
  template <class GET_KEY, class KEY_LESS>
  pair<iterator, bool> insert(GET_KEY get_key, KEY_LESS key_less,
                              const value_type &x) {
    return insert(get_key, key_less, get_key(x),
                  [&]() {return new_node(x);}, empty_function{});
  }
  template <class GET_KEY, class KEY_LESS>
  pair<iterator, bool> insert(GET_KEY get_key, KEY_LESS key_less,
                              value_type &&x) {
    return insert(get_key, key_less, get_key(x),
                  [&]() {return new_node(move(x));}, empty_function{});
  }
  template <class GET_KEY, class KEY_LESS>
  iterator link(GET_KEY get_key, KEY_LESS key_less,
                iterator hint, iterator it) {
    return insert(get_key, key_less, hint, get_key(*it),
                  bind(copy, it), empty_function{});
  }
  template <class GET_KEY, class KEY_LESS, class...S>
  iterator emplace_hint(GET_KEY get_key, KEY_LESS key_less,
                        iterator hint, S &&...s) {
    const auto it = new_node(forward<S>(s)...);
#ifndef RE_NOEXCEPT
    try {
#endif
      return insert(get_key, key_less, hint, get_key(*it), bind(copy, it),
                    [=, this](auto) {delete_node(it);});
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      delete_node(it);
      throw;
    }
#endif
  }
  template <class GET_KEY, class KEY_LESS>
  iterator insert(GET_KEY get_key, KEY_LESS key_less,
                  iterator hint, const value_type &x) {
    return insert(get_key, key_less, hint, get_key(x),
                  [&]() {return new_node(x);}, empty_function{});
  }
  template <class GET_KEY, class KEY_LESS>
  iterator insert(GET_KEY get_key, KEY_LESS key_less,
                  iterator hint, value_type &&x) {
    return insert(get_key, key_less, hint, get_key(x),
                  [&]() {return new_node(move(x));}, empty_function{});
  }

  template <class GET_KEY, class KEY_LESS, class KEY, class...S>
  pair<iterator, bool>
  try_emplace(GET_KEY get_key, KEY_LESS key_less, KEY &&key, S &&...s) {
    return insert(get_key, key_less, key,
                  [&]() {return new_node(piecewise_construct,
                                         forward_as_tuple(forward<KEY>(key)),
                                         forward_as_tuple(forward<S>(s)...));},
                  empty_function{});
  }
  template <class GET_KEY, class KEY_LESS, class KEY, class...S>
  iterator try_emplace_hint(GET_KEY get_key, KEY_LESS key_less,
                            iterator hint, KEY &&key, S &&...s) {
    return insert(get_key, key_less, hint, key,
                  [&]() {return new_node(piecewise_construct,
                                         forward_as_tuple(forward<KEY>(key)),
                                         forward_as_tuple(forward<S>(s)...));},
                  empty_function{});
  }
  template <class GET_KEY, class GET_MAPPED, class KEY_LESS, class KEY, class X>
  pair<iterator, bool>
  insert_or_assign(GET_KEY get_key, GET_MAPPED get_mapped, KEY_LESS key_less,
                   KEY &&key, X &&x) {
    return insert(get_key, key_less, key,
                  [&]() {return new_node(forward<KEY>(key), forward<X>(x));},
                  [&](iterator pos) {get_mapped(*pos) = forward<X>(x);});
  }
  template <class GET_KEY, class GET_MAPPED, class KEY_LESS, class KEY, class X>
  iterator insert_or_assign(GET_KEY get_key, GET_MAPPED get_mapped,
                            KEY_LESS key_less,
                            iterator hint, KEY &&key, X &&x) {
    return insert(get_key, key_less, hint, key,
                  [&]() {return new_node(forward<KEY>(key), forward<X>(x));},
                  [&](iterator pos) {get_mapped(*pos) = forward<X>(x);});
  }
  template <class ITERATOR, class GET_KEY, class KEY_LESS, class NODE_HANDLE>
  inner::node_handle_insert_return_type
  <ITERATOR, remove_reference_t<NODE_HANDLE>>
  insert_node_handle(GET_KEY get_key, KEY_LESS key_less, NODE_HANDLE &&nh) {
    inner::node_handle_insert_return_type
      <ITERATOR, remove_reference_t<NODE_HANDLE>> ret;
    if (nh.empty()) {
      ret.position = end();
      ret.inserted = false;
    }
    else {
      tie(ret.position, ret.inserted)
        = insert(get_key, key_less, get_key(*ITERATOR(nh.get())),
                 [&]() {return iterator(nh.release());}, empty_function{});
      ret.node = move(nh);
    }
    return ret;
  }
  template <class GET_KEY, class KEY_LESS, class NODE_HANDLE>
  iterator insert_node_handle(GET_KEY get_key, KEY_LESS key_less,
                              iterator hint, NODE_HANDLE &&nh) {
    return nh.empty()
      ? end()
      : insert(get_key, key_less, hint,
               get_key(*iterator(nh.get())),
               [&]() {return iterator(nh.release());},
               empty_function{});
  }

  template <class GET_KEY, class KEY_LESS>
  iterator link_equal(GET_KEY get_key, KEY_LESS key_less,
                      iterator it) noexcept {
    return insert_equal(get_key, key_less, get_key(*it), bind(copy, it));
  }
  template <class GET_KEY, class KEY_LESS>
  iterator link_equal(GET_KEY get_key, KEY_LESS key_less,
                      iterator hint, iterator it) noexcept {
    return insert_equal(get_key, key_less, hint, get_key(*it), bind(copy, it));
  }
  template <class GET_KEY, class KEY_LESS, class...S>
  iterator emplace_equal(GET_KEY get_key, KEY_LESS key_less, S &&...s) {
    const auto it = new_node(forward<S>(s)...);
#ifndef RE_NOEXCEPT
    try {
#endif
      return insert_equal(get_key, key_less, get_key(*it), bind(copy, it));
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      delete_node(it);
      throw;
    }
#endif
  }
  template <class GET_KEY, class KEY_LESS, class...S>
  iterator emplace_equal_hint(GET_KEY get_key, KEY_LESS key_less,
                              iterator hint, S &&...s) {
    const auto it = new_node(forward<S>(s)...);
#ifndef RE_NOEXCEPT
    try {
#endif
      return insert_equal(get_key, key_less,
                          hint, get_key(*it), bind(copy, it));
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      delete_node(it);
      throw;
    }
#endif
  }
  template <class GET_KEY, class KEY_LESS, class NODE_HANDLE>
  iterator insert_node_handle_equal(GET_KEY get_key, KEY_LESS key_less,
                                    NODE_HANDLE &&nh) {
    return nh.empty()
      ? end()
      : insert_equal(get_key, key_less, get_key(*iterator(nh.get())),
                     [&]() {return iterator(nh.release());});
  }
  template <class GET_KEY, class KEY_LESS, class NODE_HANDLE>
  iterator insert_node_handle_equal(GET_KEY get_key, KEY_LESS key_less,
                                    iterator hint, NODE_HANDLE &&nh) {
    return nh.empty()
      ? end()
      : insert_equal(get_key, key_less, hint, get_key(*iterator(nh.get())),
                     [&]() {return iterator(nh.release());});
  }

  template <class GET_KEY, class KEY_LESS, class ANALOGOUS>
  void merge(GET_KEY get_key, KEY_LESS key_less, ANALOGOUS &&other) {
    if (this != addressof(other))
      for (iterator it = other.begin(), ed = other.end(); it != ed;)
        insert(get_key, key_less, get_key(*it),
               [&]() {return exchange(it, other.unlink(it));},
               [&](...) {++it;});
  }

  template <class GET_KEY, class KEY_LESS, class ANALOGOUS>
  void merge_equal(GET_KEY get_key, KEY_LESS key_less, ANALOGOUS &&other) {
    if (this != addressof(other))
      for (iterator it = other.begin(), ed = other.end(); it != ed;)
        insert_equal(get_key, key_less, get_key(*it),
                     [&]() {return exchange(it, other.unlink(it));});
  }

  template <class GET_KEY, class KEY_LESS, class R>
  void insert_range(GET_KEY get_key, KEY_LESS key_less, R &&r) {
    for (auto &it : iters(r))
      emplace(get_key, key_less, *it);
  }
  template <class GET_KEY, class KEY_LESS, class R,
            class INSERT_RANGE>
  void assign_range(GET_KEY get_key, KEY_LESS key_less, R &&r,
                    INSERT_RANGE insert_range_fn) {
    const iterator root_node = root();
    end().right_child(iterator{});
    inner::bst_helper::link_bst_to_forward_list(end(), root_node);
    iterator hook = end().right_child();
    const auto guard = exit_fn([&]() {
      for_each_node(rng(hook, iterator{}),
                    [](auto it) {return it.right_child();},
                    [&](auto it) {delete_node(it);});
    });
    new_data();
    for (auto &it : iters(r)) {
      if (hook != nullptr) {
        *hook = *it;
        insert(get_key, key_less, get_key(*hook),
               [&]() {return exchange(hook, hook.right_child());},
               empty_function{});
      }
      else {
        insert_range_fn(rng(it, end(r)));
        return;
      }
    }
  }
  template <class GET_KEY, class KEY_LESS, class R>
  void assign_range(GET_KEY get_key, KEY_LESS key_less, R &&r) {
    assign_range(get_key, key_less, r,
                 [=, this](auto &&r) {insert_range(get_key, key_less, r);});
  }

  template <class GET_KEY, class KEY_LESS, class R>
  void insert_range_equal(GET_KEY get_key, KEY_LESS key_less, R &&r) {
    for (auto &it : iters(r))
      emplace_equal(get_key, key_less, *it);
  }
  template <class GET_KEY, class KEY_LESS, class R>
  void assign_range_equal(GET_KEY get_key, KEY_LESS key_less, R &&r) {
    const iterator root_node = root();
    end().right_child(iterator{});
    inner::bst_helper::link_bst_to_forward_list(end(), root_node);
    iterator hook = end().right_child();
    const auto guard = exit_fn([&]() {
      for_each_node(rng(hook, iterator{}),
                    [](auto it) {return it.right_child();},
                    [&](auto it) {delete_node(it);});
    });
    new_data();
    for (auto &it : iters(r)) {
      if (hook != nullptr) {
        *hook = *it;
        insert_equal(get_key, key_less, get_key(*hook),
                     [&]() {return exchange(hook, hook.right_child());});
      }
      else {
        insert_range_equal(get_key, key_less, rng(it, end(r)));
        return;
      }
    }
  }

private:
  bool good_recurse(iterator it, size_type current_black_count,
                    const size_type &black_count) const {
    if (it == nullptr) {
      if (current_black_count != black_count)
        return false;
      return true;
    }
    if (it.red()) {
      if (it.left_child() != nullptr && it.left_child().red())
        return false;
      if (it.right_child() != nullptr && it.right_child().red())
        return false;
    }
    else
      ++current_black_count;
    return good_recurse(it.left_child(), current_black_count, black_count)
      && good_recurse(it.right_child(), current_black_count, black_count);
  }
  friend struct inner::fo_good;
  bool good() const noexcept {
    if (begin() == end())
      return true;
    if (root().red())
      return false;
    size_type n = 0;
    for (auto it = root(); it != nullptr; it = it.left_child())
      n += !it.red();
    return good_recurse(root(), 0, n);
  }
};
template <class TRAITS>
bool operator ==(const rbtree_adaptor<TRAITS> &x,
                 const rbtree_adaptor<TRAITS> &y) {
  return equal(x, y);
}
template <class TRAITS>
synth_3way_result<typename TRAITS::value_type>
operator <=>(const rbtree_adaptor<TRAITS> &x,
             const rbtree_adaptor<TRAITS> &y) {
  return lexicographical_synth_3way(x, y);
}

}
// avltree_adaptor
namespace re {
  
template <size_t ID = 0, class VOID_PTR = void *>
struct avlt_node_base {
  pointer_rebind_t<VOID_PTR, avlt_node_base> left_child;
  pointer_rebind_t<VOID_PTR, avlt_node_base> right_child;
  pointer_rebind_t<VOID_PTR, avlt_node_base> parent;
};
template <size_t ID = 0, class VOID_PTR = void *>
struct join_avltree : public avlt_node_base<ID, VOID_PTR> {
  int factor;
  // +1: right tree is higher
  //  0: two max heights are same
  // -1: left tree is higher
};
template <class T, class AL = default_allocator<T>>
struct avltree_node : join_avltree<0, alloc_void_ptr<AL>> {
  alignas(T) byte data[sizeof(T)];

  T &operator *() const {
    return *reinterpret_cast<T *>(addressof(data));
  }
  T *operator ->() const {
    return reinterpret_cast<T *>(addressof(data));
  }
};
namespace inner {

template <class NODE_BASE_TYPE, class SIZE_TYPE, bool STORE_SIZE>
struct avltree_header_data {
  mutable NODE_BASE_TYPE ed;
  SIZE_TYPE sz;
};
template <class NODE_BASE_TYPE, class SIZE_TYPE>
struct avltree_header_data<NODE_BASE_TYPE, SIZE_TYPE, false> {
  mutable NODE_BASE_TYPE ed;
};

}

template <class NODE_T, size_t ID = 0,
          bool STORE_SIZE = true, bool STORE_NODE_ALLOCATOR = false,
          class AL = default_allocator<NODE_T>>
struct avltree_traits {
  using value_type = alloc_vt<AL>;
  using allocator_type = AL;
  using node_type = NODE_T;
  using node_pointer = alloc_rebind_ptr<AL, node_type>;
  using node_base_type = avlt_node_base<ID, alloc_void_ptr<AL>>;
  using node_base_pointer = alloc_rebind_ptr<AL, node_base_type>;
  using difference_type = alloc_dft<AL>;
  using size_type = alloc_szt<AL>;

  using id = size_constant<ID>;
  using store_size = bool_constant<STORE_SIZE>;
  using store_node_allocator = bool_constant<STORE_NODE_ALLOCATOR>;
  using store_allocator = bool_constant<STORE_NODE_ALLOCATOR>;

  static node_base_pointer left_child(node_base_pointer p) {
    return p->left_child;
  }
  static void left_child(node_base_pointer p, node_base_pointer p2) {
    p->left_child = p2;
  }

  static node_base_pointer right_child(node_base_pointer p) {
    return p->right_child;
  }
  static void right_child(node_base_pointer p, node_base_pointer p2) {
    p->right_child = p2;
  }

  static node_base_pointer parent(node_base_pointer p) {
    return p->parent;
  }
  static void parent(node_base_pointer p, node_base_pointer p2) {
    p->parent = p2;
  }

  static int factor(node_base_pointer p) {
    return static_cast<join_avltree<ID, alloc_void_ptr<AL>> &>(*p).factor;
  }
  static void factor(node_base_pointer p, int f) {
    static_cast<join_avltree<ID, alloc_void_ptr<AL>> &>(*p).factor = f;
  }

  template <class VT = value_type>
  static enable_if_t<!is_same_v<VT, node_type>, value_type *>
  data(node_base_pointer p) {
    return reinterpret_cast<value_type *>
      (addressof(static_cast<node_type &>(*p).data));
  }
  template <class VT = value_type>
  static enable_if_t<is_same_v<VT, node_type>, value_type *>
  data(node_base_pointer p) {
    return to_address(static_cast<node_pointer>(p));
  }

  using header_type = inner::avltree_header_data
    <node_base_type, size_type, store_size::value>;
  static node_base_pointer end_node(const header_type &h) {
    return pointer_traits<node_base_pointer>
      ::pointer_to(static_cast<node_base_type &>(h.ed));
  }
  template <bool Y = store_size::value>
  static enable_if_t<Y, size_type> size(const header_type &h) {
    return h.sz;
  }
  template <bool Y = store_size::value>
  static enable_if_t<Y> size(header_type &h, size_type n) {
    h.sz = n;
  }

  template <class...S, class VT = value_type>
  static enable_if_t<!is_same_v<VT, node_type>, node_base_pointer>
  new_node(AL &al, S &&...s) {
    return allocator_wrapper<AL>(al)
      .template new_node<node_type>(forward<S>(s)...);
  }
  template <class VT = value_type>
  static enable_if_t<!is_same_v<VT, node_type>>
  delete_node(AL &al, node_base_pointer p) noexcept {
    allocator_wrapper<AL>(al).delete_node(static_cast<node_pointer>(p));
  }

  template <class...S, class VT = value_type>
  static enable_if_t<is_same_v<VT, node_type>, node_base_pointer>
  new_node(AL &al, S &&...s) {
    return static_cast<node_base_pointer>
      (allocator_wrapper<AL>(al).new_1(forward<S>(s)...));
  }
  template <class VT = value_type>
  static enable_if_t<is_same_v<VT, node_type>>
  delete_node(AL &al, node_base_pointer p) noexcept {
    allocator_wrapper<AL>(al).delete_1(static_cast<node_pointer>(p));
  }
};

template <class TRAITS>
class avltree_adaptor
  : TRAITS::header_type
  , conditional_t<!TRAITS::store_node_allocator::value,
                  inner::empty_type, typename TRAITS::allocator_type> {
  using this_t = avltree_adaptor;

  using data_t = typename TRAITS::header_type;
  data_t &data_ref() {
    return static_cast<data_t &>(*this);
  }
  const data_t &data_ref() const {
    return static_cast<const data_t &>(*this);
  }

  using alloc_t = conditional_t<!TRAITS::store_node_allocator::value,
                                inner::empty_type,
                                typename TRAITS::allocator_type>;

  template <class R>
  static auto begin(R &&r) {return re::begin(r);}
  template <class R>
  static auto end(R &&r) {return re::end(r);}
  template <class R>
  static auto rbegin(R &&r) {return re::rbegin(r);}
  template <class R>
  static auto rend(R &&r) {return re::rend(r);}
  template <class R>
  static auto size(R &&r) {return re::size(r);}
  template <class R>
  static auto empty(R &&r) {return re::empty(r);}

public:

  using traits = TRAITS;
  using node_pointer = typename traits::node_base_pointer;

  // container

  using value_type = typename traits::value_type;
  using reference = value_type &;
  using const_reference = const value_type &;

  using iterator = inner::bst_iterator<value_type, traits>;
  using const_iterator = inner::bst_iterator<const value_type, traits>;
  using difference_type = typename traits::difference_type;
  using size_type = typename traits::size_type;

  iterator begin() noexcept {
    return leftmost();
  }
  iterator end() noexcept {
    return iterator(traits::end_node(data_ref()));
  }
  const_iterator begin() const noexcept {
    return leftmost();
  }
  const_iterator end() const noexcept {
    return iterator(traits::end_node(data_ref()));
  }
  const_iterator cbegin() const noexcept {
    return begin();
  }
  const_iterator cend() const noexcept {
    return end();
  }

  size_type max_size() const noexcept {
    return container_regular_max_size<this_t>();
  }
  template <bool Y = traits::store_size::value>
  enable_if_t<Y, size_type> size() const noexcept {
    return traits::size(data_ref());
  }
  bool empty() const noexcept {
    return root() == nullptr;
  }

  // node operations

  template <class...S>
  iterator new_node(S &&...s) {
    return iterator(traits::new_node(alloc_ref(), forward<S>(s)...));
  }
  void delete_node(const_iterator it) noexcept {
    traits::delete_node(alloc_ref(), it.node());
  }
  void delete_tree(const_iterator it) noexcept {
    inner::bst_helper::delete_bst_node_recursively
      (it, [&](auto i) {delete_node(i);});
  }

  iterator root() const noexcept {
    return end().to_mutable().right_child();
  }
  iterator leftmost() const noexcept {
    return end().to_mutable().parent();
  }
  iterator rightmost() const noexcept {
    return end().to_mutable().left_child();
  }

private:
  // inner implements

  void root(iterator it) noexcept {
    end().right_child(it);
  }
  void leftmost(iterator it) noexcept {
    end().parent(it);
  }
  void rightmost(iterator it) noexcept {
    end().left_child(it);
  }

  template <bool Y = traits::store_size::value>
  enable_if_t<Y> set_size(size_type n) noexcept {
    traits::size(data_ref(), n);
  }
  template <bool Y = traits::store_size::value>
  enable_if_t<Y, size_type> get_size() const noexcept {
    return traits::size(data_ref());
  }
  template <bool Y = traits::store_size::value>
  enable_if_t<!Y> set_size(size_type) noexcept {}
  template <bool Y = traits::store_size::value>
  enable_if_t<!Y, size_type> get_size() const noexcept {
    return 0;
  }

  void relink(iterator root_node) noexcept {
    if (root_node == nullptr)
      new_data();
    else {
      root(root_node);
      root().parent(end());

      iterator it;
      for (it = root(); it.left_child() != nullptr;)
        it = it.left_child();
      leftmost(it);
      for (it = root(); it.right_child() != nullptr;)
        it = it.right_child();
      rightmost(it);
    }
  }
  void relink_end() noexcept {
    if (root() != nullptr)
      root().parent(end()); // relink root node with end node
    else {
      leftmost(end());
      rightmost(end());
    }
  }

  friend struct inner::bst_helper;

  friend class allocator_aware_container_ownership<this_t>;
  const alloc_t &alloc_ref() const noexcept {
    return static_cast<const alloc_t &>(*this);
  }
  alloc_t &alloc_ref() noexcept {
    return static_cast<alloc_t &>(*this);
  }
  void new_data() noexcept {
    leftmost(end());
    root(iterator{});
    rightmost(end());
    set_size(0);
  }
  void delete_data() noexcept {
    delete_tree(root());
  }
  void new_data(const this_t &x) {
    inner::bst_helper::bst_clone_data_impl(*this, x, identity{});
  }
  void assign_data(const this_t &x) {
    inner::bst_helper::bst_assign_data_impl(*this, x, identity{});
  }
  void new_data(this_t &&x) noexcept {
    data_ref() = move(x.data_ref());
    relink_end();
    x.new_data();
  }
  void new_data_individually(this_t &&x) {
    const auto guard = exit_fn([&]() {
      x.delete_data();
      x.new_data();
    });
    inner::bst_helper::bst_clone_data_impl(*this, x, move);
  }
  void assign_data_individually(this_t &&x) {
    const auto guard = exit_fn([&]() {
      x.delete_data();
      x.new_data();
    });
    inner::bst_helper::bst_assign_data_impl(*this, x, move);
  }
  void swap_data(this_t &x) noexcept {
    adl_swap(data_ref(), x.data_ref());
    relink_end();
    x.relink_end();
  }

  static void ins_rotate_left(iterator a, iterator b) noexcept {
    a.rotate_left(b);
    a.factor(0);
    b.factor(0);
  }
  static void ins_rotate_right(iterator a, iterator b) noexcept {
    a.rotate_right(b);
    a.factor(0);
    b.factor(0);
  }
  static iterator del_rotate_left(iterator a, iterator b) noexcept {
    a.rotate_left(b);
    const auto b_f = b.factor();
    a.factor(1 - b_f);
    b.factor(b_f - 1);
    return b;
  }
  static iterator del_rotate_right(iterator a, iterator b) noexcept {
    a.rotate_right(b);
    const auto b_f = b.factor();
    a.factor(-1 - b_f);
    b.factor(1 + b_f);
    return b;
  }
  static iterator rotate_right_left(iterator a, iterator b) noexcept {
    const iterator c = b.left_child();
    a.rotate_right_left(b, c);
    const auto c_f = c.factor();
    a.factor(c_f <= 0 ? 0 : -1);
    b.factor(c_f >= 0 ? 0 : +1);
    c.factor(0);
    return c;
  }
  static iterator rotate_left_right(iterator a, iterator b) noexcept {
    const iterator c = b.right_child();
    a.rotate_left_right(b, c);
    const auto c_f = c.factor();
    a.factor(c_f >= 0 ? 0 : +1);
    b.factor(c_f <= 0 ? 0 : -1);
    c.factor(0);
    return c;
  }

  // ins_rebalance(it) requires:
  //   1) it != end()
  //   2) it is parent of the inserted node
  //   3) it's factor has been updated
  void ins_rebalance(iterator it) noexcept {
    for (;;) {
      if (it.factor() == 0)
        return;

      if (it.factor() == +2) {
        const iterator it_r = it.right_child();
        if (it_r.factor() == +1)
          ins_rotate_left(it, it_r);
        else
          rotate_right_left(it, it_r);
        return;
      }

      if (it.factor() == -2) {
        const iterator it_l = it.left_child();
        if (it_l.factor() == -1)
          ins_rotate_right(it, it_l);
        else
          rotate_left_right(it, it_l);
        return;
      }

      const iterator p = it.parent();
      if (p == end())
        return;
      if (p.right_child() == it)
        p.factor(p.factor() + 1);
      else
        p.factor(p.factor() - 1);
      it = p;
    }
  }
  // del_reblance(it) rquires:
  //   1) it is parent of the deleted node
  //   2) it's factor has been updated
  void del_rebalance(iterator it) noexcept {
    if (it == end())
      return;
    for (;;) {
      if (it.factor() == +2) {
        const iterator it_r = it.right_child();
        if (it_r.factor() == 0) {
          del_rotate_left(it, it_r);
          return;
        }
        it = (it_r.factor() == +1
              ? del_rotate_left(it, it_r) : rotate_right_left(it, it_r));
      }
      else if (it.factor() == -2) {
        const iterator it_l = it.left_child();
        if (it_l.factor() == 0) {
          del_rotate_right(it, it_l);
          return;
        }
        it = (it_l.factor() == -1
              ? del_rotate_right(it, it_l) : rotate_left_right(it, it_l));
      }
      else if (it.factor() != 0)
        return;

      const iterator p = it.parent();
      if (p == end())
        return;
      if (p.right_child() == it)
        p.factor(p.factor() - 1);
      else
        p.factor(p.factor() + 1);
      it = p;
    }
  }
  void del_rebalance_plus(iterator it) noexcept {
    if (it != end()) {
      it.factor(it.factor() + 1);
      del_rebalance(it);
    }
  }
  void del_rebalance_minus(iterator it) noexcept {
    if (it != end()) {
      it.factor(it.factor() - 1);
      del_rebalance(it);
    }
  }

  // insert_right(new_it, it) requires: it.right_child() == nullptr
  // insert_left(new_it, it) requires: it.left_child() == nullptr
  void insert_right(iterator new_it, iterator it) noexcept {
    new_it.left_child(iterator{});
    new_it.right_child(iterator{});
    new_it.parent(it);
    new_it.factor(0);
    it.right_child(new_it);
    set_size(get_size() + 1u);

    it.factor(it.factor() + 1);
    ins_rebalance(it);
  }
  void insert_left(iterator new_it, iterator it) noexcept {
    new_it.left_child(iterator{});
    new_it.right_child(iterator{});
    new_it.parent(it);
    new_it.factor(0);
    it.left_child(new_it);
    set_size(get_size() + 1u);

    it.factor(it.factor() - 1);
    ins_rebalance(it);
  }

  // insert_to_null(it) requires: root() == nullptr
  // insert_right/left():
  //   call insert_right/left() and update rightmost or leftmost record
  iterator insert_to_null(iterator new_it) noexcept {
    leftmost(new_it);
    rightmost(new_it);
    root(new_it);
    new_it.left_child(iterator{});
    new_it.right_child(iterator{});
    new_it.parent(end());
    new_it.factor(0);
    set_size(1);
    return new_it;
  }
  iterator insert_to_left(iterator new_it, iterator it) noexcept {
    if (it == leftmost())
      leftmost(new_it);
    insert_left(new_it, it);
    return new_it;
  }
  iterator insert_to_right(iterator new_it, iterator it) noexcept {
    if (it == rightmost())
      rightmost(new_it);
    insert_right(new_it, it);
    return new_it;
  }

public:

  // container (continued)

  avltree_adaptor()
    noexcept(!traits::store_node_allocator::value || noexcept(alloc_t{})) {
    new_data();
  }
  ~avltree_adaptor() {}
  avltree_adaptor(const avltree_adaptor &) = delete;
  avltree_adaptor &operator =(const avltree_adaptor &) = delete;
  avltree_adaptor(avltree_adaptor &&x) noexcept
    : alloc_t(move(x.alloc_ref())) {
    new_data(move(x));
  }
  avltree_adaptor &operator =(avltree_adaptor &&x) noexcept {
    if (this != addressof(x))
      new_data(move(x));
    return *this;
  }
  friend void swap(avltree_adaptor &x, avltree_adaptor &y) noexcept {
    x.swap_data(y);
  }

  ~avltree_adaptor()
    requires traits::store_node_allocator::value {
    delete_data();
  }
  avltree_adaptor(const avltree_adaptor &x)
    requires traits::store_node_allocator::value
    : alloc_t(allocator_traits<alloc_t>
              ::select_on_container_copy_construction(x.alloc_ref())) {
    new_data(x);
  }
  avltree_adaptor &operator =(const avltree_adaptor &x)
    requires traits::store_node_allocator::value {
    allocator_aware_container_ownership<this_t>::copy_assign(*this, x);
    return *this;
  }
  avltree_adaptor &operator =(avltree_adaptor &&x)
    noexcept(alloc_move_prpg<alloc_t> || alloc_always_equal<alloc_t>)
    requires traits::store_node_allocator::value {
    allocator_aware_container_ownership<this_t>::move_assign(*this, x);
    return *this;
  }
  friend void swap(avltree_adaptor &x, avltree_adaptor &y)
    noexcept(alloc_swap_prpg<alloc_t> || alloc_always_equal<alloc_t>)
    requires traits::store_node_allocator::value {
    allocator_aware_container_ownership<this_t>::swap(x, y);
  }

  // optional container operations

  // reversible container

  using reverse_iterator = re::reverse_iterator<iterator>;
  using const_reverse_iterator = re::reverse_iterator<const_iterator>;

  reverse_iterator rbegin() noexcept {
    return reverse_iterator(end());
  }
  reverse_iterator rend() noexcept {
    return reverse_iterator(begin());
  }
  const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator(begin());
  }
  const_reverse_iterator crbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  const_reverse_iterator crend() const noexcept {
    return const_reverse_iterator(begin());
  }

  // allocator-aware container

  using allocator_type = typename TRAITS::allocator_type;
  alloc_t get_allocator() const noexcept {
    return alloc_ref();
  }

  explicit avltree_adaptor(const alloc_t &al) noexcept : alloc_t(al) {
    new_data();
  }
  avltree_adaptor(const this_t &x, const alloc_t &al) : alloc_t(al) {
    new_data(x);
  }
  avltree_adaptor(this_t &&x, const alloc_t &al) : alloc_t(al) {
    allocator_aware_container_ownership<this_t>::move_construct(*this, x);
  }

  // bst specilized operations

  template <class UPRED>
  iterator partition_point(UPRED eq) const {
    iterator ret = end().to_mutable();
    iterator it = root();
    for (;;) {
      if (it == nullptr)
        return ret;
      if (eq(*it))
        it = it.right_child();
      else {
        ret = it;
        it = it.left_child();
      }
    }
  }
  template <class GET_KEY, class KEY_LESS, class KEY>
  iterator find(GET_KEY get_key, KEY_LESS key_less, const KEY &key) const {
    const auto it = lower_bound(get_key, key_less, key);
    if (it != end() && !key_less(key, get_key(*it)))
      return it;
    return end().to_mutable();
  }
  template <class GET_KEY, class KEY_LESS, class KEY>
  iterator lower_bound(GET_KEY get_key, KEY_LESS key_less,
                       const KEY &key) const {
    return partition_point(bind(key_less, bind(get_key, _1), ref(key)));
  }
  template <class GET_KEY, class KEY_LESS, class KEY>
  iterator upper_bound(GET_KEY get_key, KEY_LESS key_less,
                       const KEY &key) const {
    return partition_point(bind(not_fn(key_less), ref(key), bind(get_key, _1)));
  }
  template <class GET_KEY, class KEY_LESS, class KEY>
  iter_pair<iterator> equal_range(GET_KEY get_key, KEY_LESS key_less,
                                  const KEY &key) const {
    return {
      lower_bound(get_key, key_less, key),
      upper_bound(get_key, key_less, key)
    };
  }
  template <class GET_KEY, class KEY_LESS, class KEY>
  size_type count(GET_KEY get_key, KEY_LESS key_less,
                  const KEY &key) const {
    return size(equal_range(get_key, key_less, key));
  }
  template <class GET_KEY, class KEY_LESS, class KEY, class KEY2>
  iter_pair<iterator> find_range(GET_KEY get_key, KEY_LESS key_less,
                                 const KEY &key, const KEY2 &key2) const {
    return {
      lower_bound(get_key, key_less, key),
      upper_bound(get_key, key_less, key2)
    };
  }

private:
  iterator unlink_impl(iterator it) noexcept {
    const iterator ret = next(it);
    if (it == leftmost()) {
      leftmost(ret);
      if (it == rightmost())
        rightmost(end());
    }
    else if (it == rightmost())
      rightmost(prev(it));

    const iterator parent = it.parent();
    if (it.left_child() == nullptr) {
      if (it.right_child() == nullptr) {
        if (it == parent.right_child()) {
          parent.right_child(iterator{});
          del_rebalance_minus(parent);
        }
        else {
          parent.left_child(iterator{});
          del_rebalance_plus(parent);
        }
      }
      else {
        const iterator rchild = it.right_child();
        rchild.parent(parent);
        if (it == parent.right_child()) {
          parent.right_child(rchild);
          del_rebalance_minus(parent);
        }
        else {
          parent.left_child(rchild);
          del_rebalance_plus(parent);
        }
      }
    }
    else {
      if (it.right_child() == nullptr) {
        const iterator lchild = it.left_child();
        lchild.parent(parent);
        if (it == parent.right_child()) {
          parent.right_child(lchild);
          del_rebalance_minus(parent);
        }
        else {
          parent.left_child(lchild);
          del_rebalance_plus(parent);
        }
      }
      else {
        const auto f = it.factor();
        const iterator next = ret;
        if (next.parent() == it) {
          if (it == parent.right_child())
            parent.right_child(next);
          else
            parent.left_child(next);
          next.parent(it.parent());

          next.left_child(it.left_child());
          next.left_child().parent(next);

          next.factor(f - 1);
          del_rebalance(next);          
        }
        else {
          const iterator p = next.parent();

          p.left_child(next.right_child());
          if (next.right_child() != nullptr)
            next.right_child().parent(p);

          if (it == parent.right_child())
            parent.right_child(next);
          else
            parent.left_child(next);
          next.parent(it.parent());

          next.left_child(it.left_child());
          next.left_child().parent(next);

          next.right_child(it.right_child());
          next.right_child().parent(next);

          next.factor(f);
          p.factor(p.factor() + 1);
          del_rebalance(p);
        }
      }
    }
    set_size(get_size() - 1u);

    return ret;
  }
public:
  iterator unlink(const_iterator it) noexcept {
    return unlink_impl(it.to_mutable());
  }
  iterator unlink(const_iterator from, const_iterator to) noexcept {
    while (from != to)
      from = unlink(from);
    return to.to_mutable();
  }
  void unlink() noexcept {
    new_data();
  }
  template <class GET_KEY, class KEY_LESS, class KEY>
  size_type unlink(GET_KEY get_key, KEY_LESS key_less, const KEY &key) {
    auto it = lower_bound(get_key, key_less, key);
    size_type c = 0;
    while (it != end() && !key_less(key, get_key(*it))) {
      it = unlink(it);
      ++c;
    }
    return c;
  }
  iterator erase(const_iterator it) {
    const auto ret = unlink(it);
    delete_node(it);
    return ret;
  }
  iterator erase(const_iterator from, const_iterator to) {
    while (from != to)
      from = erase(from);      
    return to.to_mutable();
  }
  template <class GET_KEY, class KEY_LESS, class KEY>
  size_type erase(GET_KEY get_key, KEY_LESS key_less, const KEY &key) {
    auto it = lower_bound(get_key, key_less, key);
    size_type c = 0;
    while (it != end() && !key_less(key, get_key(*it))) {
      it = erase(it);
      ++c;
    }
    return c;
  }
  template <class NODE_HANDLE>
  NODE_HANDLE extract(const_iterator it) {
    NODE_HANDLE ret(it.node(), alloc_ref());
    unlink(it);
    return ret;
  }
  template <class NODE_HANDLE, class GET_KEY, class KEY_LESS, class KEY>
  NODE_HANDLE extract(GET_KEY getkey, KEY_LESS keyless, const KEY &key) {
    const iterator it = lower_bound(getkey, keyless, key);
    return (it != end() && !keyless(key, getkey(*it)))
      ? extract<NODE_HANDLE>(it) : NODE_HANDLE{};
  }
  void clear() noexcept {
    delete_data();
    new_data();
  }

private:
  iterator link_impl(iterator pos, iterator node) {
    if (root() == nullptr)
      return insert_to_null(node);
    if (pos == end()) {
      insert_right(node, rightmost());
      rightmost(node);
    }
    else if (pos == begin()) {
      insert_left(node, leftmost());
      leftmost(node);
    }
    else {
      if (pos.left_child() == nullptr)
        insert_left(node, pos);
      else
        insert_right(node, prev(pos));
    }
    return node;
  }
public:
  iterator link(const_iterator pos, const_iterator node) {
    return link_impl(pos.to_mutable(), node.to_mutable());
  }
  template <class...S>
  iterator emplace(const_iterator i, S &&...s) {
    return link(i, new_node(forward<S>(s)...));
  }
  iterator insert(const_iterator i, const value_type &x) {
    return link(i, new_node(x));
  }
  iterator insert(const_iterator i, value_type &&x) {
    return link(i, new_node(move(x)));
  }
  template <class IITR_RANGE>
  enable_if_t<!is_convertible_v<IITR_RANGE &&, value_type &&>
              && !is_convertible_v<IITR_RANGE &&, const value_type &>,
              iterator>
  insert(const_iterator pos, IITR_RANGE &&r) {
    return insert_range(pos, r);
  }
  template <class IITR_RANGE>
  iterator insert_range(const_iterator pos, IITR_RANGE &&r) {
    if (empty(r))
      return pos.to_mutable();
    auto it = begin(r);
    const iterator ret = insert(pos, *it);
    for (auto &i : iters(++it, end(r)))
      insert(pos, *i);
    return ret;
  }
  template <class IITR_RANGE>
  void assign_range(IITR_RANGE &&r) {
    auto rr = rng(r);
    iterator it = begin();
    for (;;) {
      if (empty(rr)) {
        erase(it, end());
        return;
      }
      if (it == end()) {
        insert_range(end(), rr);
        return;
      }
      *it = *rr.first;
      ++it;
      ++rr.first;
    }
  }

  template <class GET_KEY, class KEY_LESS, class KEY,
            class GET_NEW_NODE, class DO_WHEN_EQUAL>
  pair<iterator, bool>
  insert(GET_KEY get_key, KEY_LESS key_less, const KEY &key,
         GET_NEW_NODE get_new_node, DO_WHEN_EQUAL do_when_equal) {
    if (root() == nullptr)
      return {insert_to_null(get_new_node()), true};
    const iterator it = lower_bound(get_key, key_less, key);
    if (it == end()) {
      const iterator new_it = get_new_node();
      insert_right(new_it, rightmost());
      rightmost(new_it);
      return {new_it, true};
    }
    else if (key_less(key, get_key(*it))) {
      if (it.left_child() == nullptr)
        return {insert_to_left(get_new_node(), it), true};
      else {
        const iterator new_it = get_new_node();
        insert_right(new_it, prev(it));
        return {new_it, true};
      }
    }
    else {
      do_when_equal(it);
      return {it, false};
    }
  }
  template <class GET_KEY, class KEY_LESS, class KEY, class GET_NEW_NODE>
  iterator insert_equal(GET_KEY get_key, KEY_LESS key_less, const KEY &key,
                        GET_NEW_NODE get_new_node) {
    if (root() == nullptr)
      return insert_to_null(get_new_node());
    iterator it = root();
    for (;;) {
      if (key_less(key, get_key(*it))) {
        if (it.left_child() == nullptr)
          return insert_to_left(get_new_node(), it);
        else
          it = it.left_child();
      }
      else {
        if (it.right_child() == nullptr)
          return insert_to_right(get_new_node(), it);
        else
          it = it.right_child();
      }
    }
  }

  template <class GET_KEY, class KEY_LESS, class KEY,
            class GET_NEW_NODE, class DO_WHEN_EQUAL>
  iterator insert(GET_KEY get_key, KEY_LESS key_less,
                  iterator hint, const KEY &key,
                  GET_NEW_NODE get_new_node, DO_WHEN_EQUAL do_when_equal) {
    if (root() == nullptr)
      return insert_to_null(get_new_node());
    else if (hint == end()) {
      if (key_less(get_key(*rightmost()), key)) {
        const iterator new_it = get_new_node();
        insert_right(new_it, rightmost());
        rightmost(new_it);
        return new_it;
      }
    }
    else if (hint == begin()) {
      if (key_less(key, get_key(*hint))) {
        const iterator new_it = get_new_node();
        insert_left(new_it, leftmost());
        leftmost(new_it);
        return new_it;
      }
    }
    else {
      const iterator it = prev(hint);
      if (key_less(get_key(*it), key) && key_less(key, get_key(*hint))) {
        const iterator new_it = get_new_node();
        if (hint.left_child() == nullptr)
          insert_left(new_it, hint);
        else
          insert_right(new_it, it);
        return new_it;
      }
    }
    return insert(get_key, key_less, key, get_new_node, do_when_equal).first;
  }
  template <class GET_KEY, class KEY_LESS, class KEY, class GET_NEW_NODE>
  iterator insert_equal(GET_KEY get_key, KEY_LESS key_less,
                        iterator hint, const KEY &key,
                        GET_NEW_NODE get_new_node) {
    if (root() == nullptr)
      return insert_to_null(get_new_node());
    else if (hint == end()) {
      if (!key_less(key, get_key(*rightmost()))) {
        const iterator new_it = get_new_node();
        insert_right(new_it, rightmost());
        rightmost(new_it);
        return new_it;
      }
    }
    else if (hint == begin()) {
      if (!key_less(get_key(*hint), key)) {
        const iterator new_it = get_new_node();
        insert_left(new_it, leftmost());
        leftmost(new_it);
        return new_it;
      }
    }
    else {
      const iterator it = prev(hint);
      if (!key_less(key, get_key(*it)) && !key_less(get_key(*hint), key)) {
        const iterator new_it = get_new_node();
        if (hint.left_child() == nullptr)
          insert_left(new_it, hint);
        else
          insert_right(new_it, it);
        return new_it;
      }
    }
    return insert_equal(get_key, key_less, key, get_new_node);
  }

  template <class GET_KEY, class KEY_LESS>
  pair<iterator, bool> link(GET_KEY get_key, KEY_LESS key_less,
                            iterator it) {
    return insert(get_key, key_less, get_key(*it), bind(copy, it),
                  empty_function{});
  }
  template <class GET_KEY, class KEY_LESS, class...S>
  enable_if_t<!is_convertible_v<GET_KEY &&, const_iterator>,
              pair<iterator, bool>>
  emplace(GET_KEY &&get_key, KEY_LESS key_less, S &&...s) {
    const auto it = new_node(forward<S>(s)...);
#ifndef RE_NOEXCEPT
    try {
#endif
      return insert(get_key, key_less, get_key(*it), bind(copy, it),
                    [=, this](auto) {delete_node(it);});
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      delete_node(it);
      throw;
    }
#endif
  }
  template <class GET_KEY, class KEY_LESS>
  pair<iterator, bool> insert(GET_KEY get_key, KEY_LESS key_less,
                              const value_type &x) {
    return insert(get_key, key_less, get_key(x),
                  [&]() {return new_node(x);}, empty_function{});
  }
  template <class GET_KEY, class KEY_LESS>
  pair<iterator, bool> insert(GET_KEY get_key, KEY_LESS key_less,
                              value_type &&x) {
    return insert(get_key, key_less, get_key(x),
                  [&]() {return new_node(move(x));}, empty_function{});
  }
  template <class GET_KEY, class KEY_LESS>
  iterator link(GET_KEY get_key, KEY_LESS key_less,
                iterator hint, iterator it) {
    return insert(get_key, key_less, hint, get_key(*it),
                  bind(copy, it), empty_function{});
  }
  template <class GET_KEY, class KEY_LESS, class...S>
  iterator emplace_hint(GET_KEY get_key, KEY_LESS key_less,
                        iterator hint, S &&...s) {
    const auto it = new_node(forward<S>(s)...);
#ifndef RE_NOEXCEPT
    try {
#endif
      return insert(get_key, key_less, hint, get_key(*it), bind(copy, it),
                    [=, this](auto) {delete_node(it);});
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      delete_node(it);
      throw;
    }
#endif
  }
  template <class GET_KEY, class KEY_LESS>
  iterator insert(GET_KEY get_key, KEY_LESS key_less,
                  iterator hint, const value_type &x) {
    return insert(get_key, key_less, hint, get_key(x),
                  [&]() {return new_node(x);}, empty_function{});
  }
  template <class GET_KEY, class KEY_LESS>
  iterator insert(GET_KEY get_key, KEY_LESS key_less,
                  iterator hint, value_type &&x) {
    return insert(get_key, key_less, hint, get_key(x),
                  [&]() {return new_node(move(x));}, empty_function{});
  }

  template <class GET_KEY, class KEY_LESS, class KEY, class...S>
  pair<iterator, bool>
  try_emplace(GET_KEY get_key, KEY_LESS key_less, KEY &&key, S &&...s) {
    return insert(get_key, key_less, key,
                  [&]() {return new_node(piecewise_construct,
                                         forward_as_tuple(forward<KEY>(key)),
                                         forward_as_tuple(forward<S>(s)...));},
                  empty_function{});
  }
  template <class GET_KEY, class KEY_LESS, class KEY, class...S>
  iterator try_emplace_hint(GET_KEY get_key, KEY_LESS key_less,
                            iterator hint, KEY &&key, S &&...s) {
    return insert(get_key, key_less, hint, key,
                  [&]() {return new_node(piecewise_construct,
                                         forward_as_tuple(forward<KEY>(key)),
                                         forward_as_tuple(forward<S>(s)...));},
                  empty_function{});
  }
  template <class GET_KEY, class GET_MAPPED, class KEY_LESS, class KEY, class X>
  pair<iterator, bool>
  insert_or_assign(GET_KEY get_key, GET_MAPPED get_mapped, KEY_LESS key_less,
                   KEY &&key, X &&x) {
    return insert(get_key, key_less, key,
                  [&]() {return new_node(forward<KEY>(key), forward<X>(x));},
                  [&](iterator pos) {get_mapped(*pos) = forward<X>(x);});
  }
  template <class GET_KEY, class GET_MAPPED, class KEY_LESS, class KEY, class X>
  iterator insert_or_assign(GET_KEY get_key, GET_MAPPED get_mapped,
                            KEY_LESS key_less,
                            iterator hint, KEY &&key, X &&x) {
    return insert(get_key, key_less, hint, key,
                  [&]() {return new_node(forward<KEY>(key), forward<X>(x));},
                  [&](iterator pos) {get_mapped(*pos) = forward<X>(x);});
  }
  template <class ITERATOR, class GET_KEY, class KEY_LESS, class NODE_HANDLE>
  inner::node_handle_insert_return_type
  <ITERATOR, remove_reference_t<NODE_HANDLE>>
  insert_node_handle(GET_KEY get_key, KEY_LESS key_less, NODE_HANDLE &&nh) {
    inner::node_handle_insert_return_type
      <ITERATOR, remove_reference_t<NODE_HANDLE>> ret;
    if (nh.empty()) {
      ret.position = end();
      ret.inserted = false;
    }
    else {
      tie(ret.position, ret.inserted)
        = insert(get_key, key_less, get_key(*ITERATOR(nh.get())),
                 [&]() {return iterator(nh.release());}, empty_function{});
      ret.node = move(nh);
    }
    return ret;
  }
  template <class GET_KEY, class KEY_LESS, class NODE_HANDLE>
  iterator insert_node_handle(GET_KEY get_key, KEY_LESS key_less,
                              iterator hint, NODE_HANDLE &&nh) {
    return nh.empty()
      ? end()
      : insert(get_key, key_less, hint,
               get_key(*iterator(nh.get())),
               [&]() {return iterator(nh.release());},
               empty_function{});
  }

  template <class GET_KEY, class KEY_LESS>
  iterator link_equal(GET_KEY get_key, KEY_LESS key_less,
                      iterator it) noexcept {
    return insert_equal(get_key, key_less, get_key(*it), bind(copy, it));
  }
  template <class GET_KEY, class KEY_LESS>
  iterator link_equal(GET_KEY get_key, KEY_LESS key_less,
                      iterator hint, iterator it) noexcept {
    return insert_equal(get_key, key_less, hint, get_key(*it), bind(copy, it));
  }
  template <class GET_KEY, class KEY_LESS, class...S>
  iterator emplace_equal(GET_KEY get_key, KEY_LESS key_less, S &&...s) {
    const auto it = new_node(forward<S>(s)...);
#ifndef RE_NOEXCEPT
    try {
#endif
      return insert_equal(get_key, key_less, get_key(*it), bind(copy, it));
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      delete_node(it);
      throw;
    }
#endif
  }
  template <class GET_KEY, class KEY_LESS, class...S>
  iterator emplace_equal_hint(GET_KEY get_key, KEY_LESS key_less,
                              iterator hint, S &&...s) {
    const auto it = new_node(forward<S>(s)...);
#ifndef RE_NOEXCEPT
    try {
#endif
      return insert_equal(get_key, key_less,
                          hint, get_key(*it), bind(copy, it));
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      delete_node(it);
      throw;
    }
#endif
  }
  template <class GET_KEY, class KEY_LESS, class NODE_HANDLE>
  iterator insert_node_handle_equal(GET_KEY get_key, KEY_LESS key_less,
                                    NODE_HANDLE &&nh) {
    return nh.empty()
      ? end()
      : insert_equal(get_key, key_less, get_key(*iterator(nh.get())),
                     [&]() {return iterator(nh.release());});
  }
  template <class GET_KEY, class KEY_LESS, class NODE_HANDLE>
  iterator insert_node_handle_equal(GET_KEY get_key, KEY_LESS key_less,
                                    iterator hint, NODE_HANDLE &&nh) {
    return nh.empty()
      ? end()
      : insert_equal(get_key, key_less, hint, get_key(*iterator(nh.get())),
                     [&]() {return iterator(nh.release());});
  }

  template <class GET_KEY, class KEY_LESS, class ANALOGOUS>
  void merge(GET_KEY get_key, KEY_LESS key_less, ANALOGOUS &&other) {
    if (this != addressof(other))
      for (iterator it = other.begin(), ed = other.end(); it != ed;)
        insert(get_key, key_less, get_key(*it),
               [&]() {return exchange(it, other.unlink(it));},
               [&](...) {++it;});
  }

  template <class GET_KEY, class KEY_LESS, class ANALOGOUS>
  void merge_equal(GET_KEY get_key, KEY_LESS key_less, ANALOGOUS &&other) {
    if (this != addressof(other))
      for (iterator it = other.begin(), ed = other.end(); it != ed;)
        insert_equal(get_key, key_less, get_key(*it),
                     [&]() {return exchange(it, other.unlink(it));});
  }

  template <class GET_KEY, class KEY_LESS, class R>
  void insert_range(GET_KEY get_key, KEY_LESS key_less, R &&r) {
    for (auto &it : iters(r))
      emplace(get_key, key_less, *it);
  }
  template <class GET_KEY, class KEY_LESS, class R,
            class INSERT_RANGE>
  void assign_range(GET_KEY get_key, KEY_LESS key_less, R &&r,
                    INSERT_RANGE insert_range_fn) {
    const iterator root_node = root();
    end().right_child(iterator{});
    inner::bst_helper::link_bst_to_forward_list(end(), root_node);
    iterator hook = end().right_child();
    const auto guard = exit_fn([&]() {
      for_each_node(rng(hook, iterator{}),
                    [](auto it) {return it.right_child();},
                    [&](auto it) {delete_node(it);});
    });
    new_data();
    for (auto &it : iters(r)) {
      if (hook != nullptr) {
        *hook = *it;
        insert(get_key, key_less, get_key(*hook),
               [&]() {return exchange(hook, hook.right_child());},
               empty_function{});
      }
      else {
        insert_range_fn(rng(it, end(r)));
        return;
      }
    }
  }
  template <class GET_KEY, class KEY_LESS, class R>
  void assign_range(GET_KEY get_key, KEY_LESS key_less, R &&r) {
    assign_range(get_key, key_less, r,
                 [=, this](auto &&r) {insert_range(get_key, key_less, r);});
  }

  template <class GET_KEY, class KEY_LESS, class R>
  void insert_range_equal(GET_KEY get_key, KEY_LESS key_less, R &&r) {
    for (auto &it : iters(r))
      emplace_equal(get_key, key_less, *it);
  }
  template <class GET_KEY, class KEY_LESS, class R>
  void assign_range_equal(GET_KEY get_key, KEY_LESS key_less, R &&r) {
    const iterator root_node = root();
    end().right_child(iterator{});
    inner::bst_helper::link_bst_to_forward_list(end(), root_node);
    iterator hook = end().right_child();
    const auto guard = exit_fn([&]() {
      for_each_node(rng(hook, iterator{}),
                    [](auto it) {return it.right_child();},
                    [&](auto it) {delete_node(it);});
    });
    new_data();
    for (auto &it : iters(r)) {
      if (hook != nullptr) {
        *hook = *it;
        insert_equal(get_key, key_less, get_key(*hook),
                     [&]() {return exchange(hook, hook.right_child());});
      }
      else {
        insert_range_equal(get_key, key_less, rng(it, end(r)));
        return;
      }
    }
  }

private:
  static bool good_recurse(iterator it) {
    if (it == nullptr)
      return true;
    const auto f = it.factor();
    if (f == 1)
      return it.left_child().max_depth() + 1 == it.right_child().max_depth();
    else if (f == -1)
      return it.right_child().max_depth() + 1 == it.left_child().max_depth();
    else if (f == 0)
      return it.right_child().max_depth() == it.left_child().max_depth();
    else
      return false;
    return good_recurse(it.left_child()) && good_recurse(it.right_child());
  }
  friend struct inner::fo_good;
  bool good() const noexcept {
    return good_recurse(root());
  }
};
template <class TRAITS>
bool operator ==(const avltree_adaptor<TRAITS> &x,
                 const avltree_adaptor<TRAITS> &y) {
  return equal(x, y);
}
template <class TRAITS>
synth_3way_result<typename TRAITS::value_type>
operator <=>(const avltree_adaptor<TRAITS> &x,
             const avltree_adaptor<TRAITS> &y) {
  return lexicographical_synth_3way(x, y);
}

}
// ranked_rbree_adaptor
namespace re {

template <size_t ID = 0, class VOID_PTR = void *>
struct rrbt_node_base {
  pointer_rebind_t<VOID_PTR, rrbt_node_base> left_child;
  pointer_rebind_t<VOID_PTR, rrbt_node_base> right_child;
  pointer_rebind_t<VOID_PTR, rrbt_node_base> parent;
};
template <size_t ID = 0, class VOID_PTR = void *>
struct join_ranked_rbtree : public rrbt_node_base<ID, VOID_PTR> {
  ptrdiff_t state;
};
template <class T, class VOID_PTR = void *>
struct ranked_rbtree_node : join_ranked_rbtree<0, VOID_PTR> {
  alignas(T) byte data[sizeof(T)];

  T *operator *() const {
    return reinterpret_cast<T *>(addressof(data));
  }
  T &operator ->() const {
    return *operator *();
  }
};
namespace inner {

template <class NODE_BASE_TYPE>
struct ranked_rbtree_header_data {
  mutable NODE_BASE_TYPE ed;
};

}

template <class NODE_T, size_t ID = 0, bool STORE_NODE_ALLOCATOR = false,
          class AL = default_allocator<NODE_T>>
struct ranked_rbtree_traits {
  using value_type = alloc_vt<AL>;
  using allocator_type = AL;
  using node_type = NODE_T;
  using node_pointer = alloc_rebind_ptr<AL, node_type>;
  using node_base_type = rrbt_node_base<ID, alloc_void_ptr<AL>>;
  using node_base_pointer = alloc_rebind_ptr<AL, node_base_type>;
  using difference_type = alloc_dft<AL>;
  using size_type = alloc_szt<AL>;

  using id = size_constant<ID>;
  using store_node_allocator = bool_constant<STORE_NODE_ALLOCATOR>;
  using store_allocator = bool_constant<STORE_NODE_ALLOCATOR>;

  static node_base_pointer left_child(node_base_pointer p) {
    return p->left_child;
  }
  static void left_child(node_base_pointer p, node_base_pointer p2) {
    p->left_child = p2;
  }

  static node_base_pointer right_child(node_base_pointer p) {
    return p->right_child;
  }
  static void right_child(node_base_pointer p, node_base_pointer p2) {
    p->right_child = p2;
  }

  static node_base_pointer parent(node_base_pointer p) {
    return p->parent;
  }
  static void parent(node_base_pointer p, node_base_pointer p2) {
    p->parent = p2;
  }

  static ptrdiff_t state(node_base_pointer p) {
    return static_cast<join_ranked_rbtree<ID, alloc_void_ptr<AL>> &>(*p).state;
  }
  static void state(node_base_pointer p, ptrdiff_t n) {
    static_cast<join_ranked_rbtree<ID, alloc_void_ptr<AL>> &>(*p).state = n;
  }

  template <class VT = value_type>
  static enable_if_t<!is_same_v<VT, node_type>, value_type *>
  data(node_base_pointer p) {
    return reinterpret_cast<value_type *>(addressof
                                          (static_cast<node_type &>(*p).data));
  }
  template <class VT = value_type>
  static enable_if_t<is_same_v<VT, node_type>, value_type *>
  data(node_base_pointer p) {
    return to_address(static_cast<node_pointer>(p));
  }

  using header_type
    = inner::ranked_rbtree_header_data<node_base_type>;
  static node_base_pointer end_node(const header_type &h) {
    return pointer_traits<node_base_pointer>
      ::pointer_to(static_cast<node_base_type &>(h.ed));
  }

  template <class...S, class VT = value_type>
  static enable_if_t<!is_same_v<VT, node_type>, node_base_pointer>
  new_node(AL &al, S &&...s) {
    return allocator_wrapper<AL>(al)
      .template new_node<node_type>(forward<S>(s)...);
  }
  template <class VT = value_type>
  static enable_if_t<!is_same_v<VT, node_type>>
  delete_node(AL &al, node_base_pointer p) noexcept {
    allocator_wrapper<AL>(al).delete_node(static_cast<node_pointer>(p));
  }

  template <class...S, class VT = value_type>
  static enable_if_t<is_same_v<VT, node_type>, node_base_pointer>
  new_node(AL &al, S &&...s) {
    return static_cast<node_base_pointer>
      (allocator_wrapper<AL>(al).new_1(forward<S>(s)...));
  }
  template <class VT = value_type>
  static enable_if_t<is_same_v<VT, node_type>>
  delete_node(AL &al, node_base_pointer p) noexcept {
    allocator_wrapper<AL>(al).delete_1(static_cast<node_pointer>(p));
  }
};

template <class>
class ranked_rbtree_adaptor;
namespace inner {

template <class T, class TRAITS, bool PROMOTED = false>
class rrbt_iterator {
  static_assert(is_same_v<remove_const_t<T>, typename TRAITS::value_type>);

  using this_t = rrbt_iterator;

  friend struct re::inner::bst_helper;
  template <class>
  friend class re::ranked_rbtree_adaptor;
  template <class, class, bool>
  friend class rrbt_iterator;

  using node_pointer = typename TRAITS::node_base_pointer;
  node_pointer p{};

public:
  using value_type = remove_const_t<T>;
  using pointer = T *;
  using reference = T &;
  using difference_type = typename TRAITS::difference_type;
  using iterator_category = conditional_t
    <PROMOTED, random_access_iterator_tag, bidirectional_iterator_tag>;

  rrbt_iterator() = default;
  rrbt_iterator(const this_t &) = default;
  rrbt_iterator &operator =(const this_t &) = default;
  rrbt_iterator(this_t &&) = default;
  rrbt_iterator &operator =(this_t &&) = default;
  friend void swap(this_t &x, this_t &y) noexcept {
    adl_swap(x.p, y.p);
  }

  template <class TT = T, class = enable_if_t<is_const_v<TT>>>
  rrbt_iterator(rrbt_iterator<remove_const_t<TT>, TRAITS, PROMOTED> it)
    : p(it.p) {}
  template <class TT = T, class = enable_if_t<is_const_v<TT>>>
  this_t &operator =(rrbt_iterator
                     <remove_const_t<TT>, TRAITS, PROMOTED> it) {
    p = it.p;
    return *this;
  }

  explicit rrbt_iterator(node_pointer p) : p(p) {}
  node_pointer node() const {
    return p;
  }
  auto to_mutable() const requires is_const_v<T> {
    return rrbt_iterator<remove_const_t<T>, TRAITS, PROMOTED>(p);
  }
  auto promote() const requires (!PROMOTED) {
    return rrbt_iterator<T, TRAITS, true>(p);
  }

private:
  this_t left_child() const {
    return this_t(TRAITS::left_child(p));
  }
  void left_child(this_t p2) const {
    TRAITS::left_child(p, p2.node());
  }
  this_t right_child() const {
    return this_t(TRAITS::right_child(p));
  }
  void right_child(this_t p2) const {
    TRAITS::right_child(p, p2.node());
  }
  this_t parent() const {
    return this_t(TRAITS::parent(p));
  }
  void parent(this_t p2) const {
    TRAITS::parent(p, p2.node());
  }
  ptrdiff_t state() const {
    return TRAITS::state(p);
  }
  void state(ptrdiff_t x) const {
    return TRAITS::state(p, x);
  }
  void state(bool red, typename TRAITS::size_type sz) const {
    TRAITS::state(p, red ? ptrdiff_t(sz) : -ptrdiff_t(sz));
  }
  bool red() const {
    return TRAITS::state(p) > 0;
  }
  void red(bool y) const {
    if (red() != y)
      TRAITS::state(p, -TRAITS::state(p));
  }
  typename TRAITS::size_type size() const {
    const ptrdiff_t x = TRAITS::state(p);
    return x < 0 ? -x : x;
  }
  void size(typename TRAITS::size_type n) const {
    if (TRAITS::state(p) < 0)
      TRAITS::state(p, -ptrdiff_t(n));
    else
      TRAITS::state(p, n);
  }
  typename TRAITS::size_type get_size() const {
    return p == nullptr ? 0 : size();
  }
  void size_inc(typename TRAITS::difference_type n = 1) const {
    if (TRAITS::state(p) < 0)
      TRAITS::state(p, TRAITS::state(p) - n);
    else
      TRAITS::state(p, TRAITS::state(p) + n);
  }
  void size_dec(typename TRAITS::difference_type n = 1) const {
    if (TRAITS::state(p) < 0)
      TRAITS::state(p, TRAITS::state(p) + n);
    else
      TRAITS::state(p, TRAITS::state(p) - n);
  }

  void rotate_left(this_t b) const {
    const auto &a = *this;

    const auto b_l = b.left_child();
    if (b_l != nullptr)
      b_l.parent(a);
    a.right_child(b_l);

    const auto a_p = a.parent();
    a_p.right_child() == a ? a_p.right_child(b) : a_p.left_child(b);
    b.parent(a_p);

    b.left_child(a);
    a.parent(b);
  }
  void rotate_right(this_t b) const {
    const auto &a = *this;

    const auto b_r = b.right_child();
    if (b_r != nullptr)
      b_r.parent(a);
    a.left_child(b_r);

    const auto a_p = a.parent();
    a_p.right_child() == a ? a_p.right_child(b) : a_p.left_child(b);
    b.parent(a_p);

    b.right_child(a);
    a.parent(b);
  }
  void rotate_right_left(this_t b, this_t c) const {
    const auto &a = *this;
    const auto a_p = a.parent();
    const auto c_l = c.left_child();
    const auto c_r = c.right_child();

    a_p.right_child() == a ? a_p.right_child(c) : a_p.left_child(c);
    c.parent(a_p);

    a.right_child(c_l);
    if (c_l != nullptr)
      c_l.parent(a);

    b.left_child(c_r);
    if (c_r != nullptr)
      c_r.parent(b);

    c.left_child(a);
    a.parent(c);

    c.right_child(b);
    b.parent(c);
  }
  void rotate_left_right(this_t b, this_t c) const {
    const auto &a = *this;
    const auto a_p = a.parent();
    const auto c_l = c.left_child();
    const auto c_r = c.right_child();

    a_p.right_child() == a ? a_p.right_child(c) : a_p.left_child(c);
    c.parent(a_p);

    a.left_child(c_r);
    if (c_r != nullptr)
      c_r.parent(a);

    b.right_child(c_l);
    if (c_l != nullptr)
      c_l.parent(b);

    c.right_child(a);
    a.parent(c);

    c.left_child(b);
    b.parent(c);
  }

  void calc_max_depth(typename TRAITS::size_type &result,
                      typename TRAITS::size_type now = 1) const {
    if (p == nullptr)
      return;
    if (now > result)
      result = now;
    left_child().calc_max_depth(result, now + 1);
    right_child().calc_max_depth(result, now + 1);
  }
  void calc_min_depth(typename TRAITS::size_type &result,
                      typename TRAITS::size_type now = 0) const {
    if (p == nullptr) {
      if (result == 0u)
        result = now;
      else if (now < result)
        result = now;
      return;
    }
    left_child().calc_min_depth(result, now + 1);
    right_child().calc_min_depth(result, now + 1);
  }

  typename TRAITS::size_type max_depth() const {
    typename TRAITS::size_type result = 0;
    calc_max_depth(result);
    return result;
  }
  typename TRAITS::size_type min_depth() const {
    typename TRAITS::size_type result = 0;
    calc_min_depth(result);
    return result;
  }

public:
  reference operator *() const {
    return *TRAITS::data(p);
  }
  pointer operator ->() const {
    return TRAITS::data(p);
  }

  this_t &operator ++() {
    if (right_child() != nullptr) {
      *this = right_child();
      while (left_child() != nullptr)
        *this = left_child();
    }
    else {
      while (*this == parent().right_child())
        *this = parent();
      if (*this == parent().left_child())
        *this = parent();
    }
    return *this;
  }
  this_t operator ++(int) {
    return iter_post_increment(*this);
  }

  this_t &operator --() {
    if (left_child() != nullptr) {
      *this = left_child();
      while (right_child() != nullptr)
        *this = right_child();
    }
    else {
      while (*this == parent().left_child())
        *this = parent();
      *this = parent();
    }
    return *this;
  }
  this_t operator --(int) {
    return iter_post_decrement(*this);
  }

  reference operator [](difference_type i) const {
    return *(this_t(*this) += i);
  }
  this_t &operator +=(difference_type i) {
    const auto is_end = [](this_t it) {
      return it.parent().left_child() == nullptr
        && it.parent().right_child() != it;
    };

    if (i == 0)
      return *this;
    if (is_end(*this)) {
      *this = right_child();
      i = i + to_signed(get_size());
      goto go_down;
    }

    for (;;) {
      if (i > 0) {
        const difference_type r_sz = right_child().get_size();
        if (r_sz >= i) {
          --i;
          *this = right_child();
          goto go_down;
        }
        if (parent().right_child() == *this && !is_end(parent()))
          i += size() - r_sz;
        else
          i -= r_sz + 1;
      }
      else {
        const difference_type l_sz = left_child().get_size();
        if (l_sz >= -i) {
          i += l_sz;
          *this = left_child();
          goto go_down;
        }
        if (parent().right_child() == *this && !is_end(parent()))
          i += l_sz + 1;
        else
          i -= size() - l_sz;
      }
      *this = parent();
      if (i == 0)
        return *this;
    }

  go_down:
    for (;;) {
      const difference_type l_n = left_child().get_size();
      const difference_type dif = i - l_n;
      if (dif == 0)
        return *this;
      else if (dif < 0)
        *this = left_child();
      else {
        i -= l_n + 1;
        *this = right_child();
      }
    }
  }
  this_t &operator -=(difference_type i) {
    operator +=(-i);
    return *this;
  }

  difference_type nth() const {
    const auto is_end = [](this_t it) {
      return it.parent() == it
        || (it.parent().left_child() == nullptr
            && it.parent().right_child() != it);
    };
    this_t it = *this;
    if (is_end(it))
      return it.right_child().get_size();
    difference_type n = it.left_child().get_size();
    for (;;) {
      const this_t pp = it.parent();
      if (is_end(pp))
        return n;
      else {
        if (it == pp.right_child())
          n += pp.left_child().get_size() + 1u;
        it = pp;
      }
    }
  }
};
template <class A, class AA, class B, bool P>
enable_if_t<is_same_v<remove_const_t<A>, remove_const_t<AA>>, bool>
operator ==(rrbt_iterator<A, B, P> x, rrbt_iterator<AA, B, P> y) {
  return x.node() == y.node();
}
template <class A, class AA, class B, bool P>
enable_if_t<is_same_v<remove_const_t<A>, remove_const_t<AA>>,
            strong_ordering>
operator <=>(rrbt_iterator<A, B, P> x, rrbt_iterator<AA, B, P> y) {
  return x.nth() <=> y.nth();
}
template <class A, class B, bool P>
bool operator ==(rrbt_iterator<A, B, P> x, nullptr_t) {
  return x.node() == nullptr;
}
template <class T, class TRAITS, bool P>
rrbt_iterator<T, TRAITS, P>
operator +(itr_dft<rrbt_iterator<T, TRAITS, P>> i,
           rrbt_iterator<T, TRAITS, P> x) {
  return copy(x) += i;
}
template <class T, class TRAITS, bool P>
rrbt_iterator<T, TRAITS, P>
operator +(rrbt_iterator<T, TRAITS, P> x,
           itr_dft<rrbt_iterator<T, TRAITS, P>> i) {
  return copy(x) += i;
}
template <class T, class TRAITS, bool P>
rrbt_iterator<T, TRAITS, P>
operator -(rrbt_iterator<T, TRAITS, P> x,
           itr_dft<rrbt_iterator<T, TRAITS, P>> i) {
  return copy(x) -= i;
}
template <class T, class TT, class TRAITS, bool P,
          class = enable_if_t<is_same_v<remove_const_t<T>, remove_const_t<TT>>>>
auto operator -(rrbt_iterator<T, TRAITS, P> x,
                rrbt_iterator<TT, TRAITS, P> y) {
  return x.nth() - y.nth();
}

}
template <class TRAITS>
class ranked_rbtree_adaptor
  : TRAITS::header_type
  , conditional_t<!TRAITS::store_node_allocator::value,
                  inner::empty_type, typename TRAITS::allocator_type> {
  using this_t = ranked_rbtree_adaptor;

  using data_t = typename TRAITS::header_type;
  data_t &data_ref() {
    return static_cast<data_t &>(*this);
  }
  const data_t &data_ref() const {
    return static_cast<const data_t &>(*this);
  }

  using alloc_t = conditional_t<!TRAITS::store_node_allocator::value,
                                inner::empty_type,
                                typename TRAITS::allocator_type>;

  template <class R>
  static auto begin(R &&r) {return re::begin(r);}
  template <class R>
  static auto end(R &&r) {return re::end(r);}
  template <class R>
  static auto rbegin(R &&r) {return re::rbegin(r);}
  template <class R>
  static auto rend(R &&r) {return re::rend(r);}
  template <class R>
  static auto size(R &&r) {return re::size(r);}
  template <class R>
  static auto empty(R &&r) {return re::empty(r);}

public:

  using traits = TRAITS;
  using node_pointer = typename traits::node_base_pointer;

  // container

  using value_type = typename traits::value_type;
  using reference = value_type &;
  using const_reference = const value_type &;

  using iterator = inner::rrbt_iterator<value_type, traits>;
  using const_iterator = inner::rrbt_iterator<const value_type, traits>;
  using difference_type = typename traits::difference_type;
  using size_type = typename traits::size_type;

  iterator begin() noexcept {
    return leftmost();
  }
  iterator end() noexcept {
    return iterator(traits::end_node(data_ref()));
  }
  const_iterator begin() const noexcept {
    return leftmost();
  }
  const_iterator end() const noexcept {
    return iterator(traits::end_node(data_ref()));
  }
  const_iterator cbegin() const noexcept {
    return begin();
  }
  const_iterator cend() const noexcept {
    return end();
  }

  size_type max_size() const noexcept {
    return container_regular_max_size<this_t>();
  }
  size_type size() const noexcept {
    return root().get_size();
  }
  bool empty() const noexcept {
    return root() == nullptr;
  }

  // node operations

  template <class...S>
  iterator new_node(S &&...s) {
    return iterator(traits::new_node(alloc_ref(), forward<S>(s)...));
  }
  void delete_node(const_iterator it) noexcept {
    traits::delete_node(alloc_ref(), it.node());
  }
  void delete_tree(const_iterator it) noexcept {
    inner::bst_helper::delete_bst_node_recursively
      (it, [&](auto i) {delete_node(i);});
  }
  iterator exchange_node(const_iterator i, const_iterator x) noexcept {
    if (i.parent().right_child() == i)
      i.parent().right_child(x);
    else
      i.parent().left_child(x);
    if (i.left_child() != nullptr)
      i.left_child().parent(x);
    if (i.right_child() != nullptr)
      i.right_child().parent(x);
    x.parent(i.parent());
    x.left_child(i.left_child());
    x.right_child(i.right_child());
    x.state(i.state());
    if (i == root())
      root(x.to_mutable());
    if (i == leftmost())
      leftmost(x.to_mutable());
    if (i == rightmost())
      rightmost(x.to_mutable());
    return i.to_mutable();
  }

  iterator root() const noexcept {
    return end().to_mutable().right_child();
  }
  iterator leftmost() const noexcept {
    return end().to_mutable().parent();
  }
  iterator rightmost() const noexcept {
    return end().to_mutable().left_child();
  }

private:
  // inner implements

  void root(iterator it) noexcept {
    end().right_child(it);
  }
  void leftmost(iterator it) noexcept {
    end().parent(it);
  }
  void rightmost(iterator it) noexcept {
    end().left_child(it);
  }

  void relink(iterator root_node) noexcept {
    if (root_node == nullptr)
      new_data();
    else {
      root(root_node);
      root().parent(end());

      iterator it;
      for (it = root(); it.left_child() != nullptr;)
        it = it.left_child();
      leftmost(it);
      for (it = root(); it.right_child() != nullptr;)
        it = it.right_child();
      rightmost(it);
    }
  }
  void relink_end() noexcept {
    if (root() != nullptr)
      root().parent(end()); // relink root node with end node
    else {
      leftmost(end());
      rightmost(end());
    }
  }

  friend struct inner::bst_helper;

  friend class allocator_aware_container_ownership<this_t>;
  const alloc_t &alloc_ref() const noexcept {
    return static_cast<const alloc_t &>(*this);
  }
  alloc_t &alloc_ref() noexcept {
    return static_cast<alloc_t &>(*this);
  }
  void new_data() noexcept {
    leftmost(end());
    root(iterator{});
    rightmost(end());
  }
  void delete_data() noexcept {
    delete_tree(root());
  }
  void new_data(const this_t &x) {
    inner::bst_helper::bst_clone_data_impl(*this, x, identity{});
  }
  void assign_data(const this_t &x) {
    inner::bst_helper::bst_assign_data_impl(*this, x, identity{});
  }
  void new_data(this_t &&x) noexcept {
    data_ref() = move(x.data_ref());
    relink_end();
    x.new_data();
  }
  void new_data_individually(this_t &&x) {
    const auto guard = exit_fn([&]() {
      x.delete_data();
      x.new_data();
    });
    inner::bst_helper::bst_clone_data_impl(*this, x, move);
  }
  void assign_data_individually(this_t &&x) {
    const auto guard = exit_fn([&]() {
      x.delete_data();
      x.new_data();
    });
    inner::bst_helper::bst_assign_data_impl(*this, x, move);
  }
  void swap_data(this_t &x) noexcept {
    adl_swap(data_ref(), x.data_ref());
    relink_end();
    x.relink_end();
  }

  void recursive_size_inc(iterator it, size_type n = 1) noexcept {
    for (; it != end(); it = it.parent())
      it.size_inc(n);
  }
  void recursive_size_dec(iterator it, size_type n = 1) noexcept {
    for (; it != end(); it = it.parent())
      it.size_dec(n);
  }

  static void rotate_left(iterator a, iterator b) noexcept {
    a.rotate_left(b);
    const auto n = a.size();
    b.size(n);
    a.size(n - b.right_child().get_size() - 1u);
  }
  static void rotate_right(iterator a, iterator b) {
    a.rotate_right(b);
    const auto n = a.size();
    b.size(n);
    a.size(n - b.left_child().get_size() - 1u);
  }
  static void rotate_left_right(iterator a, iterator b, iterator c) {
    a.rotate_left_right(b, c);
    const auto n = a.size();
    c.size(n);
    b.size(b.left_child().get_size() + b.right_child().get_size() + 1u);
    a.size(n - b.size() - 1);
  }
  static void rotate_right_left(iterator a, iterator b, iterator c) {
    a.rotate_right_left(b, c);
    const auto n = a.size();
    c.size(n);
    b.size(b.left_child().get_size() + b.right_child().get_size() + 1u);
    a.size(n - b.size() - 1);
  }

  // ins_rebalance(new_it, it) requires:
  //   1) it != end(),
  //   2) it is the parent of new_it, it is red
  //   3) new_it is red
  //   4) every path except those via new_it conform to the rule of rbtree
  void ins_rebalance(iterator new_it, iterator it) noexcept {
    for (iterator p, u; it.red();) {
      p = it.parent(); // p is impossible to be end node

      if (it == p.right_child()) {
        u = p.left_child();
        if (u == nullptr || !u.red()) {
          if (new_it == it.left_child()) {
            rotate_right_left(p, it, new_it);
            new_it.red(false);
            p.red(true);
          }
          else {
            rotate_left(p, it);
            it.red(false);
            p.red(true);
          }
          return;
        }
      }
      else {
        u = p.right_child();
        if (u == nullptr || !u.red()) {
          if (new_it == it.right_child()) {
            rotate_left_right(p, it, new_it);
            new_it.red(false);
            p.red(true);
          }
          else {
            rotate_right(p, it);
            it.red(false);
            p.red(true);
          }
          return;
        }
      }

      it.red(false);
      u.red(false);
      if (p == root())
        return;
      p.red(true);
      new_it = p;
      it = p.parent();
    }
  }

  // del_rebalance(p, c) requires:
  //   1) p is the parent of c
  //   2) c is black (c never be red because the attributes of rbtree)
  //   3) every path via c has same count of black nodes, every path not via c
  //      has same count of black nodes
  //   4) every path via c lost one black node by deletion
  void del_rebalance(iterator p, iterator c) noexcept {
    iterator u;
    while (p != end()) {
      if (c == p.right_child()) {
        u = p.left_child();
        if (p.red()) {
        P_IS_RED:
          if (u.right_child() == nullptr || !u.right_child().red())
            rotate_right(p, u);
          else {
            p.red(false);
            rotate_left_right(p, u, u.right_child());
          }
          return;
        }
        else {
          if (u.red()) {
            p.red(true);
            u.red(false);
            rotate_right(p, u);
            u = p.left_child();
            goto P_IS_RED;
          }
          else {
            if (u.left_child() == nullptr || !u.left_child().red()) {
              if (u.right_child() == nullptr || !u.right_child().red()) {
                u.red(true);
                c = p;
                p = p.parent();
              }
              else {
                u.right_child().red(false);
                rotate_left_right(p, u, u.right_child());
                return;
              }
            }
            else {
              u.left_child().red(false);
              rotate_right(p, u);
              return;
            }
          }
        }
      }
      else {
        u = p.right_child();
        if (p.red()) {
        P_IS_RED_2:
          if (u.left_child() == nullptr || !u.left_child().red())
            rotate_left(p, u);
          else {
            p.red(false);
            rotate_right_left(p, u, u.left_child());
          }
          return;
        }
        else {
          if (u.red()) {
            p.red(true);
            u.red(false);
            rotate_left(p, u);
            u = p.right_child();
            goto P_IS_RED_2;
          }
          else {
            if (u.right_child() == nullptr || !u.right_child().red()) {
              if (u.left_child() == nullptr || !u.left_child().red()) {
                u.red(true);
                c = p;
                p = p.parent();
              }
              else {
                u.left_child().red(false);
                rotate_right_left(p, u, u.left_child());
                return;
              }
            }
            else {
              u.right_child().red(false);
              rotate_left(p, u);
              return;
            }
          }
        }
      }
    }
  }

  // insert_right(new_it, it) requires: it.right_child() == nullptr
  // insert_left(new_it, it) requires: it.left_child() == nullptr
  void insert_right(iterator new_it, iterator it) noexcept {
    new_it.left_child(iterator{});
    new_it.right_child(iterator{});
    new_it.parent(it);
    it.right_child(new_it);

    new_it.state(true, 1);
    recursive_size_inc(it);

    ins_rebalance(new_it, it);
  }
  void insert_left(iterator new_it, iterator it) noexcept {
    new_it.left_child(iterator{});
    new_it.right_child(iterator{});
    new_it.parent(it);
    it.left_child(new_it);

    new_it.state(true, 1);
    recursive_size_inc(it);

    ins_rebalance(new_it, it);
  }

  // insert_to_null(it) requires: root() == nullptr
  // insert_right/left():
  //   call insert_right/left() and update rightmost or leftmost record
  iterator insert_to_null(iterator new_it) noexcept {
    leftmost(new_it);
    rightmost(new_it);
    root(new_it);
    new_it.left_child(iterator{});
    new_it.right_child(iterator{});
    new_it.parent(end());
    new_it.state(false, 1);
    return new_it;
  }
  iterator insert_to_left(iterator new_it, iterator it) noexcept {
    if (it == leftmost())
      leftmost(new_it);
    insert_left(new_it, it);
    return new_it;
  }
  iterator insert_to_right(iterator new_it, iterator it) noexcept {
    if (it == rightmost())
      rightmost(new_it);
    insert_right(new_it, it);
    return new_it;
  }

public:
  // container (continued)

  ranked_rbtree_adaptor()
    noexcept(!traits::store_node_allocator::value || noexcept(alloc_t{})) {
    new_data();
  }
  ~ranked_rbtree_adaptor() {}
  ranked_rbtree_adaptor(const ranked_rbtree_adaptor &) = delete;
  ranked_rbtree_adaptor &operator =(const ranked_rbtree_adaptor &) = delete;
  ranked_rbtree_adaptor(ranked_rbtree_adaptor &&x) noexcept
    : alloc_t(move(x.alloc_ref())) {
    new_data(move(x));
  }
  ranked_rbtree_adaptor &operator =(ranked_rbtree_adaptor &&x) noexcept {
    if (this != addressof(x))
      new_data(move(x));
    return *this;
  }
  friend void swap(ranked_rbtree_adaptor &x,
                   ranked_rbtree_adaptor &y) noexcept {
    x.swap_data(y);
  }

  ~ranked_rbtree_adaptor()
    requires traits::store_node_allocator::value {
    delete_data();
  }
  ranked_rbtree_adaptor(const ranked_rbtree_adaptor &x)
    requires traits::store_node_allocator::value
    : alloc_t(allocator_traits<alloc_t>
              ::select_on_container_copy_construction(x.alloc_ref())) {
    new_data(x);
  }
  ranked_rbtree_adaptor &operator =(const ranked_rbtree_adaptor &x)
    requires traits::store_node_allocator::value {
    allocator_aware_container_ownership<this_t>::copy_assign(*this, x);
    return *this;
  }
  ranked_rbtree_adaptor &operator =(ranked_rbtree_adaptor &&x)
    noexcept(alloc_move_prpg<alloc_t> || alloc_always_equal<alloc_t>)
    requires traits::store_node_allocator::value {
    allocator_aware_container_ownership<this_t>::move_assign(*this, x);
    return *this;
  }
  friend void swap(ranked_rbtree_adaptor &x, ranked_rbtree_adaptor &y)
    noexcept(alloc_swap_prpg<alloc_t> || alloc_always_equal<alloc_t>)
    requires traits::store_node_allocator::value {
    allocator_aware_container_ownership<this_t>::swap(x, y);
  }

  // optional container operations

  // reversible container

  using reverse_iterator = re::reverse_iterator<iterator>;
  using const_reverse_iterator = re::reverse_iterator<const_iterator>;

  reverse_iterator rbegin() noexcept {
    return reverse_iterator(end());
  }
  reverse_iterator rend() noexcept {
    return reverse_iterator(begin());
  }
  const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator(begin());
  }
  const_reverse_iterator crbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  const_reverse_iterator crend() const noexcept {
    return const_reverse_iterator(begin());
  }

  // allocator-aware container

  using allocator_type = typename TRAITS::allocator_type;
  alloc_t get_allocator() const noexcept {
    return alloc_ref();
  }

  explicit ranked_rbtree_adaptor(const alloc_t &al) noexcept : alloc_t(al) {
    new_data();
  }
  ranked_rbtree_adaptor(const this_t &x, const alloc_t &al) : alloc_t(al) {
    new_data(x);
  }
  ranked_rbtree_adaptor(this_t &&x, const alloc_t &al) : alloc_t(al) {
    allocator_aware_container_ownership<this_t>::move_construct(*this, x);
  }

  // bst specilized operations

  template <class UPRED>
  iterator partition_point(UPRED eq) const {
    iterator ret = end().to_mutable();
    iterator it = root();
    for (;;) {
      if (it == nullptr)
        return ret;
      if (eq(*it))
        it = it.right_child();
      else {
        ret = it;
        it = it.left_child();
      }
    }
  }
  template <class GET_KEY, class KEY_LESS, class KEY>
  iterator find(GET_KEY get_key, KEY_LESS key_less, const KEY &key) const {
    const auto it = lower_bound(get_key, key_less, key);
    if (it != end() && !key_less(key, get_key(*it)))
      return it;
    return end().to_mutable();
  }
  template <class GET_KEY, class KEY_LESS, class KEY>
  iterator lower_bound(GET_KEY get_key, KEY_LESS key_less,
                       const KEY &key) const {
    return partition_point(bind(key_less, bind(get_key, _1), ref(key)));
  }
  template <class GET_KEY, class KEY_LESS, class KEY>
  iterator upper_bound(GET_KEY get_key, KEY_LESS key_less,
                       const KEY &key) const {
    return partition_point(bind(not_fn(key_less), ref(key), bind(get_key, _1)));
  }
  template <class GET_KEY, class KEY_LESS, class KEY>
  iter_pair<iterator> equal_range(GET_KEY get_key, KEY_LESS key_less,
                                  const KEY &key) const {
    return {
      lower_bound(get_key, key_less, key),
      upper_bound(get_key, key_less, key)
    };
  }
  template <class GET_KEY, class KEY_LESS, class KEY>
  size_type count(GET_KEY get_key, KEY_LESS key_less,
                  const KEY &key) const {
    return size(equal_range(get_key, key_less, key));
  }
  template <class GET_KEY, class KEY_LESS, class KEY, class KEY2>
  iter_pair<iterator> find_range(GET_KEY get_key, KEY_LESS key_less,
                                 const KEY &key, const KEY2 &key2) const {
    return {
      lower_bound(get_key, key_less, key),
      upper_bound(get_key, key_less, key2)
    };
  }

private:
  iterator unlink_impl(iterator it) noexcept {
    const iterator ret = next(it);
    if (it == leftmost()) {
      leftmost(ret);
      if (it == rightmost())
        rightmost(end());
    }
    else if (it == rightmost())
      rightmost(prev(it));

    const iterator parent = it.parent();
    if (it.left_child() == nullptr) {
      if (it.right_child() == nullptr) {
        if (it == parent.right_child()) {
          parent.right_child(iterator{});
          recursive_size_dec(parent);
          if (!it.red())
            del_rebalance(parent, parent.right_child());
        }
        else {
          parent.left_child(iterator{});
          recursive_size_dec(parent);
          if (!it.red())
            del_rebalance(parent, parent.left_child());
        }
      }
      else {
        const iterator rchild = it.right_child();
        rchild.parent(parent);
        recursive_size_dec(parent);
        if (it == parent.right_child())
          parent.right_child(rchild);
        else
          parent.left_child(rchild);
        rchild.red(false);
      }
    }
    else {
      if (it.right_child() == nullptr) {
        const iterator lchild = it.left_child();
        lchild.parent(parent);
        recursive_size_dec(parent);
        if (it == parent.right_child())
          parent.right_child(lchild);
        else
          parent.left_child(lchild);
        lchild.red(false);
      }
      else {
        const iterator next = ret;
        if (next.parent() == it) {
          if (it == parent.right_child())
            parent.right_child(next);
          else
            parent.left_child(next);
          next.parent(it.parent());

          next.left_child(it.left_child());
          next.left_child().parent(next);

          if (!next.red()) {
            next.state(it.state());
            recursive_size_dec(next);
            if (next.right_child() != nullptr)
              next.right_child().red(false);
            else
              del_rebalance(next, next.right_child());
          }
          else {
            next.state(it.state());
            recursive_size_dec(next);
          }
        }
        else {
          const iterator p = next.parent();

          p.left_child(next.right_child());
          if (next.right_child() != nullptr)
            next.right_child().parent(p);

          if (it == parent.right_child())
            parent.right_child(next);
          else
            parent.left_child(next);
          next.parent(it.parent());

          next.left_child(it.left_child());
          next.left_child().parent(next);

          next.right_child(it.right_child());
          next.right_child().parent(next);

          if (!next.red()) {
            next.state(it.state());
            recursive_size_dec(p);
            if (p.left_child() != nullptr)
              p.left_child().red(false);
            else
              del_rebalance(p, p.left_child());
          }
          else {
            next.state(it.state());
            recursive_size_dec(p);
          }
        }
      }
    }

    return ret;
  }
public:
  iterator unlink(const_iterator it) noexcept {
    return unlink_impl(it.to_mutable());
  }
  iterator unlink(const_iterator from, const_iterator to) noexcept {
    while (from != to)
      from = unlink(from);
    return to.to_mutable();
  }
  void unlink() noexcept {
    new_data();
  }
  template <class GET_KEY, class KEY_LESS, class KEY>
  size_type unlink(GET_KEY get_key, KEY_LESS key_less, const KEY &key) {
    auto it = lower_bound(get_key, key_less, key);
    size_type c = 0;
    while (it != end() && !key_less(key, get_key(*it))) {
      it = unlink(it);
      ++c;
    }
    return c;
  }
  iterator erase(const_iterator it) {
    const auto ret = unlink(it);
    delete_node(it);
    return ret;
  }
  iterator erase(const_iterator from, const_iterator to) {
    while (from != to)
      from = erase(from);      
    return to.to_mutable();
  }
  template <class GET_KEY, class KEY_LESS, class KEY>
  size_type erase(GET_KEY get_key, KEY_LESS key_less, const KEY &key) {
    auto it = lower_bound(get_key, key_less, key);
    size_type c = 0;
    while (it != end() && !key_less(key, get_key(*it))) {
      it = erase(it);
      ++c;
    }
    return c;
  }
  template <class NODE_HANDLE>
  NODE_HANDLE extract(const_iterator it) {
    NODE_HANDLE ret(it.node(), alloc_ref());
    unlink(it);
    return ret;
  }
  template <class NODE_HANDLE, class GET_KEY, class KEY_LESS, class KEY>
  NODE_HANDLE extract(GET_KEY getkey, KEY_LESS keyless, const KEY &key) {
    const iterator it = lower_bound(getkey, keyless, key);
    return (it != end() && !keyless(key, getkey(*it)))
      ? extract<NODE_HANDLE>(it) : NODE_HANDLE{};
  }
  void clear() noexcept {
    delete_data();
    new_data();
  }

private:
  iterator link_impl(iterator pos, iterator node) {
    if (root() == nullptr)
      return insert_to_null(node);
    if (pos == end()) {
      insert_right(node, rightmost());
      rightmost(node);
    }
    else if (pos == begin()) {
      insert_left(node, leftmost());
      leftmost(node);
    }
    else {
      if (pos.left_child() == nullptr)
        insert_left(node, pos);
      else
        insert_right(node, prev(pos));
    }
    return node;
  }
public:
  iterator link(const_iterator pos, const_iterator node) {
    return link_impl(pos.to_mutable(), node.to_mutable());
  }
  template <class...S>
  iterator emplace(const_iterator i, S &&...s) {
    return link(i, new_node(forward<S>(s)...));
  }
  iterator insert(const_iterator i, const value_type &x) {
    return link(i, new_node(x));
  }
  iterator insert(const_iterator i, value_type &&x) {
    return link(i, new_node(move(x)));
  }
  template <class IITR_RANGE>
  enable_if_t<!is_convertible_v<IITR_RANGE &&, value_type &&>
              && !is_convertible_v<IITR_RANGE &&, const value_type &>
              && !is_convertible_v<IITR_RANGE &&, inner::node_handle<TRAITS>>
              && !is_convertible_v<IITR_RANGE &&, this_t &&>,
              iterator>
  insert(const_iterator pos, IITR_RANGE &&r) {
    return insert_range(pos, r);
  }
  template <class IITR_RANGE>
  iterator insert_range(const_iterator pos, IITR_RANGE &&r) {
    if (empty(r))
      return pos.to_mutable();
    auto it = begin(r);
    const iterator ret = emplace(pos, *it);
    for (auto &i : iters(++it, end(r)))
      emplace(pos, *i);
    return ret;
  }
  template <class IITR_RANGE>
  void assign_range(IITR_RANGE &&r) {
    auto rr = rng(r);
    iterator it = begin();
    for (;;) {
      if (empty(rr)) {
        erase(it, end());
        return;
      }
      if (it == end()) {
        insert_range(end(), rr);
        return;
      }
      *it = *rr.first;
      ++it;
      ++rr.first;
    }
  }

  template <class GET_KEY, class KEY_LESS, class KEY,
            class GET_NEW_NODE, class DO_WHEN_EQUAL>
  pair<iterator, bool>
  insert(GET_KEY get_key, KEY_LESS key_less, const KEY &key,
         GET_NEW_NODE get_new_node, DO_WHEN_EQUAL do_when_equal) {
    if (root() == nullptr)
      return {insert_to_null(get_new_node()), true};
    const iterator it = lower_bound(get_key, key_less, key);
    if (it == end()) {
      const iterator new_it = get_new_node();
      insert_right(new_it, rightmost());
      rightmost(new_it);
      return {new_it, true};
    }
    else if (key_less(key, get_key(*it))) {
      if (it.left_child() == nullptr)
        return {insert_to_left(get_new_node(), it), true};
      else {
        const iterator new_it = get_new_node();
        insert_right(new_it, prev(it));
        return {new_it, true};
      }
    }
    else {
      do_when_equal(it);
      return {it, false};
    }
  }
  template <class GET_KEY, class KEY_LESS, class KEY, class GET_NEW_NODE>
  iterator insert_equal(GET_KEY get_key, KEY_LESS key_less, const KEY &key,
                        GET_NEW_NODE get_new_node) {
    if (root() == nullptr)
      return insert_to_null(get_new_node());
    iterator it = root();
    for (;;) {
      if (key_less(key, get_key(*it))) {
        if (it.left_child() == nullptr)
          return insert_to_left(get_new_node(), it);
        else
          it = it.left_child();
      }
      else {
        if (it.right_child() == nullptr)
          return insert_to_right(get_new_node(), it);
        else
          it = it.right_child();
      }
    }
  }

  template <class GET_KEY, class KEY_LESS, class KEY,
            class GET_NEW_NODE, class DO_WHEN_EQUAL>
  iterator insert(GET_KEY get_key, KEY_LESS key_less,
                  iterator hint, const KEY &key,
                  GET_NEW_NODE get_new_node, DO_WHEN_EQUAL do_when_equal) {
    if (root() == nullptr)
      return insert_to_null(get_new_node());
    else if (hint == end()) {
      if (key_less(get_key(*rightmost()), key)) {
        const iterator new_it = get_new_node();
        insert_right(new_it, rightmost());
        rightmost(new_it);
        return new_it;
      }
    }
    else if (hint == begin()) {
      if (key_less(key, get_key(*hint))) {
        const iterator new_it = get_new_node();
        insert_left(new_it, leftmost());
        leftmost(new_it);
        return new_it;
      }
    }
    else {
      const iterator it = prev(hint);
      if (key_less(get_key(*it), key) && key_less(key, get_key(*hint))) {
        const iterator new_it = get_new_node();
        if (hint.left_child() == nullptr)
          insert_left(new_it, hint);
        else
          insert_right(new_it, it);
        return new_it;
      }
    }
    return insert(get_key, key_less, key, get_new_node, do_when_equal).first;
  }
  template <class GET_KEY, class KEY_LESS, class KEY, class GET_NEW_NODE>
  iterator insert_equal(GET_KEY get_key, KEY_LESS key_less,
                        iterator hint, const KEY &key,
                        GET_NEW_NODE get_new_node) {
    if (root() == nullptr)
      return insert_to_null(get_new_node());
    else if (hint == end()) {
      if (!key_less(key, get_key(*rightmost()))) {
        const iterator new_it = get_new_node();
        insert_right(new_it, rightmost());
        rightmost(new_it);
        return new_it;
      }
    }
    else if (hint == begin()) {
      if (!key_less(get_key(*hint), key)) {
        const iterator new_it = get_new_node();
        insert_left(new_it, leftmost());
        leftmost(new_it);
        return new_it;
      }
    }
    else {
      const iterator it = prev(hint);
      if (!key_less(key, get_key(*it)) && !key_less(get_key(*hint), key)) {
        const iterator new_it = get_new_node();
        if (hint.left_child() == nullptr)
          insert_left(new_it, hint);
        else
          insert_right(new_it, it);
        return new_it;
      }
    }
    return insert_equal(get_key, key_less, key, get_new_node);
  }

  template <class GET_KEY, class KEY_LESS>
  pair<iterator, bool> link(GET_KEY get_key, KEY_LESS key_less,
                            iterator it) {
    return insert(get_key, key_less, get_key(*it), bind(copy, it),
                  empty_function{});
  }
  template <class GET_KEY, class KEY_LESS, class...S>
  enable_if_t<!is_convertible_v<GET_KEY &&, const_iterator>,
              pair<iterator, bool>>
  emplace(GET_KEY &&get_key, KEY_LESS key_less, S &&...s) {
    const auto it = new_node(forward<S>(s)...);
#ifndef RE_NOEXCEPT
    try {
#endif
      return insert(get_key, key_less, get_key(*it), bind(copy, it),
                    [=, this](auto) {delete_node(it);});
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      delete_node(it);
      throw;
    }
#endif
  }
  template <class GET_KEY, class KEY_LESS>
  enable_if_t<!is_convertible_v<GET_KEY &&, const_iterator>,
              pair<iterator, bool>>
  insert(GET_KEY &&get_key, KEY_LESS key_less, const value_type &x) {
    return insert(get_key, key_less, get_key(x),
                  [&]() {return new_node(x);}, empty_function{});
  }
  template <class GET_KEY, class KEY_LESS>
  enable_if_t<!is_convertible_v<GET_KEY &&, const_iterator>,
              pair<iterator, bool>>
  insert(GET_KEY &&get_key, KEY_LESS key_less, value_type &&x) {
    return insert(get_key, key_less, get_key(x),
                  [&]() {return new_node(move(x));}, empty_function{});
  }
  template <class GET_KEY, class KEY_LESS>
  iterator link(GET_KEY get_key, KEY_LESS key_less,
                iterator hint, iterator it) {
    return insert(get_key, key_less, hint, get_key(*it),
                  bind(copy, it), empty_function{});
  }
  template <class GET_KEY, class KEY_LESS, class...S>
  iterator emplace_hint(GET_KEY get_key, KEY_LESS key_less,
                        iterator hint, S &&...s) {
    const auto it = new_node(forward<S>(s)...);
#ifndef RE_NOEXCEPT
    try {
#endif
      return insert(get_key, key_less, hint, get_key(*it), bind(copy, it),
                    [=, this](auto) {delete_node(it);});
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      delete_node(it);
      throw;
    }
#endif
  }
  template <class GET_KEY, class KEY_LESS>
  iterator insert(GET_KEY get_key, KEY_LESS key_less,
                  iterator hint, const value_type &x) {
    return insert(get_key, key_less, hint, get_key(x),
                  [&]() {return new_node(x);}, empty_function{});
  }
  template <class GET_KEY, class KEY_LESS>
  iterator insert(GET_KEY get_key, KEY_LESS key_less,
                  iterator hint, value_type &&x) {
    return insert(get_key, key_less, hint, get_key(x),
                  [&]() {return new_node(move(x));}, empty_function{});
  }

  template <class GET_KEY, class KEY_LESS, class KEY, class...S>
  pair<iterator, bool>
  try_emplace(GET_KEY get_key, KEY_LESS key_less, KEY &&key, S &&...s) {
    return insert(get_key, key_less, key,
                  [&]() {return new_node(piecewise_construct,
                                         forward_as_tuple(forward<KEY>(key)),
                                         forward_as_tuple(forward<S>(s)...));},
                  empty_function{});
  }
  template <class GET_KEY, class KEY_LESS, class KEY, class...S>
  iterator try_emplace_hint(GET_KEY get_key, KEY_LESS key_less,
                            iterator hint, KEY &&key, S &&...s) {
    return insert(get_key, key_less, hint, key,
                  [&]() {return new_node(piecewise_construct,
                                         forward_as_tuple(forward<KEY>(key)),
                                         forward_as_tuple(forward<S>(s)...));},
                  empty_function{});
  }
  template <class GET_KEY, class GET_MAPPED, class KEY_LESS, class KEY, class X>
  pair<iterator, bool>
  insert_or_assign(GET_KEY get_key, GET_MAPPED get_mapped, KEY_LESS key_less,
                   KEY &&key, X &&x) {
    return insert(get_key, key_less, key,
                  [&]() {return new_node(forward<KEY>(key), forward<X>(x));},
                  [&](iterator pos) {get_mapped(*pos) = forward<X>(x);});
  }
  template <class GET_KEY, class GET_MAPPED, class KEY_LESS, class KEY, class X>
  iterator insert_or_assign(GET_KEY get_key, GET_MAPPED get_mapped,
                            KEY_LESS key_less,
                            iterator hint, KEY &&key, X &&x) {
    return insert(get_key, key_less, hint, key,
                  [&]() {return new_node(forward<KEY>(key), forward<X>(x));},
                  [&](iterator pos) {get_mapped(*pos) = forward<X>(x);});
  }
  template <class ITERATOR, class GET_KEY, class KEY_LESS, class NODE_HANDLE>
  inner::node_handle_insert_return_type
  <ITERATOR, remove_reference_t<NODE_HANDLE>>
  insert_node_handle(GET_KEY get_key, KEY_LESS key_less, NODE_HANDLE &&nh) {
    inner::node_handle_insert_return_type
      <ITERATOR, remove_reference_t<NODE_HANDLE>> ret;
    if (nh.empty()) {
      ret.position = end();
      ret.inserted = false;
    }
    else {
      tie(ret.position, ret.inserted)
        = insert(get_key, key_less, get_key(*ITERATOR(nh.get())),
                 [&]() {return iterator(nh.release());}, empty_function{});
      ret.node = move(nh);
    }
    return ret;
  }
  template <class GET_KEY, class KEY_LESS, class NODE_HANDLE>
  iterator insert_node_handle(GET_KEY get_key, KEY_LESS key_less,
                              iterator hint, NODE_HANDLE &&nh) {
    return nh.empty()
      ? end()
      : insert(get_key, key_less, hint,
               get_key(*iterator(nh.get())),
               [&]() {return iterator(nh.release());},
               empty_function{});
  }

  template <class GET_KEY, class KEY_LESS>
  iterator link_equal(GET_KEY get_key, KEY_LESS key_less,
                      iterator it) noexcept {
    return insert_equal(get_key, key_less, get_key(*it), bind(copy, it));
  }
  template <class GET_KEY, class KEY_LESS>
  iterator link_equal(GET_KEY get_key, KEY_LESS key_less,
                      iterator hint, iterator it) noexcept {
    return insert_equal(get_key, key_less, hint, get_key(*it), bind(copy, it));
  }
  template <class GET_KEY, class KEY_LESS, class...S>
  iterator emplace_equal(GET_KEY get_key, KEY_LESS key_less, S &&...s) {
    const auto it = new_node(forward<S>(s)...);
#ifndef RE_NOEXCEPT
    try {
#endif
    return insert_equal(get_key, key_less, get_key(*it), bind(copy, it));
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      delete_node(it);
      throw;
    }
#endif
  }
  template <class GET_KEY, class KEY_LESS, class...S>
  iterator emplace_equal_hint(GET_KEY get_key, KEY_LESS key_less,
                              iterator hint, S &&...s) {
    const auto it = new_node(forward<S>(s)...);
#ifndef RE_NOEXCEPT
    try {
#endif
      return insert_equal(get_key, key_less,
                          hint, get_key(*it), bind(copy, it));
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      delete_node(it);
      throw;
    }
#endif
  }
  template <class GET_KEY, class KEY_LESS, class NODE_HANDLE>
  iterator insert_node_handle_equal(GET_KEY get_key, KEY_LESS key_less,
                                    NODE_HANDLE &&nh) {
    return nh.empty()
      ? end()
      : insert_equal(get_key, key_less, get_key(*iterator(nh.get())),
                     [&]() {return iterator(nh.release());});
  }
  template <class GET_KEY, class KEY_LESS, class NODE_HANDLE>
  iterator insert_node_handle_equal(GET_KEY get_key, KEY_LESS key_less,
                                    iterator hint, NODE_HANDLE &&nh) {
    return nh.empty()
      ? end()
      : insert_equal(get_key, key_less, hint, get_key(*iterator(nh.get())),
                     [&]() {return iterator(nh.release());});
  }

  template <class GET_KEY, class KEY_LESS, class ANALOGOUS>
  void merge(GET_KEY get_key, KEY_LESS key_less, ANALOGOUS &&other) {
    if (this != addressof(other))
      for (iterator it = other.begin(), ed = other.end(); it != ed;)
        insert(get_key, key_less, get_key(*it),
               [&]() {return re::exchange(it, other.unlink(it));},
               [&](...) {++it;});
  }

  template <class GET_KEY, class KEY_LESS, class ANALOGOUS>
  void merge_equal(GET_KEY get_key, KEY_LESS key_less, ANALOGOUS &&other) {
    if (this != addressof(other))
      for (iterator it = other.begin(), ed = other.end(); it != ed;)
        insert_equal(get_key, key_less, get_key(*it),
                     [&]() {return re::exchange(it, other.unlink(it));});
  }

  template <class GET_KEY, class KEY_LESS, class R>
  void insert_range(GET_KEY get_key, KEY_LESS key_less, R &&r) {
    for (auto &it : iters(r))
      emplace(get_key, key_less, *it);
  }
  template <class GET_KEY, class KEY_LESS, class R,
            class INSERT_RANGE>
  void assign_range(GET_KEY get_key, KEY_LESS key_less, R &&r,
                    INSERT_RANGE insert_range_fn) {
    const iterator root_node = root();
    end().right_child(iterator{});
    inner::bst_helper::link_bst_to_forward_list(end(), root_node);
    iterator hook = end().right_child();
    const auto guard = exit_fn([&]() {
      for_each_node(rng(hook, iterator{}),
                    [](auto it) {return it.right_child();},
                    [&](auto it) {delete_node(it);});
    });
    new_data();
    for (auto &it : iters(r)) {
      if (hook != nullptr) {
        *hook = *it;
        insert(get_key, key_less, get_key(*hook),
               [&]() {return re::exchange(hook, hook.right_child());},
               empty_function{});
      }
      else {
        insert_range_fn(rng(it, end(r)));
        return;
      }
    }
  }
  template <class GET_KEY, class KEY_LESS, class R>
  void assign_range(GET_KEY get_key, KEY_LESS key_less, R &&r) {
    assign_range(get_key, key_less, r,
                 [=, this](auto &&r) {insert_range(get_key, key_less, r);});
  }

  template <class GET_KEY, class KEY_LESS, class R>
  void insert_range_equal(GET_KEY get_key, KEY_LESS key_less, R &&r) {
    for (auto &it : iters(r))
      emplace_equal(get_key, key_less, *it);
  }
  template <class GET_KEY, class KEY_LESS, class R>
  void assign_range_equal(GET_KEY get_key, KEY_LESS key_less, R &&r) {
    const iterator root_node = root();
    end().right_child(iterator{});
    inner::bst_helper::link_bst_to_forward_list(end(), root_node);
    iterator hook = end().right_child();
    const auto guard = exit_fn([&]() {
      for_each_node(rng(hook, iterator{}),
                    [](auto it) {return it.right_child();},
                    [&](auto it) {delete_node(it);});
    });
    new_data();
    for (auto &it : iters(r)) {
      if (hook != nullptr) {
        *hook = *it;
        insert_equal(get_key, key_less, get_key(*hook),
                     [&]() {return re::exchange(hook, hook.right_child());});
      }
      else {
        insert_range_equal(get_key, key_less, rng(it, end(r)));
        return;
      }
    }
  }

private:
  iterator nth_impl(size_type n) const {
    if (n == size())
      return end().to_mutable();
    iterator it = root();
    for (;;) {
      const size_type l_n = it.left_child().get_size();
      const difference_type dif = to_signed(n) - to_signed(l_n);
      if (dif == 0)
        return it;
      else if (dif < 0)
        it = it.left_child();
      else {
        n -= l_n + 1u;
        it = it.right_child();
      }
    }
  }
  size_type nth_impl(iterator it) const {
    if (it == end())
      return size();
    size_type n = it.left_child().get_size();
    for (;;) {
      const iterator p = it.parent();
      if (p == end())
        return n;
      else {
        if (it == p.right_child())
          n += p.left_child().get_size() + 1u;
        it = p;
      }
    }
  }
public:
  const_iterator nth(difference_type n) const {
    return nth_impl(to_unsigned(n));
  }
  iterator nth(difference_type n) {
    return nth_impl(to_unsigned(n));
  }
  difference_type nth(const_iterator it) const {
    return to_signed(nth_impl(it.to_mutable()));
  }

private:
  bool good_recurse(iterator it, size_type current_black_count,
                    const size_type &black_count) const {
    if (it == nullptr) {
      if (current_black_count != black_count)
        return false;
      return true;
    }

    if (it.red()) {
      if (it.left_child() != nullptr && it.left_child().red())
        return false;
      if (it.right_child() != nullptr && it.right_child().red())
        return false;
    }
    else
      ++current_black_count;

    if (it.size()
        != it.left_child().get_size() + it.right_child().get_size() + 1u)
      return false;

    return good_recurse(it.left_child(), current_black_count, black_count)
      && good_recurse(it.right_child(), current_black_count, black_count);
  }
  friend struct inner::fo_good;
  bool good() const noexcept {
    if (begin() == end())
      return true;
    if (root().red())
      return false;
    size_type n = 0;
    for (auto it = root(); it != nullptr; it = it.left_child())
      n += !it.red();
    return good_recurse(root(), 0, n);
  }

public:
  value_type &front() {
    return *leftmost();
  }
  const value_type &front() const {
    return *leftmost();
  }
  iterator unlink_front() {
    unlink_impl(leftmost());
    return begin();
  }
  void pop_front() {
    erase(leftmost());
  }
  void pop_front(size_type n) {
    for (; n != 0; --n)
      erase(leftmost());
  }
  iterator link_front(const_iterator node) noexcept {
    const iterator x = node.to_mutable();
    if (root() == nullptr)
      insert_to_null(x);
    else {
      insert_left(x, leftmost());
      leftmost(x);
    }
    return x;
  }
  template <class...S>
  reference emplace_front(S &&...s) {
    return *link_front(new_node(forward<S>(s)...));
  }
  void push_front(const value_type &x) {
    emplace_front(x);
  }
  void push_front(value_type &&x) {
    emplace_front(move(x));
  }

  value_type &back() {
    return *rightmost();
  }
  const value_type &back() const {
    return *rightmost();
  }
  iterator unlink_back() {
    unlink_impl(rightmost());
    return end();
  }
  void pop_back() {
    erase(rightmost());
  }
  void pop_back(size_type n) {
    for (; n != 0; --n)
      erase(rightmost());
  }
  iterator link_back(const_iterator node) noexcept {
    const iterator x = node.to_mutable();
    if (root() == nullptr)
      insert_to_null(x);
    else {
      insert_right(x, rightmost());
      rightmost(x);
    }
    return x;
  }
  template <class...S>
  reference emplace_back(S &&...s) {
    return *link_back(new_node(forward<S>(s)...));
  }
  void push_back(const value_type &x) {
    emplace_back(x);
  }
  void push_back(value_type &&x) {
    emplace_back(move(x));
  }

  reference operator [](size_type n) {
    return *nth(n);
  }
  const_reference operator [](size_type n) const {
    return *nth(n);
  }

  reference at(size_type nn) {
    if (nn >= size())
      throw_or_terminate<out_of_range>
        ("re::ranked_rbtree_adaptor: at(n) failed\n");
    return begin()[nn];
  }
  const_reference at(size_type nn) const {
    if (nn >= size())
      throw_or_terminate<out_of_range>
        ("re::ranked_rbtree_adaptor: at(n) failed\n");
    return begin()[nn];
  }

  explicit ranked_rbtree_adaptor(size_type n, const alloc_t &al = alloc_t{})
    : ranked_rbtree_adaptor(al) {
    for (; n != 0; --n)
      emplace_back();
  }
  ranked_rbtree_adaptor(size_type n, const value_type &x,
                        const alloc_t &al = alloc_t{})
    : ranked_rbtree_adaptor(al) {
    for (; n != 0; --n)
      emplace_back(x);
  }
  void assign(size_type n, const value_type &x) {
    assign_range(rng(n, x));
  }
  iterator insert(const_iterator pos, size_type n, const value_type &x) {
    return insert_range(pos, rng(n, ref(x)));
  }

  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  ranked_rbtree_adaptor(IITR from, IITR to, const alloc_t &al = alloc_t{})
    : ranked_rbtree_adaptor(al) {
    insert_range(end(), rng(from, to));
  }
  template <class IITR>
  enable_if_t<is_itr<IITR>> assign(IITR from, IITR to) {
    assign_range(rng(from, to));
  }
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  iterator insert(const_iterator pos, IITR from, IITR to) {
    return insert_range(pos, rng(from, to));
  }

  ranked_rbtree_adaptor(initializer_list<value_type> l,
                        const alloc_t &al = alloc_t{})
    : ranked_rbtree_adaptor(al) {
    insert_range(end(), l);
  }
  this_t &operator =(initializer_list<value_type> l) {
    assign_range(l);
    return *this;
  }
  void assign(initializer_list<value_type> l) {
    assign_range(l);
  }
  iterator insert(const_iterator pos, initializer_list<value_type> l) {
    return insert_range(pos, l);
  }

  template <class IITR_RANGE, class = enable_if_t
            <is_rng<IITR_RANGE>
             && is_constructible_v<value_type, rng_ref<IITR_RANGE>>>>
  ranked_rbtree_adaptor(from_range_t, IITR_RANGE &&r,
                        const alloc_t &al = alloc_t{})
    : ranked_rbtree_adaptor(al) {
    insert_range(end(), r);
  }
  template <class IITR_RANGE, class = enable_if_t
            <!is_same_v<decay_t<IITR_RANGE>, this_t>
             && !is_convertible_v<IITR_RANGE &&, const alloc_t &>
             && is_rng<IITR_RANGE>
             && is_constructible_v<value_type, rng_ref<IITR_RANGE>>>>
  explicit ranked_rbtree_adaptor(IITR_RANGE &&r)
    : ranked_rbtree_adaptor(alloc_t{}) {
    insert_range(end(), r);
  }
  template <class IITR_RANGE, class = enable_if_t
            <!is_same_v<decay_t<IITR_RANGE>, this_t>
             && is_rng<IITR_RANGE>
             && is_constructible_v<value_type, rng_ref<IITR_RANGE>>>>
  ranked_rbtree_adaptor(IITR_RANGE &&r, const alloc_t &al)
    : ranked_rbtree_adaptor(al) {
    insert_range(end(), r);
  }
  template <class IITR_RANGE>
  enable_if_t<!is_same_v<decay_t<IITR_RANGE>, this_t>
              && is_rng<IITR_RANGE>
              && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
              && is_assignable_v<value_type &, rng_ref<IITR_RANGE>>, this_t &>
  operator =(IITR_RANGE &&r) {
    assign_range(r);
    return *this;
  }
  template <class IITR_RANGE>
  void assign(IITR_RANGE &&r) {
    assign_range(r);
  }

  template <class IITR_RANGE>
  void append_range(IITR_RANGE &&r) {
    insert_range(end(), r);
  }
  template <class IITR_RANGE>
  enable_if_t<!is_convertible_v<IITR_RANGE &&, value_type &&>
              && !is_convertible_v<IITR_RANGE &&, const value_type &>
              && !is_convertible_v<IITR_RANGE &&, inner::node_handle<TRAITS> &&>
              && !is_convertible_v<IITR_RANGE &&, this_t &&>>
  push_back(IITR_RANGE &&r) {
    append_range(r);
  }
  this_t &append() {
    return *this;
  }
  template <class X, class...S>
  this_t &append(X &&x, S &&...s) {
    push_back(forward<X>(x));
    return append(forward<S>(s)...);
  }

  template <class IITR_RANGE>
  void prepend_range(IITR_RANGE &&r) {
    insert_range(begin(), r);
  }
  template <class IITR_RANGE>
  enable_if_t<!is_convertible_v<IITR_RANGE &&, value_type &&>
              && !is_convertible_v<IITR_RANGE &&, const value_type &>
              && !is_convertible_v<IITR_RANGE &&, inner::node_handle<TRAITS> &&>
              && !is_convertible_v<IITR_RANGE &&, this_t &&>>
  push_front(IITR_RANGE &&r) {
    prepend_range(r);
  }
  this_t &prepend() {
    return *this;
  }
  template <class X, class...S>
  this_t &prepend(X &&x, S &&...s) {
    prepend(forward<S>(s)...);
    push_front(forward<X>(x));
    return *this;
  }

  void resize(size_type n) {
    if (size() > n)
      while (size() != n)
        pop_back();
    else
      while (size() != n)
        emplace_back();
  }
  void resize(size_type n, const value_type &x) {
    if (size() > n)
      while (size() != n)
        pop_back();
    else
      while (size() != n)
        emplace_back(x);
  }

  void splice(const_iterator next, this_t &l) noexcept {
    while (!l.empty()) {
      auto it = l.begin();
      l.unlink(it);
      link(next, it);
    }
  }
  void splice(const_iterator next, this_t &&l) noexcept {
    splice(next, l);
  }
  void splice(const_iterator next,
              this_t &l, const_iterator i) noexcept {
    if (next != i) {
      l.unlink(i);
      link(next, i);
    }
  }
  void splice(const_iterator next, this_t &&l, const_iterator i) noexcept {
    splice(next, l, i);
  }
  void splice(const_iterator next, this_t &l,
              const_iterator from, const_iterator to) noexcept {
    if (next == to)
      return;
    for_each_node(rng(from, to), re::next, [&](auto it) {
      l.unlink(it);
      link(next, it);
    });
  }
  void splice(const_iterator next, this_t &&l,
              const_iterator from, const_iterator to) noexcept {
    splice(next, l, from, to);
  }

  void swap(const_iterator x, const_iterator y) noexcept {
    if (x == y)
      return;
    if (x == y.right_child()) {
    label1:
      const auto p = y.parent();
      const auto y_l = y.left_child();
      const auto x_r = x.right_child();
      const auto x_l = x.left_child();
      if (y == p.right_child())
        p.right_child(x);
      else
        p.left_child(x);
      x.parent(p);
      x.left_child(y_l);
      if (x.left_child() != nullptr)
        x.left_child().parent(x);
      x.right_child(y);
      y.parent(x);
      y.left_child(x_l);
      y.right_child(x_r);
      if (y.left_child() != nullptr)
        y.left_child().parent(y);
      if (y.right_child() != nullptr)
        y.right_child().parent(y);
      const auto tmp = x.state();
      x.state(y.state());
      y.state(tmp);
      if (x == rightmost())
        rightmost(y.to_mutable());
      if (y == leftmost())
        leftmost(x.to_mutable());
    }
    else if (y == x.right_child()) {
      adl_swap(x, y);
      goto label1;
    }
    else if (x == y.left_child()) {
    label2:
      const auto p = y.parent();
      const auto y_r = y.right_child();
      const auto x_r = x.right_child();
      const auto x_l = x.left_child();
      if (y == p.right_child())
        p.right_child(x);
      else
        p.left_child(x);
      x.parent(p);
      x.right_child(y_r);
      if (x.right_child() != nullptr)
        x.right_child().parent(x);
      x.left_child(y);
      y.parent(x);
      y.left_child(x_l);
      y.right_child(x_r);
      if (y.left_child() != nullptr)
        y.left_child().parent(y);
      if (y.right_child() != nullptr)
        y.right_child().parent(y);
      const auto tmp = x.state();
      x.state(y.state());
      y.state(tmp);
      if (x == leftmost())
        leftmost(y.to_mutable());
      if (y == rightmost())
        rightmost(x.to_mutable());
    }
    else if (y == x.left_child()) {
      adl_swap(x, y);
      goto label2;
    }
    else {
      const_iterator tmp = x.parent();
      x.parent(y.parent());
      y.parent(tmp);
      tmp = x.left_child();
      x.left_child(y.left_child());
      y.left_child(tmp);
      tmp = x.right_child();
      x.right_child(y.right_child());
      y.right_child(tmp);
      const auto tmp2 = x.state();
      x.state(y.state());
      y.state(tmp2);

      if (x.left_child() != nullptr)
        x.left_child().parent(x);
      if (x.right_child() != nullptr)
        x.right_child().parent(x);
      if (y.left_child() != nullptr)
        y.left_child().parent(y);
      if (y.right_child() != nullptr)
        y.right_child().parent(y);
    
      if (x.parent().right_child() == y) {
        if (y.parent().right_child() == x) {
          x.parent().right_child(x);
          y.parent().right_child(y);
        }
        else {
          x.parent().right_child(x);
          y.parent().left_child(y);
        }
      }
      else {
        if (y.parent().right_child() == x) {
          x.parent().left_child(x);
          y.parent().right_child(y);
        }
        else {
          x.parent().left_child(x);
          y.parent().left_child(y);
        }
      }

      if (leftmost() == x)
        leftmost(y.to_mutable());
      else if (leftmost() == y)
        leftmost(x.to_mutable());
      if (rightmost() == x)
        rightmost(y.to_mutable());
      else if (rightmost() == y)
        rightmost(x.to_mutable());
    }
  }
  void swap(const_iterator x, this_t &l, const_iterator y) noexcept {
    if (addressof(l) == this)
      swap(x, y);
    else {
      const_iterator tmp = x.parent();
      x.parent(y.parent());
      y.parent(tmp);
      tmp = x.left_child();
      x.left_child(y.left_child());
      y.left_child(tmp);
      tmp = x.right_child();
      x.right_child(y.right_child());
      y.right_child(tmp);
      const auto tmp2 = x.state();
      x.state(y.state());
      y.state(tmp2);

      if (x.left_child() != nullptr)
        x.left_child().parent(x);
      if (x.right_child() != nullptr)
        x.right_child().parent(x);
      if (y.left_child() != nullptr)
        y.left_child().parent(y);
      if (y.right_child() != nullptr)
        y.right_child().parent(y);
    
      if (x.parent().right_child() == y) {
        if (y.parent().right_child() == x) {
          x.parent().right_child(x);
          y.parent().right_child(y);
        }
        else {
          x.parent().right_child(x);
          y.parent().left_child(y);
        }
      }
      else {
        if (y.parent().right_child() == x) {
          x.parent().left_child(x);
          y.parent().right_child(y);
        }
        else {
          x.parent().left_child(x);
          y.parent().left_child(y);
        }
      }

      if (leftmost() == x)
        leftmost(y.to_mutable());
      if (rightmost() == x)
        rightmost(y.to_mutable());

      if (l.leftmost() == y)
        l.leftmost(x.to_mutable());
      if (l.rightmost() == y)
        l.rightmost(x.to_mutable());
    }
  }

  template <bool Y = TRAITS::store_node_allocator::value>
  enable_if_t<Y, iterator> erase_or_unlink(const_iterator it) noexcept {
    return erase(it);
  }
  template <bool Y = TRAITS::store_node_allocator::value>
  enable_if_t<!Y, iterator> erase_or_unlink(const_iterator it) noexcept {
    return unlink(it);
  }
  template <class UPRED>
  size_type remove_if(UPRED eq) {
    size_type ret = 0;
    for (iterator it = begin(); it != end();) {
      if (eq(*it)) {
        it = erase_or_unlink(it);
        ++ret;
      }
      else
        ++it;
    }
    return ret;
  }
  template <class X>
  size_type remove(const X &x) {
    return remove_if([&x](const value_type &y) {return x == y;});
  }

  template <class BPRED>
  void unique(BPRED eq) {
    list_unique(*this, eq, [=, this](auto it) {return erase_or_unlink(it);});
  }
  void unique() {
    unique(equal_to<>());
  }

  template <class BPRED>
  void merge(this_t &l, BPRED less) {
    if (addressof(l) == this)
      return;
    iterator it = begin(), l_it = l.begin();
    if (l_it == l.end())
      return;
    if (it == end())
      return splice(it, l);
    for (;;) {
      if (less(*l_it, *it)) {
        const iterator bk = next(l_it);
        splice(it, l, l_it);
        l_it = bk;
        if (l_it == l.end())
          return;
      }
      else {
        ++it;
        if (it == end())
          return splice(it, l);
      }
    }
  }
  template <class BPRED>
  void merge(this_t &&l, BPRED less) {
    merge(l, less);
  }
  void merge(this_t &l) {
    merge(l, less<>());
  }
  void merge(this_t &&l) {
    merge(l, less<>());
  }

private:
  void reverse_impl(iterator it) {
    if (it != nullptr) {
      iterator tmp = it.right_child();
      it.right_child(it.left_child());
      it.left_child(tmp);
      reverse_impl(it.left_child());
      reverse_impl(it.right_child());
    }
  }
public:
  void reverse() noexcept {
    if (size() > 1u) {
      reverse_impl(root());
      const auto tmp = leftmost();
      leftmost(rightmost());
      rightmost(tmp);
    }
  }

  template <class BPRED>
  void sort(BPRED less) {
    this_t l(get_allocator());
    while (!empty()) {
      auto it = begin();
      l.insert_equal(as_lvalue,
                     [less](const value_type &x, const value_type &y) {
                       return less(const_cast<value_type &>(x),
                                   const_cast<value_type &>(y));
                     },
                     *it,
                     [&]() {unlink(it); return it;});
    }
    adl_swap(*this, l);
  }
  void sort() {
    sort(less<>());
  }

  template <class R>
  iterator replace(const_iterator i1, const_iterator i2, R &&r)
    requires (!is_convertible_v<R &&, this_t &&>) {
    return inner::fns::seq_container_replace_impl
      (*this, i1.to_mutable(), i2.to_mutable(), r);
  }

  // node and slice

  using node_type = inner::node_handle<TRAITS>;
  template <class...S>
  node_type make_node(S &&...s) {
    return node_type(new_node(forward<S>(s)...).node(), get_allocator());
  }

  node_type extract(const_iterator ci) noexcept {
    unlink(ci);
    return node_type(ci.node(), get_allocator());
  }
  iterator insert(const_iterator ci, node_type &&x) noexcept {
    return (!x.empty()) ? link(ci, iterator(x.release())) : ci.to_mutable();
  }
  void push_front(node_type &&x) noexcept {
    if (!x.empty())
      link_front(const_iterator(x.release()));
  }
  void push_back(node_type &&x) noexcept {
    if (!x.empty())
      link_back(const_iterator(x.release()));
  }
  node_type exchange(const_iterator ci, node_type &x) noexcept {
    (!x.empty()) ? exchange_node(ci, iterator(x.release())) : unlink(ci);
    return node_type(ci.node(), get_allocator());
  }
  node_type exchange(const_iterator ci, node_type &&x) noexcept {
    return exchange(ci, x);
  }
  iterator replace(const_iterator ci, node_type &&x) noexcept {
    if (!x.empty()) {
      const iterator it(x.release());
      delete_node(exchange_node(ci, it));
      return it;
    }
    else
      return erase(ci);
  }

  this_t extract(const_iterator ci, const_iterator ci2) noexcept {
    this_t l(get_allocator());
    l.splice(l.end(), *this, ci, ci2);
    return l;
  }
  iterator insert(const_iterator ci, this_t &&l) noexcept {
    if (!l.empty()) {
      const auto ret = l.begin();
      for_each_node(l, re::next, [&](auto it) {
        l.unlink(it);
        link(ci, it);
      });
      return ret;
    }
    else
      return ci.to_mutable();
  }
  void push_front(this_t &&l) noexcept {
    if (!l.empty()) {
      auto it = before_end(l);
      for (;;) {
        if (it == l.begin()) {
          l.unlink(it);
          link_front(it);
          break;
        }
        else {
          const auto tmp = prev(it);
          l.unlink(it);
          link_front(it);
          it = tmp;
        }
      }
    }
  }
  void push_back(this_t &&l) noexcept {
    for_each_node(l, re::next, [&](auto it) {
      l.unlink(it);
      link_back(it);
    });
  }
  this_t exchange(const_iterator ci, const_iterator ci2,
                  this_t &x) noexcept {
    this_t ret = extract(ci, ci2);
    insert(ci2, move(x));
    return ret;
  }
  this_t exchange(const_iterator ci, const_iterator ci2,
                  this_t &&x) noexcept {
    return exchange(ci, ci2, x);
  }
  iterator replace(const_iterator ci, const_iterator ci2,
                   this_t &&x) noexcept {
    erase(ci, ci2);
    return insert(ci2, move(x));
  }
};
template <class TRAITS>
bool operator ==(const ranked_rbtree_adaptor<TRAITS> &x,
                 const ranked_rbtree_adaptor<TRAITS> &y) {
  return equal(x, y);
}
template <class TRAITS>
synth_3way_result<typename TRAITS::value_type>
operator <=>(const ranked_rbtree_adaptor<TRAITS> &x,
             const ranked_rbtree_adaptor<TRAITS> &y) {
  return lexicographical_synth_3way(x, y);
}

}
// (set/multiset/map/multimap)_adaptor
namespace re {

template <class TREE, class LESS>
class set_adaptor;
template <class TREE, class LESS>
class multiset_adaptor;
template <class TREE, class LESS>
class map_adaptor;
template <class TREE, class LESS>
class multimap_adaptor;

template <class TREE, class LESS>
class set_adaptor : TREE, derivable_wrapper<LESS> {
  using this_t = set_adaptor;

  using base_t = TREE;
  const base_t &base() const noexcept {
    return static_cast<const base_t &>(*this);
  }
  base_t &base() noexcept {
    return static_cast<base_t &>(*this);
  }

public:
  using traits = typename base_t::traits;
  using node_pointer = typename traits::node_base_pointer;

  typename base_t::iterator root() noexcept {
    return base().root();
  }
  typename base_t::const_iterator root() const noexcept {
    return base().root();
  }
  typename base_t::iterator leftmost() noexcept {
    return base().leftmost();
  }
  typename base_t::const_iterator leftmost() const noexcept {
    return base().leftmost();
  }
  typename base_t::iterator rightmost() noexcept {
    return base().rightmost();
  }
  typename base_t::const_iterator rightmost() const noexcept {
    return base().rightmost();
  }

private:
  using less_wrapper = derivable_wrapper<LESS>;
  LESS &less_ref() noexcept {
    return *static_cast<less_wrapper &>(*this);
  }
  const LESS &less_ref() const noexcept {
    return *static_cast<const less_wrapper &>(*this);
  }

protected:
  static auto get_key() noexcept {
    return [](const auto &x)->const auto & {
      return traits::key(x);
    };
  }
  auto key_less() const noexcept {
    return ref(less_ref());
  }

  using alloc_t = typename base_t::allocator_type;

public:
  using pointer = alloc_ptr<alloc_t>;
  using const_pointer = alloc_cptr<alloc_t>;

  // container 

  using value_type = typename base_t::value_type;
  using reference = typename base_t::reference;
  using const_reference = typename base_t::const_reference;

  using iterator = typename base_t::iterator;
  using const_iterator = typename base_t::const_iterator;
  using difference_type = typename base_t::difference_type;
  using size_type = typename base_t::size_type;

  iterator begin() noexcept {
    return base_t::begin();
  }
  iterator end() noexcept {
    return base_t::end();
  }
  const_iterator begin() const noexcept {
    return base_t::begin();
  }
  const_iterator end() const noexcept {
    return base_t::end();
  }
  const_iterator cbegin() const noexcept {
    return base_t::cbegin();
  }
  const_iterator cend() const noexcept {
    return base_t::cend();
  }

  size_type max_size() const noexcept {
    return base_t::max_size();
  }
  template <bool Y = rng_is_sized<TREE>>
  enable_if_t<Y, size_type> size() const noexcept {
    return base_t::size();
  }
  bool empty() const noexcept {
    return base_t::empty();
  }

  set_adaptor() = default;
  ~set_adaptor() = default;
  set_adaptor(const set_adaptor &) = default;
  set_adaptor &operator =(const set_adaptor &) = default;
  set_adaptor(set_adaptor &&) = default;
  set_adaptor &operator =(set_adaptor &&) = default;
  friend void swap(set_adaptor &x, set_adaptor &y)
    noexcept(is_nothrow_swappable_v<base_t>
             && is_nothrow_swappable_v<LESS>) {
    adl_swap(x.base(), y.base());
    adl_swap(x.less_ref(), y.less_ref());
  }

  // optional container operations

  // reversible container

  using reverse_iterator = re::reverse_iterator<iterator>;
  using const_reverse_iterator = re::reverse_iterator<const_iterator>;

  reverse_iterator rbegin() noexcept {
    return reverse_iterator(end());
  }
  reverse_iterator rend() noexcept {
    return reverse_iterator(begin());
  }
  const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator(begin());
  }
  const_reverse_iterator crbegin() const noexcept {
    return rbegin();
  }
  const_reverse_iterator crend() const noexcept {
    return rend();
  }

  // allocator-aware container

  using allocator_type = alloc_t;
  allocator_type get_allocator() const noexcept {
    return base_t::get_allocator();
  }

  explicit set_adaptor(const alloc_t &al) noexcept : base_t(al) {}
  set_adaptor(const this_t &x, const alloc_t &al) : base_t(x.base(), al) {}
  set_adaptor(this_t &&x, const alloc_t &al) : base_t(move(x.base()), al) {}

  // associative container

  using key_type = typename traits::key_type;
  using key_compare = LESS;
  using value_compare = LESS;
  using node_type = inner::set_node_handle<traits>;
  using insert_return_type
    = inner::node_handle_insert_return_type<iterator, node_type>;

  LESS key_comp() const {
    return less_ref();
  }
  LESS value_comp() const {
    return less_ref();
  }

  explicit set_adaptor(const LESS &less) : base_t(), less_wrapper(less) {}
  set_adaptor(const LESS &less, const alloc_t &al)
    : base_t(al), less_wrapper(less) {}

  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  set_adaptor(IITR first, IITR last,
              const LESS &less = LESS{}, const alloc_t &al = alloc_t{})
    : base_t(al), less_wrapper(less) {
    base_t::insert_range(get_key(), key_less(), rng(first, last));
  }
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  set_adaptor(IITR first, IITR last, const allocator_type &al)
    : base_t(al) {
    base_t::insert_range(get_key(), key_less(), rng(first, last));
  }
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  void assign(IITR first, IITR last) {
    assign_range(rng(first, last));
  }

  set_adaptor(initializer_list<value_type> il,
              const LESS &less = LESS{}, const alloc_t &al = alloc_t{})
    : base_t(al), less_wrapper(less) {
    base_t::insert_range(get_key(), key_less(), il);
  }
  set_adaptor(initializer_list<value_type> il, const alloc_t &al)
    : base_t(al) {
    base_t::insert_range(get_key(), key_less(), il);
  }
  set_adaptor &operator =(initializer_list<value_type> il) {
    assign_range(il);
    return *this;
  }
  void assign(initializer_list<value_type> il) {
    assign_range(il);
  }

  template <class...S>
  pair<iterator, bool> emplace(S &&...s) {
    return base_t::emplace(get_key(), key_less(), forward<S>(s)...);
  }
  template <class...S>
  iterator emplace_hint(const_iterator hint, S &&...s) {
    return base_t::emplace_hint(get_key(), key_less(), hint.to_mutable(),
                                forward<S>(s)...);
  }
  pair<iterator, bool> insert(const value_type &x) {
    return base_t::insert(get_key(), key_less(), x);
  }
  pair<iterator, bool> insert(value_type &&x) {
    return base_t::insert(get_key(), key_less(), move(x));
  }
  template <class K, class X = LESS, class = typename X::is_transparent,
            class = enable_if_t<is_constructible_v<value_type, K &&>>>
  pair<iterator, bool> insert(K &&key) {
    return try_link(key, [&]() {return new_node(forward<K>(key));});
  }
  iterator insert(const_iterator hint, const value_type &x) {
    return base_t::insert(get_key(), key_less(), hint.to_mutable(), x);
  }
  iterator insert(const_iterator hint, value_type &&x) {
    return base_t::insert(get_key(), key_less(), hint.to_mutable(), move(x));
  }
  template <class K, class X = LESS, class = typename X::is_transparent,
            class = enable_if_t<is_constructible_v<value_type, K &&>>>
  iterator insert(const_iterator hint, K &&key) {
    return try_link_hint(hint.to_mutable(), key,
                         [&]() {return new_node(forward<K>(key));});
  }
  template <class IITR>
  void insert(IITR from, IITR to) {
    insert_range(rng(from, to));
  }
  void insert(initializer_list<value_type> il) {
    insert_range(il);
  }

  node_type extract(const_iterator pos) {
    return base_t::template extract<node_type>(pos);
  }
  node_type extract(const key_type &key) {
    return base_t::template extract<node_type>(get_key(), key_less(), key);
  }
  template <class K, class X = LESS, class = typename X::is_transparent,
            class = enable_if_t<!is_convertible_v<K &&, iterator>
                                && !is_convertible_v<K &&, const_iterator>>>
  node_type extract(K &&key) {
    return base_t::template extract<node_type>(get_key(), key_less(), key);
  }
  insert_return_type insert(node_type &&nh) {
    return base_t::template insert_node_handle<iterator>(get_key(), key_less(),
                                                         move(nh));
  }
  iterator insert(const_iterator hint, node_type &&nh) {
    return base_t::insert_node_handle(get_key(), key_less(),
                                      hint.to_mutable(), move(nh));
  }

  iterator erase(const_iterator pos) {
    return base_t::erase(pos);
  }
  iterator erase(const_iterator from, const_iterator to) {
    return base_t::erase(from, to);
  }
  void clear() noexcept {
    base_t::clear();
  }

  size_type erase(const key_type &key) {
    const auto it = base_t::find(get_key(), key_less(), key);
    if (it == end())
      return 0;
    erase(it);
    return 1;
  }
  template <class K, class X = LESS, class = typename X::is_transparent,
            class = enable_if_t<!is_convertible_v<K &&, iterator>
                                && !is_convertible_v<K &&, const_iterator>>>
  size_type erase(K &&key) {
    const auto it = base_t::find(get_key(), key_less(), key);
    if (it == end())
      return 0;
    erase(it);
    return 1;
  }

  size_type remove(const key_type &key) {
    const auto it = base_t::find(get_key(), key_less(), key);
    if (it == end())
      return 0;
    erase_or_unlink(it);
    return 1;
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  size_type remove(const K &key) {
    const auto it = base_t::find(get_key(), key_less(), key);
    if (it == end())
      return 0;
    erase_or_unlink(it);
    return 1;
  }
  template <class UF>
  size_type remove_if(UF eq) {
    size_type ret = 0;
    for (iterator it = begin(); it != end();) {
      if (eq(*it)) {
        it = erase_or_unlink(it);
        ++ret;
      }
      else
        ++it;
    }
    return ret;
  }
  
  template <class LESS2>
  void merge(set_adaptor<base_t, LESS2> &x) {
    base_t::merge(get_key(), key_less(), x.base());
  }
  template <class LESS2>
  void merge(set_adaptor<base_t, LESS2> &&x) {
    base_t::merge(get_key(), key_less(), x.base());
  }
  template <class LESS2>
  void merge(multiset_adaptor<base_t, LESS2> &x) {
    base_t::merge(get_key(), key_less(), x.base());
  }
  template <class LESS2>
  void merge(multiset_adaptor<base_t, LESS2> &&x) {
    base_t::merge(get_key(), key_less(), x.base());
  }

  template <class K, class LESS2 = LESS, class = typename LESS2::is_transparent>
  iterator find(const K &key) {
    return base_t::find(get_key(), key_less(), key);
  }
  template <class K, class LESS2 = LESS, class = typename LESS2::is_transparent>
  const_iterator find(const K &key) const {
    return base_t::find(get_key(), key_less(), key);
  }
  iterator find(const key_type &key) {
    return base_t::find(get_key(), key_less(), key);
  }
  const_iterator find(const key_type &key) const {
    return base_t::find(get_key(), key_less(), key);
  }

  template <class K, class LESS2 = LESS, class = typename LESS2::is_transparent>
  bool contains(const K &key) const {
    return find(key) != end();
  }
  bool contains(const key_type &key) const {
    return find(key) != end();
  }

  template <class K, class LESS2 = LESS, class = typename LESS2::is_transparent>
  size_type count(const K &key) const {
    return find(key) != end() ? 1 : 0;
  }
  size_type count(const key_type &key) const {
    return find(key) != end() ? 1 : 0;
  }

  template <class K, class LESS2 = LESS, class = typename LESS2::is_transparent>
  iterator lower_bound(const K &key) {
    return base_t::lower_bound(get_key(), key_less(), key);
  }
  template <class K, class LESS2 = LESS, class = typename LESS2::is_transparent>
  const_iterator lower_bound(const K &key) const {
    return base_t::lower_bound(get_key(), key_less(), key);
  }
  iterator lower_bound(const key_type &key) {
    return base_t::lower_bound(get_key(), key_less(), key);
  }
  const_iterator lower_bound(const key_type &key) const {
    return base_t::lower_bound(get_key(), key_less(), key);
  }

  template <class K, class LESS2 = LESS, class = typename LESS2::is_transparent>
  iterator upper_bound(const K &key) {
    return base_t::upper_bound(get_key(), key_less(), key);
  }
  template <class K, class LESS2 = LESS, class = typename LESS2::is_transparent>
  const_iterator upper_bound(const K &key) const {
    return base_t::upper_bound(get_key(), key_less(), key);
  }
  iterator upper_bound(const key_type &key) {
    return base_t::upper_bound(get_key(), key_less(), key);
  }
  const_iterator upper_bound(const key_type &key) const {
    return base_t::upper_bound(get_key(), key_less(), key);
  }

  template <class K, class LESS2 = LESS, class = typename LESS2::is_transparent>
  iter_pair<iterator> equal_range(const K &key) {
    const iterator it = base_t::find(get_key(), key_less(), key);
    return {it, it == end() ? end() : next(it)};
  }
  template <class K, class LESS2 = LESS, class = typename LESS2::is_transparent>
  iter_pair<const_iterator> equal_range(const K &key) const {
    const iterator it = base_t::find(get_key(), key_less(), key);
    return {it, it == end() ? end() : next(it)};
  }
  iter_pair<iterator> equal_range(const key_type &key) {
    const iterator it = base_t::find(get_key(), key_less(), key);
    return {it, it == end() ? end() : next(it)};
  }
  iter_pair<const_iterator> equal_range(const key_type &key) const {
    const iterator it = base_t::find(get_key(), key_less(), key);
    return {it, it == end() ? end() : next(it)};
  }

  // extensions

  template <class UPRED>
  iterator partition_point(UPRED eq) {
    return base_t::partition_point(eq);
  }
  template <class UPRED>
  const_iterator partition_point(UPRED eq) const {
    return base_t::partition_point(eq);
  }

  template <class K, class K2,
            class LESS2 = LESS, class = typename LESS2::is_transparent>
  iter_pair<iterator> find_range(const K &key, const K2 &key2) {
    return base_t::find_range(get_key(), key_less(), key, key2);
  }
  template <class K, class K2,
            class LESS2 = LESS, class = typename LESS2::is_transparent>
  iter_pair<const_iterator> find_range(const K &key, const K2 &key2) const {
    return base_t::find_range(get_key(), key_less(), key, key2);
  }
  iter_pair<iterator> find_range(const key_type &key,
                                 const key_type &key2) {
    return base_t::find_range(get_key(), key_less(), key, key2);
  }
  iter_pair<const_iterator> find_range(const key_type &key,
                                       const key_type &key2) const {
    return base_t::find_range(get_key(), key_less(), key, key2);
  }

  template <class...S>
  iterator new_node(S &&...s) {
    return base_t::new_node(forward<S>(s)...);
  }
  void delete_node(const_iterator it) noexcept {
    base_t::delete_node(it.to_mutable());
  }

  iterator unlink(const_iterator it) noexcept {
    return base_t::unlink(it);
  }
  iterator unlink(const_iterator from, const_iterator to) noexcept {
    return base_t::unlink(from, to);
  }
  void unlink() noexcept {
    base_t::unlink();
  }
  size_type unlink_key(const key_type &key) {
    const auto it = base_t::find(get_key(), key_less(), key);
    if (it == end())
      return 0;
    unlink(it);
    return 1;
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  size_type unlink_key(const K &key) {
    const auto it = base_t::find(get_key(), key_less(), key);
    if (it == end())
      return 0;
    unlink(it);
    return 1;
  }
  pair<iterator, bool> link(const_iterator it) {
    return base_t::link(get_key(), key_less(), it.to_mutable());
  }
  iterator link(const_iterator hint, const_iterator it) {
    return base_t::link(get_key(), key_less(), hint.to_mutable(),
                        it.to_mutable());
  }

  template <class K, class GET_NODE, class DO_WHEN_EQ = empty_function>
  pair<iterator, bool> try_link(const K &key, GET_NODE get_node,
                                DO_WHEN_EQ do_when_eq = DO_WHEN_EQ{}) {
    return base_t::insert(get_key(), key_less(),
                          key, get_node, do_when_eq);
  }
  template <class K, class GET_NODE, class DO_WHEN_EQ = empty_function>
  iterator try_link_hint(const_iterator hint, const K &key, GET_NODE get_node,
                         DO_WHEN_EQ do_when_eq = DO_WHEN_EQ{}) {
    return base_t::insert(get_key(), key_less(),
                          hint.to_mutable(), key, get_node, do_when_eq);
  }

  reference front() {
    return *base_t::leftmost();
  }
  const_reference front() const {
    return *base_t::leftmost();
  }
  reference back() {
    return *base_t::rightmost();
  }
  const_reference back() const {
    return *base_t::rightmost();
  }

  template <bool Y = inner::has_mfn_nth<base_t>>
  enable_if_t<Y, iterator> nth(difference_type n) noexcept {
    return base_t::nth(n);
  }
  template <bool Y = inner::has_mfn_nth<base_t>>
  enable_if_t<Y, const_iterator> nth(difference_type n) const noexcept {
    return base_t::nth(n);
  }
  template <bool Y = inner::has_mfn_nth<base_t>>
  enable_if_t<Y, difference_type> nth(const_iterator it) const noexcept {
    return base_t::nth(it);
  }

private:
  friend struct inner::fo_good;
  bool good() const noexcept {
    return base_t::good();
  }

public:
  template <bool Y = traits::store_node_allocator::value>
  enable_if_t<Y, iterator> erase_or_unlink(const_iterator it) noexcept {
    return erase(it);
  }
  template <bool Y = traits::store_node_allocator::value>
  enable_if_t<!Y, iterator> erase_or_unlink(const_iterator it) noexcept {
    return unlink(it);
  }

  void unique() {}
  template <class EQL>
  void unique(EQL eql) {
    list_unique(*this, eql, [this](auto it) {return erase_or_unlink(it);});
  };

  template <class IITR_RANGE, class = enable_if_t
            <is_rng<IITR_RANGE>
             && is_constructible_v<value_type, rng_ref<IITR_RANGE>>>>
  set_adaptor(from_range_t, IITR_RANGE &&r, const LESS &l = LESS{},
              const allocator_type &al = allocator_type{})
    : base_t(al), less_wrapper(l) {
    insert_range(r);
  }
  template <class IITR_RANGE, class = enable_if_t
            <is_rng<IITR_RANGE>
             && is_constructible_v<value_type, rng_ref<IITR_RANGE>>>>
  set_adaptor(from_range_t, IITR_RANGE &&r, const allocator_type &al)
    : base_t(al) {
    insert_range(r);
  }
  template <class IITR_RANGE, class = enable_if_t
            <!is_same_v<decay_t<IITR_RANGE>, this_t>
             && is_rng<IITR_RANGE>
             && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
             && !is_convertible_v<IITR_RANGE &&, const LESS &>
             && !is_convertible_v<IITR_RANGE &&, const alloc_t &>>>
  explicit set_adaptor(IITR_RANGE &&r) {
    insert_range(r);
  }
  template <class IITR_RANGE, class = enable_if_t
            <!is_same_v<decay_t<IITR_RANGE>, this_t>
             && is_rng<IITR_RANGE>
             && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
             && !is_convertible_v<IITR_RANGE &&, const LESS &>>>
  set_adaptor(IITR_RANGE &&r, const LESS &less, const alloc_t &al = alloc_t{})
    : base_t(al), less_wrapper(less) {
    insert_range(r);
  }
  template <class IITR_RANGE, class = enable_if_t
            <!is_same_v<decay_t<IITR_RANGE>, this_t>
             && is_rng<IITR_RANGE>
             && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
             && !is_convertible_v<IITR_RANGE &&, const LESS &>>>
  set_adaptor(IITR_RANGE &&r, const alloc_t &al) : base_t(al) {
    insert_range(r);
  }
  template <class IITR_RANGE>
  enable_if_t<!is_same_v<decay_t<IITR_RANGE>, this_t>
              && is_rng<IITR_RANGE>
              && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
              && is_assignable_v<value_type &, rng_ref<IITR_RANGE>>, this_t &>
  operator =(IITR_RANGE &&r) {
    assign_range(r);
    return *this;
  }
  template <class IITR_RANGE>
  void assign(IITR_RANGE &&r) {
    assign_range(r);
  }
  template <class IITR_RANGE>
  void assign_range(IITR_RANGE &&r) {
    base_t::assign_range(get_key(), key_less(), r,
                         [this](auto &&r) {insert_range(r);});
  }

  template <class IITR_RANGE>
  enable_if_t<(!is_transparent_function_v<LESS>
               && !is_convertible_v<IITR_RANGE &&, value_type &&>
               && !is_convertible_v<IITR_RANGE &&, const value_type &>
               && !is_convertible_v<IITR_RANGE &&, node_type &&>)
              || !is_constructible_v<value_type, IITR_RANGE &&>>
  insert(IITR_RANGE &&r) {
    insert_range(r);
  }
  template <class IITR_RANGE>
  void insert_range(IITR_RANGE &&r) {
    for (auto &i : iters(r))
      insert(*i);
  }

  this_t &append() {
    return *this;
  }
  template <class X, class...S>
  this_t &append(X &&x, S &&...s) {
    insert(forward<X>(x));
    return append(forward<S>(s)...);
  }
};
template <class TREE, class LESS>
bool operator ==(const set_adaptor<TREE, LESS> &x,
                 const set_adaptor<TREE, LESS> &y) {
  return equal(x, y);
}
template <class TREE, class LESS>
synth_3way_result<typename TREE::value_type>
operator <=>(const set_adaptor<TREE, LESS> &x,
             const set_adaptor<TREE, LESS> &y) {
  return lexicographical_synth_3way(x, y);
}

template <class TREE, class LESS>
class multiset_adaptor : TREE, derivable_wrapper<LESS> {
  using this_t = multiset_adaptor;

  using base_t = TREE;
  const base_t &base() const noexcept {
    return static_cast<const base_t &>(*this);
  }
  base_t &base() noexcept {
    return static_cast<base_t &>(*this);
  }

public:
  using traits = typename base_t::traits;
  using node_pointer = typename traits::node_base_pointer;

  typename base_t::iterator root() noexcept {
    return base().root();
  }
  typename base_t::const_iterator root() const noexcept {
    return base().root();
  }
  typename base_t::iterator leftmost() noexcept {
    return base().leftmost();
  }
  typename base_t::const_iterator leftmost() const noexcept {
    return base().leftmost();
  }
  typename base_t::iterator rightmost() noexcept {
    return base().rightmost();
  }
  typename base_t::const_iterator rightmost() const noexcept {
    return base().rightmost();
  }

private:
  using less_wrapper = derivable_wrapper<LESS>;
  LESS &less_ref() noexcept {
    return *static_cast<less_wrapper &>(*this);
  }
  const LESS &less_ref() const noexcept {
    return *static_cast<const less_wrapper &>(*this);
  }

protected:
  static auto get_key() noexcept {
    return [](const auto &x)->const auto & {
      return traits::key(x);
    };
  }
  auto key_less() const noexcept {
    return ref(less_ref());
  }

  using alloc_t = typename base_t::allocator_type;

public:

  using pointer = alloc_ptr<alloc_t>;
  using const_pointer = alloc_cptr<alloc_t>;

  // container 

  using value_type = typename base_t::value_type;
  using reference = typename base_t::reference;
  using const_reference = typename base_t::const_reference;

  using iterator = typename base_t::iterator;
  using const_iterator = typename base_t::const_iterator;
  using difference_type = typename base_t::difference_type;
  using size_type = typename base_t::size_type;

  iterator begin() noexcept {
    return base_t::begin();
  }
  iterator end() noexcept {
    return base_t::end();
  }
  const_iterator begin() const noexcept {
    return base_t::begin();
  }
  const_iterator end() const noexcept {
    return base_t::end();
  }
  const_iterator cbegin() const noexcept {
    return base_t::cbegin();
  }
  const_iterator cend() const noexcept {
    return base_t::cend();
  }

  size_type max_size() const noexcept {
    return base_t::max_size();
  }
  template <bool Y = rng_is_sized<TREE>>
  enable_if_t<Y, size_type> size() const noexcept {
    return base_t::size();
  }
  bool empty() const noexcept {
    return base_t::empty();
  }

  multiset_adaptor() = default;
  ~multiset_adaptor() = default;
  multiset_adaptor(const multiset_adaptor &) = default;
  multiset_adaptor &operator =(const multiset_adaptor &) = default;
  multiset_adaptor(multiset_adaptor &&) = default;
  multiset_adaptor &operator =(multiset_adaptor &&) = default;
  friend void swap(multiset_adaptor &x, multiset_adaptor &y)
    noexcept(is_nothrow_swappable_v<base_t>
             && is_nothrow_swappable_v<LESS>) {
    adl_swap(x.base(), y.base());
    adl_swap(x.less_ref(), y.less_ref());
  }

  // optional container operations

  // reversible container

  using reverse_iterator = re::reverse_iterator<iterator>;
  using const_reverse_iterator = re::reverse_iterator<const_iterator>;

  reverse_iterator rbegin() noexcept {
    return reverse_iterator(end());
  }
  reverse_iterator rend() noexcept {
    return reverse_iterator(begin());
  }
  const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator(begin());
  }
  const_reverse_iterator crbegin() const noexcept {
    return rbegin();
  }
  const_reverse_iterator crend() const noexcept {
    return rend();
  }

  // allocator-aware container

  using allocator_type = alloc_t;
  allocator_type get_allocator() const noexcept {
    return base_t::get_allocator();
  }

  explicit multiset_adaptor(const alloc_t &al) noexcept : base_t(al) {}
  multiset_adaptor(const this_t &x, const alloc_t &al) : base_t(x.base(), al) {}
  multiset_adaptor(this_t &&x, const alloc_t &al)
    : base_t(move(x.base()), al) {}

  // associative container

  using key_type = typename traits::key_type;
  using key_compare = LESS;
  using value_compare = LESS;
  using node_type = inner::set_node_handle<traits>;

  LESS key_comp() const {
    return less_ref();
  }
  LESS value_comp() const {
    return less_ref();
  }

  explicit multiset_adaptor(const LESS &less) : base_t(), less_wrapper(less) {}
  multiset_adaptor(const LESS &less, const alloc_t &al)
    : base_t(al), less_wrapper(less) {}

  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  multiset_adaptor(IITR first, IITR last,
                   const LESS &less = LESS{}, const alloc_t &al = alloc_t{})
    : base_t(al), less_wrapper(less) {
    base_t::insert_range_equal(get_key(), key_less(), rng(first, last));
  }
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  multiset_adaptor(IITR first, IITR last, const allocator_type &al)
    : base_t(al) {
    base_t::insert_range_equal(get_key(), key_less(), rng(first, last));
  }
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  void assign(IITR first, IITR last) {
    assign_range(rng(first, last));
  }

  multiset_adaptor(initializer_list<value_type> il,
                   const LESS &less = LESS{}, const alloc_t &al = alloc_t{})
    : base_t(al), less_wrapper(less) {
    base_t::insert_range_equal(get_key(), key_less(), il);
  }
  multiset_adaptor(initializer_list<value_type> il, const alloc_t &al)
    : base_t(al) {
    base_t::insert_range_equal(get_key(), key_less(), il);
  }
  multiset_adaptor &operator =(initializer_list<value_type> il) {
    base_t::assign_range_equal(get_key(), key_less(), il);
    return *this;
  }
  void assign(initializer_list<value_type> il) {
    assign_range(il);
  }

  template <class...S>
  iterator emplace(S &&...s) {
    return base_t::emplace_equal(get_key(), key_less(), forward<S>(s)...);
  }
  template <class...S>
  iterator emplace_hint(const_iterator hint, S &&...s) {
    return base_t::emplace_equal_hint(get_key(), key_less(),
                                      hint.to_mutable(), forward<S>(s)...);
  }
  iterator insert(const value_type &x) {
    return base_t::emplace_equal(get_key(), key_less(), x);
  }
  iterator insert(value_type &&x) {
    return base_t::emplace_equal(get_key(), key_less(), move(x));
  }
  template <class K, class X = LESS, class = typename X::is_transparent,
            class = enable_if_t<is_constructible_v<value_type, K &&>>>
  iterator insert(K &&key) {
    return try_link(forward<K>(key),
                    [&]() {return new_node(forward<K>(key));});
  }
  iterator insert(const_iterator hint, const value_type &x) {
    return base_t::emplace_equal_hint(get_key(), key_less(),
                                      hint.to_mutable(), x);
  }
  iterator insert(const_iterator hint, value_type &&x) {
    return base_t::emplace_equal_hint(get_key(), key_less(),
                                      hint.to_mutable(), move(x));
  }
  template <class K, class X = LESS, class = typename X::is_transparent,
            class = enable_if_t<is_constructible_v<value_type, K &&>>>
  iterator insert(const_iterator hint, K &&key) {
    return try_link_hint(hint.to_mutable(), forward<K>(key),
                         [&]() {return new_node(forward<K>(key));});
  }
  template <class IITR>
  void insert(IITR from, IITR to) {
    base_t::insert_range_equal(get_key(), key_less(), rng(from, to));
  }
  void insert(initializer_list<value_type> il) {
    base_t::insert_range_equal(get_key(), key_less(), il);
  }

  node_type extract(const_iterator pos) {
    return base_t::template extract<node_type>(pos);
  }
  node_type extract(const key_type &key) {
    return base_t::template extract<node_type>(get_key(), key_less(), key);
  }
  template <class K, class X = LESS, class = typename X::is_transparent,
            class = enable_if_t
            <!is_convertible_v<K &&, iterator>
             && !is_convertible_v<K &&, const_iterator>>>
  node_type extract(K &&key) {
    return base_t::template extract<node_type>(get_key(), key_less(), key);
  }
  iterator insert(node_type &&nh) {
    return base_t::insert_node_handle_equal(get_key(), key_less(), move(nh));
  }
  iterator insert(const_iterator hint, node_type &&nh) {
    return base_t::insert_node_handle_equal(get_key(), key_less(),
                                            hint.to_mutable(), move(nh));
  }

  iterator erase(const_iterator pos) {
    return base_t::erase(pos);
  }
  iterator erase(const_iterator from, const_iterator to) {
    return base_t::erase(from, to);
  }
  void clear() noexcept {
    base_t::clear();
  }

  size_type erase(const key_type &key) {
    return base_t::erase(get_key(), key_less(), key);
  }
  template <class K, class X = LESS, class = typename X::is_transparent,
            class = enable_if_t<!is_convertible_v<K &&, iterator>
                                && !is_convertible_v<K &&, const_iterator>>>
  size_type erase(K &&key) {
    return base_t::erase(get_key(), key_less(), key);
  }

  size_type remove(const key_type &key) {
    if constexpr (traits::store_node_allocator::value) {
      return base_t::erase(get_key(), key_less(), key);
    }
    else {
      return base_t::unlink(get_key(), key_less(), key);
    }
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  size_type remove(const K &key) {
    if constexpr (traits::store_node_allocator::value) {
      return base_t::erase(get_key(), key_less(), key);
    }
    else {
      return base_t::unlink(get_key(), key_less(), key);
    }
  }
  template <class UF>
  size_type remove_if(UF eq) {
    size_type ret = 0;
    for (iterator it = begin(); it != end();) {
      if (eq(*it)) {
        it = erase_or_unlink(it);
        ++ret;
      }
      else
        ++it;
    }
    return ret;
  }

  template <class LESS2>
  void merge(set_adaptor<TREE, LESS2> &x) {
    base_t::merge_equal(get_key(), key_less(), x.base());
  }
  template <class LESS2>
  void merge(set_adaptor<TREE, LESS2> &&x) {
    base_t::merge_equal(get_key(), key_less(), x.base());
  }
  template <class LESS2>
  void merge(multiset_adaptor<TREE, LESS2> &x) {
    base_t::merge_equal(get_key(), key_less(), x.base());
  }
  template <class LESS2>
  void merge(multiset_adaptor<TREE, LESS2> &&x) {
    base_t::merge_equal(get_key(), key_less(), x.base());
  }

  template <class K, class LESS2 = LESS, class = typename LESS2::is_transparent>
  iterator find(const K &key) {
    return base_t::find(get_key(), key_less(), key);
  }
  template <class K, class LESS2 = LESS, class = typename LESS2::is_transparent>
  const_iterator find(const K &key) const {
    return base_t::find(get_key(), key_less(), key);
  }
  iterator find(const key_type &key) {
    return base_t::find(get_key(), key_less(), key);
  }
  const_iterator find(const key_type &key) const {
    return base_t::find(get_key(), key_less(), key);
  }

  template <class K, class LESS2 = LESS, class = typename LESS2::is_transparent>
  bool contains(const K &key) const {
    return find(key) != end();
  }
  bool contains(const key_type &key) const {
    return find(key) != end();
  }

  template <class K, class LESS2 = LESS, class = typename LESS2::is_transparent>
  size_type count(const K &key) const {
    return base_t::count(get_key(), key_less(), key);
  }
  size_type count(const key_type &key) const {
    return base_t::count(get_key(), key_less(), key);
  }

  template <class K, class LESS2 = LESS, class = typename LESS2::is_transparent>
  iterator lower_bound(const K &key) {
    return base_t::lower_bound(get_key(), key_less(), key);
  }
  template <class K, class LESS2 = LESS, class = typename LESS2::is_transparent>
  const_iterator lower_bound(const K &key) const {
    return base_t::lower_bound(get_key(), key_less(), key);
  }
  iterator lower_bound(const key_type &key) {
    return base_t::lower_bound(get_key(), key_less(), key);
  }
  const_iterator lower_bound(const key_type &key) const {
    return base_t::lower_bound(get_key(), key_less(), key);
  }

  template <class K, class LESS2 = LESS, class = typename LESS2::is_transparent>
  iterator upper_bound(const K &key) {
    return base_t::upper_bound(get_key(), key_less(), key);
  }
  template <class K, class LESS2 = LESS, class = typename LESS2::is_transparent>
  const_iterator upper_bound(const K &key) const {
    return base_t::upper_bound(get_key(), key_less(), key);
  }
  iterator upper_bound(const key_type &key) {
    return base_t::upper_bound(get_key(), key_less(), key);
  }
  const_iterator upper_bound(const key_type &key) const {
    return base_t::upper_bound(get_key(), key_less(), key);
  }

  template <class K, class LESS2 = LESS, class = typename LESS2::is_transparent>
  iter_pair<iterator> equal_range(const K &key) {
    return base_t::equal_range(get_key(), key_less(), key);
  }
  template <class K, class LESS2 = LESS, class = typename LESS2::is_transparent>
  iter_pair<const_iterator> equal_range(const K &key) const {
    return base_t::equal_range(get_key(), key_less(), key);
  }
  iter_pair<iterator> equal_range(const key_type &key) {
    return base_t::equal_range(get_key(), key_less(), key);
  }
  iter_pair<const_iterator> equal_range(const key_type &key) const {
    return base_t::equal_range(get_key(), key_less(), key);
  }

  // extensions

  template <class UPRED>
  iterator partition_point(UPRED eq) {
    return base_t::partition_point(eq);
  }
  template <class UPRED>
  const_iterator partition_point(UPRED eq) const {
    return base_t::partition_point(eq);
  }

  template <class K, class K2,
            class LESS2 = LESS, class = typename LESS2::is_transparent>
  iter_pair<iterator> find_range(const K &key, const K2 &key2) {
    return base_t::find_range(get_key(), key_less(), key, key2);
  }
  template <class K, class K2,
            class LESS2 = LESS, class = typename LESS2::is_transparent>
  iter_pair<const_iterator> find_range(const K &key, const K2 &key2) const {
    return base_t::find_range(get_key(), key_less(), key, key2);
  }
  iter_pair<iterator> find_range(const key_type &key,
                                 const key_type &key2) {
    return base_t::find_range(get_key(), key_less(), key, key2);
  }
  iter_pair<const_iterator> find_range(const key_type &key,
                                       const key_type &key2) const {
    return base_t::find_range(get_key(), key_less(), key, key2);
  }

  template <class...S>
  iterator new_node(S &&...s) {
    return base_t::new_node(forward<S>(s)...);
  }
  void delete_node(const_iterator it) noexcept {
    base_t::delete_node(it.to_mutable());
  }

  iterator unlink(const_iterator it) noexcept {
    return base_t::unlink(it);
  }
  iterator unlink(const_iterator from, const_iterator to) noexcept {
    return base_t::unlink(from, to);
  }
  void unlink() noexcept {
    base_t::unlink();
  }
  size_type unlink_key(const key_type &key) {
    return base_t::unlink(get_key(), key_less(), key);
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  size_type unlink_key(const K &key) {
    return base_t::unlink(get_key(), key_less(), key);
  }
  iterator link(const_iterator it) {
    return base_t::link_equal(get_key(), key_less(), it.to_mutable());
  }
  iterator link(const_iterator hint, const_iterator it) {
    return base_t::link_equal(get_key(), key_less(), hint.to_mutable(),
                              it.to_mutable());
  }

  template <class K, class GET_NODE>
  iterator try_link(const K &key, GET_NODE get_node) {
    return base_t::insert_equal(get_key(), key_less(), key, get_node);
  }
  template <class K, class GET_NODE>
  iterator try_link_hint(const_iterator hint,
                         const K &key, GET_NODE get_node) {
    return base_t::insert_equal(get_key(), key_less(),
                                hint.to_mutable(), key, get_node);
  }

  reference front() {
    return *base_t::leftmost();
  }
  const_reference front() const {
    return *base_t::leftmost();
  }
  reference back() {
    return *base_t::rightmost();
  }
  const_reference back() const {
    return *base_t::rightmost();
  }

  template <bool Y = inner::has_mfn_nth<base_t>>
  enable_if_t<Y, iterator> nth(difference_type n) noexcept {
    return base_t::nth(n);
  }
  template <bool Y = inner::has_mfn_nth<base_t>>
  enable_if_t<Y, const_iterator> nth(difference_type n) const noexcept {
    return base_t::nth(n);
  }
  template <bool Y = inner::has_mfn_nth<base_t>>
  enable_if_t<Y, difference_type> nth(const_iterator it) const noexcept {
    return base_t::nth(it);
  }

private:
  friend struct inner::fo_good;
  bool good() const noexcept {
    return base_t::good();
  }

public:
  template <bool Y = traits::store_node_allocator::value>
  enable_if_t<Y, iterator> erase_or_unlink(const_iterator it) noexcept {
    return erase(it);
  }
  template <bool Y = traits::store_node_allocator::value>
  enable_if_t<!Y, iterator> erase_or_unlink(const_iterator it) noexcept {
    return unlink(it);
  }

  void unique() {
    list_unique(*this, not_fn(key_less()),
                [this](auto it) {return erase_or_unlink(it);});
  };
  template <class EQL>
  void unique(EQL eql) {
    list_unique(*this, eql, [this](auto it) {return erase_or_unlink(it);});
  };

  template <class IITR_RANGE, class = enable_if_t
            <is_rng<IITR_RANGE>
             && is_constructible_v<value_type, rng_ref<IITR_RANGE>>>>
  multiset_adaptor(from_range_t, IITR_RANGE &&r, const LESS &l = LESS{},
                   const allocator_type &al = allocator_type{})
    : base_t(al), less_wrapper(l) {
    insert_range(r);
  }
  template <class IITR_RANGE, class = enable_if_t
            <is_rng<IITR_RANGE>
             && is_constructible_v<value_type, rng_ref<IITR_RANGE>>>>
  multiset_adaptor(from_range_t, IITR_RANGE &&r, const allocator_type &al)
    : base_t(al) {
    insert_range(r);
  }
  template <class IITR_RANGE, class = enable_if_t
            <!is_same_v<decay_t<IITR_RANGE>, this_t>
             && is_rng<IITR_RANGE>
             && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
             && !is_convertible_v<IITR_RANGE &&, const LESS &>
             && !is_convertible_v<IITR_RANGE &&, const alloc_t &>>>
  explicit multiset_adaptor(IITR_RANGE &&r) {
    base_t::insert_range_equal(get_key(), key_less(), r);
  }
  template <class IITR_RANGE, class = enable_if_t
            <!is_same_v<decay_t<IITR_RANGE>, this_t>
             && is_rng<IITR_RANGE>
             && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
             && !is_convertible_v<IITR_RANGE &&, const LESS &>>>
  multiset_adaptor(IITR_RANGE &&r, const LESS &less,
                   const alloc_t &al = alloc_t{})
    : base_t(al), less_wrapper(less) {
    base_t::insert_range_equal(get_key(), key_less(), r);
  }
  template <class IITR_RANGE, class = enable_if_t
            <!is_same_v<decay_t<IITR_RANGE>, this_t>
             && is_rng<IITR_RANGE>
             && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
             && !is_convertible_v<IITR_RANGE &&, const LESS &>>>
  multiset_adaptor(IITR_RANGE &&r, const alloc_t &al) : base_t(al) {
    base_t::insert_range_equal(get_key(), key_less(), r);
  }
  template <class IITR_RANGE>
  enable_if_t<!is_same_v<decay_t<IITR_RANGE>, this_t>
              && is_rng<IITR_RANGE>
              && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
              && is_assignable_v<value_type &, rng_ref<IITR_RANGE>>, this_t &>
  operator =(IITR_RANGE &&r) {
    base_t::assign_range_equal(get_key(), key_less(), r);
    return *this;
  }
  template <class IITR_RANGE>
  void assign(IITR_RANGE &&r) {
    assign_range(r);
  }
  template <class IITR_RANGE>
  void assign_range(IITR_RANGE &&r) {
    base_t::assign_range_equal(get_key(), key_less(), r);
  }

  template <class IITR_RANGE>
  enable_if_t<(!is_transparent_function_v<LESS>
               && !is_convertible_v<IITR_RANGE &&, value_type &&>
               && !is_convertible_v<IITR_RANGE &&, const value_type &>
               && !is_convertible_v<IITR_RANGE &&, node_type &&>)
              || !is_constructible_v<value_type, IITR_RANGE &&>>
  insert(IITR_RANGE &&r) {
    insert_range(r);
  }
  template <class IITR_RANGE>
  void insert_range(IITR_RANGE &&r) {
    for (auto &i : iters(r))
      insert(*i);
  }

  this_t &append() {
    return *this;
  }
  template <class X, class...S>
  this_t &append(X &&x, S &&...s) {
    insert(forward<X>(x));
    return append(forward<S>(s)...);
  }
};
template <class TREE, class LESS>
bool operator ==(const multiset_adaptor<TREE, LESS> &x,
                 const multiset_adaptor<TREE, LESS> &y) {
  return equal(x, y);
}
template <class TREE, class LESS>
synth_3way_result<typename TREE::value_type>
operator <=>(const multiset_adaptor<TREE, LESS> &x,
             const multiset_adaptor<TREE, LESS> &y) {
  return lexicographical_synth_3way(x, y);
}

template <class TREE, class LESS>
class map_adaptor : TREE, derivable_wrapper<LESS> {
  using this_t = map_adaptor;

  using base_t = TREE;
  const base_t &base() const noexcept {
    return static_cast<const base_t &>(*this);
  }
  base_t &base() noexcept {
    return static_cast<base_t &>(*this);
  }

public:
  using traits = typename base_t::traits;
  using node_pointer = typename traits::node_base_pointer;

  typename base_t::iterator root() noexcept {
    return base().root();
  }
  typename base_t::const_iterator root() const noexcept {
    return base().root();
  }
  typename base_t::iterator leftmost() noexcept {
    return base().leftmost();
  }
  typename base_t::const_iterator leftmost() const noexcept {
    return base().leftmost();
  }
  typename base_t::iterator rightmost() noexcept {
    return base().rightmost();
  }
  typename base_t::const_iterator rightmost() const noexcept {
    return base().rightmost();
  }

private:
  using less_wrapper = derivable_wrapper<LESS>;
  LESS &less_ref() noexcept {
    return *static_cast<less_wrapper &>(*this);
  }
  const LESS &less_ref() const noexcept {
    return *static_cast<const less_wrapper &>(*this);
  }

protected:
  static auto get_key() noexcept {
    return [](const auto &x)->const auto & {
      return traits::key(x);
    };
  }
  static auto get_mapped() noexcept {
    return [](auto &x)->auto & {
      return traits::mapped(x);
    };
  }
  auto key_less() const noexcept {
    return ref(less_ref());
  }

  using alloc_t = typename base_t::allocator_type;

public:
  using pointer = alloc_ptr<alloc_t>;
  using const_pointer = alloc_cptr<alloc_t>;

  // container 

  using value_type = typename base_t::value_type;
  using reference = typename base_t::reference;
  using const_reference = typename base_t::const_reference;

  using iterator = typename base_t::iterator;
  using const_iterator = typename base_t::const_iterator;
  using difference_type = typename base_t::difference_type;
  using size_type = typename base_t::size_type;

  iterator begin() noexcept {
    return base_t::begin();
  }
  iterator end() noexcept {
    return base_t::end();
  }
  const_iterator begin() const noexcept {
    return base_t::begin();
  }
  const_iterator end() const noexcept {
    return base_t::end();
  }
  const_iterator cbegin() const noexcept {
    return base_t::cbegin();
  }
  const_iterator cend() const noexcept {
    return base_t::cend();
  }

  size_type max_size() const noexcept {
    return base_t::max_size();
  }
  template <bool Y = rng_is_sized<TREE>>
  enable_if_t<Y, size_type> size() const noexcept {
    return base_t::size();
  }
  bool empty() const noexcept {
    return base_t::empty();
  }

  map_adaptor() = default;
  ~map_adaptor() = default;
  map_adaptor(const map_adaptor &) = default;
  map_adaptor &operator =(const map_adaptor &) = default;
  map_adaptor(map_adaptor &&) = default;
  map_adaptor &operator =(map_adaptor &&) = default;
  friend void swap(map_adaptor &x, map_adaptor &y)
    noexcept(is_nothrow_swappable_v<base_t>
             && is_nothrow_swappable_v<LESS>) {
    adl_swap(x.base(), y.base());
    adl_swap(x.less_ref(), y.less_ref());
  }

  // optional container operations

  // reversible container

  using reverse_iterator = typename base_t::reverse_iterator;
  using const_reverse_iterator = typename base_t::const_reverse_iterator;

  reverse_iterator rbegin() noexcept {
    return reverse_iterator(end());
  }
  reverse_iterator rend() noexcept {
    return reverse_iterator(begin());
  }
  const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator(begin());
  }
  const_reverse_iterator crbegin() const noexcept {
    return rbegin();
  }
  const_reverse_iterator crend() const noexcept {
    return rend();
  }

  // allocator-aware container

  using allocator_type = alloc_t;
  allocator_type get_allocator() const noexcept {
    return base_t::get_allocator();
  }

  explicit map_adaptor(const alloc_t &al) noexcept : base_t(al) {}
  map_adaptor(const this_t &x, const alloc_t &al) : base_t(x.base(), al) {}
  map_adaptor(this_t &&x, const alloc_t &al) : base_t(move(x.base()), al) {}

  // associative container

  using key_type = typename traits::key_type;
  using mapped_type = typename traits::mapped_type;
  using key_compare = LESS;
  class value_compare {
    friend class map_adaptor;

    LESS l;
    explicit value_compare(const LESS &c) : l(c) {}

  public:
    value_compare() = delete;
    ~value_compare() = default;
    value_compare(const value_compare &) = default;
    value_compare &operator =(const value_compare &) = default;
    value_compare(value_compare &&) = default;
    value_compare &operator =(value_compare &&) = default;
    friend void swap(value_compare &x, value_compare &y)
      noexcept(is_nothrow_swappable_v<LESS>) {
      adl_swap(x.l, y.l);
    }

    bool operator ()(const value_type &x, const value_type &y) const {
      return l(traits::key(x), traits::key(y));
    }
  };
  using node_type = inner::map_node_handle<traits>;
  using insert_return_type
    = inner::node_handle_insert_return_type<iterator, node_type>;

  key_compare key_comp() const {
    return less_ref();
  }
  value_compare value_comp() const {
    return value_compare(less_ref());
  }

  explicit map_adaptor(const LESS &less) : base_t(), less_wrapper(less) {}
  map_adaptor(const LESS &less, const alloc_t &al)
    : base_t(al), less_wrapper(less) {}

  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  map_adaptor(IITR first, IITR last,
              const LESS &less = LESS{}, const alloc_t &al = alloc_t{})
    : base_t(al), less_wrapper(less) {
    base_t::insert_range(get_key(), key_less(), rng(first, last));
  }
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  map_adaptor(IITR first, IITR last, const allocator_type &al)
    : base_t(al) {
    base_t::insert_range(get_key(), key_less(), rng(first, last));
  }
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  void assign(IITR first, IITR last) {
    assign_range(rng(first, last));
  }

  map_adaptor(initializer_list<value_type> il,
              const LESS &less = LESS{}, const alloc_t &al = alloc_t{})
    : base_t(al), less_wrapper(less) {
    base_t::insert_range(get_key(), key_less(), il);
  }
  map_adaptor(initializer_list<value_type> il, const alloc_t &al)
    : base_t(al) {
    base_t::insert_range(get_key(), key_less(), il);
  }
  map_adaptor &operator =(initializer_list<value_type> il) {
    base_t::assign_range(get_key(), key_less(), il);
    return *this;
  }
  void assign(initializer_list<value_type> il) {
    assign_range(il);
  }

  template <class...S>
  pair<iterator, bool> emplace(S &&...s) {
    return base_t::emplace(get_key(), key_less(), forward<S>(s)...);
  }
  template <class...S>
  iterator emplace_hint(const_iterator hint, S &&...s) {
    return base_t::emplace_hint(get_key(), key_less(), hint.to_mutable(),
                                forward<S>(s)...);
  }
  pair<iterator, bool> insert(const value_type &x) {
    return base_t::insert(get_key(), key_less(), x);
  }
  pair<iterator, bool> insert(value_type &&x) {
    return base_t::insert(get_key(), key_less(), move(x));
  }
  iterator insert(const_iterator hint, const value_type &x) {
    return base_t::insert(get_key(), key_less(), hint.to_mutable(), x);
  }
  iterator insert(const_iterator hint, value_type &&x) {
    return base_t::insert(get_key(), key_less(), hint.to_mutable(), move(x));
  }
  template <class IITR>
  void insert(IITR from, IITR to) {
    base_t::insert_range(get_key(), key_less(), rng(from, to));
  }
  void insert(initializer_list<value_type> il) {
    base_t::insert_range(get_key(), key_less(), il);
  }

  node_type extract(const_iterator pos) {
    return base_t::template extract<node_type>(pos);
  }
  node_type extract(const key_type &key) {
    return base_t::template extract<node_type>(get_key(), key_less(), key);
  }
  template <class K, class X = LESS, class = typename X::is_transparent,
            class = enable_if_t<!is_convertible_v<K &&, iterator>
                                && !is_convertible_v<K &&, const_iterator>>>
  node_type extract(K &&key) {
    return base_t::template extract<node_type>(get_key(), key_less(), key);
  }

  insert_return_type insert(node_type &&nh) {
    return base_t::template insert_node_handle<iterator>(get_key(), key_less(),
                                                         move(nh));
  }
  iterator insert(const_iterator hint, node_type &&nh) {
    return base_t::insert_node_handle(get_key(), key_less(),
                                      hint.to_mutable(), move(nh));
  }

  template <class...S>
  pair<iterator, bool> try_emplace(const key_type &key, S &&...s) {
    return base_t::try_emplace(get_key(), key_less(), key, forward<S>(s)...);
  }
  template <class...S>
  pair<iterator, bool> try_emplace(key_type &&key, S &&...s) {
    return base_t::try_emplace(get_key(), key_less(), move(key),
                               forward<S>(s)...);
  }
  template <class K, class...S>
  enable_if_t<is_transparent_function_v<LESS>
              && !is_convertible_v<K &&, const_iterator>
              && !is_convertible_v<K &&, iterator>,
              pair<iterator, bool>>
  try_emplace(K &&key, S &&...s) {
    return base_t::try_emplace(get_key(), key_less(), forward<K>(key),
                               forward<S>(s)...);
  }
  template <class...S>
  iterator try_emplace(const_iterator hint, const key_type &key, S &&...s) {
    return base_t::try_emplace_hint(get_key(), key_less(), hint.to_mutable(),
                                    key, forward<S>(s)...);
  }
  template <class...S>
  iterator try_emplace(const_iterator hint, key_type &&key, S &&...s) {
    return base_t::try_emplace_hint(get_key(), key_less(), hint.to_mutable(),
                                    move(key), forward<S>(s)...);
  }
  template <class K, class...S,
            class X = LESS, class = typename X::is_transparent>
  iterator try_emplace(const_iterator hint, K &&key, S &&...s) {
    return base_t::try_emplace_hint(get_key(), key_less(), hint.to_mutable(),
                                    forward<K>(key), forward<S>(s)...);
  }
  template <class X>
  pair<iterator, bool> insert_or_assign(const key_type &key, X &&x) {
    return base_t::insert_or_assign(get_key(), get_mapped(), key_less(),
                                    key, forward<X>(x));
  }
  template <class X>
  pair<iterator, bool> insert_or_assign(key_type &&key, X &&x) {
    return base_t::insert_or_assign(get_key(), get_mapped(), key_less(),
                                    move(key), forward<X>(x));
  }
  template <class K, class X,
            class XX = LESS, class = typename XX::is_transparent>
  pair<iterator, bool> insert_or_assign(K &&key, X &&x) {
    return base_t::insert_or_assign(get_key(), get_mapped(), key_less(),
                                    forward<K>(key), forward<X>(x));
  }
  template <class X>
  iterator insert_or_assign(const_iterator hint,
                            const key_type &key, X &&x) {
    return base_t::insert_or_assign(get_key(), get_mapped(), key_less(),
                                    hint.to_mutable(), key, forward<X>(x));
  }
  template <class X>
  iterator insert_or_assign(const_iterator hint, key_type &&key, X &&x) {
    return base_t::insert_or_assign(get_key(), get_mapped(), key_less(),
                                    hint.to_mutable(), move(key),
                                    forward<X>(x));
  }
  template <class K, class X,
            class XX = LESS, class = typename XX::is_transparent>
  iterator insert_or_assign(const_iterator hint, K &&key, X &&x) {
    return base_t::insert_or_assign(get_key(), get_mapped(), key_less(),
                                    hint.to_mutable(), forward<K>(key),
                                    forward<X>(x));
  }

  mapped_type &operator [](const key_type &key) {
    return traits::mapped(*try_emplace(key).first);
  }
  mapped_type &operator [](key_type &&key) {
    return traits::mapped(*try_emplace(move(key)).first);
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  mapped_type &operator [](K &&key) {
    return traits::mapped(*try_emplace(forward<K>(key)).first);
  }

  const mapped_type &operator [](const key_type &key) const {
    return traits::mapped(*find(key));
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  const mapped_type &operator [](K &&key) const {
    return traits::mapped(*find(key));
  }

  mapped_type &at(const key_type &key) {
    const iterator it = find(key);
    if (it == end())
      throw_or_terminate<out_of_range>("re::map_adaptor: at(key) failed");
    return traits::mapped(*it);
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  mapped_type &at(const K &key) {
    const iterator it = find(key);
    if (it == end())
      throw_or_terminate<out_of_range>("re::map_adaptor: at(key) failed");
    return traits::mapped(*it);
  }

  const mapped_type &at(const key_type &key) const {
    const const_iterator it = find(key);
    if (it == end())
      throw_or_terminate<out_of_range>("re::map_adaptor: at(key) failed");
    return traits::mapped(*it);
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  const mapped_type &at(const K &key) const {
    const const_iterator it = find(key);
    if (it == end())
      throw_or_terminate<out_of_range>("re::map_adaptor: at(key) failed");
    return traits::mapped(*it);
  }

  iterator erase(const_iterator pos) {
    return base_t::erase(pos);
  }  
  iterator erase(const_iterator from, const_iterator to) {
    return base_t::erase(from, to);
  }
  void clear() noexcept {
    base_t::clear();
  }

  size_type erase(const key_type &key) {
    const auto it = base_t::find(get_key(), key_less(), key);
    if (it == end())
      return 0;
    erase(it);
    return 1;
  }
  template <class K, class X = LESS, class = typename X::is_transparent,
            class = enable_if_t<!is_convertible_v<K &&, iterator>
                                && !is_convertible_v<K &&, const_iterator>>>
  size_type erase(K &&key) {
    const auto it = base_t::find(get_key(), key_less(), key);
    if (it == end())
      return 0;
    erase(it);
    return 1;
  }

  size_type remove(const key_type &key) {
    const auto it = base_t::find(get_key(), key_less(), key);
    if (it == end())
      return 0;
    erase_or_unlink(it);
    return 1;
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  size_type remove(const K &key) {
    const auto it = base_t::find(get_key(), key_less(), key);
    if (it == end())
      return 0;
    erase_or_unlink(it);
    return 1;
  }
  template <class UF>
  size_type remove_if(UF eq) {
    size_type ret = 0;
    for (iterator it = begin(); it != end();) {
      if (eq(*it)) {
        it = erase_or_unlink(it);
        ++ret;
      }
      else
        ++it;
    }
    return ret;
  }

  template <class LESS2>
  void merge(map_adaptor<TREE, LESS2> &x) {
    base_t::merge(get_key(), key_less(), x.base());
  }
  template <class LESS2>
  void merge(map_adaptor<TREE, LESS2> &&x) {
    base_t::merge(get_key(), key_less(), x.base());
  }
  template <class LESS2>
  void merge(multimap_adaptor<TREE, LESS2> &x) {
    base_t::merge(get_key(), key_less(), x.base());
  }
  template <class LESS2>
  void merge(multimap_adaptor<TREE, LESS2> &&x) {
    base_t::merge(get_key(), key_less(), x.base());
  }

  template <class K, class LESS2 = LESS, class = typename LESS2::is_transparent>
  iterator find(const K &key) {
    return base_t::find(get_key(), key_less(), key);
  }
  template <class K, class LESS2 = LESS, class = typename LESS2::is_transparent>
  const_iterator find(const K &key) const {
    return base_t::find(get_key(), key_less(), key);
  }
  iterator find(const key_type &key) {
    return base_t::find(get_key(), key_less(), key);
  }
  const_iterator find(const key_type &key) const {
    return base_t::find(get_key(), key_less(), key);
  }

  template <class K, class LESS2 = LESS, class = typename LESS2::is_transparent>
  bool contains(const K &key) const {
    return find(key) != end();
  }
  bool contains(const key_type &key) const {
    return find(key) != end();
  }

  template <class K, class LESS2 = LESS, class = typename LESS2::is_transparent>
  size_type count(const K &key) const {
    return find(key) != end() ? 1 : 0;
  }
  size_type count(const key_type &key) const {
    return find(key) != end() ? 1 : 0;
  }

  template <class K, class LESS2 = LESS, class = typename LESS2::is_transparent>
  iterator lower_bound(const K &key) {
    return base_t::lower_bound(get_key(), key_less(), key);
  }
  template <class K, class LESS2 = LESS, class = typename LESS2::is_transparent>
  const_iterator lower_bound(const K &key) const {
    return base_t::lower_bound(get_key(), key_less(), key);
  }
  iterator lower_bound(const key_type &key) {
    return base_t::lower_bound(get_key(), key_less(), key);
  }
  const_iterator lower_bound(const key_type &key) const {
    return base_t::lower_bound(get_key(), key_less(), key);
  }

  template <class K, class LESS2 = LESS, class = typename LESS2::is_transparent>
  iterator upper_bound(const K &key) {
    return base_t::upper_bound(get_key(), key_less(), key);
  }
  template <class K, class LESS2 = LESS, class = typename LESS2::is_transparent>
  const_iterator upper_bound(const K &key) const {
    return base_t::upper_bound(get_key(), key_less(), key);
  }
  iterator upper_bound(const key_type &key) {
    return base_t::upper_bound(get_key(), key_less(), key);
  }
  const_iterator upper_bound(const key_type &key) const {
    return base_t::upper_bound(get_key(), key_less(), key);
  }

  template <class K, class LESS2 = LESS, class = typename LESS2::is_transparent>
  iter_pair<iterator> equal_range(const K &key) {
    const iterator it = base_t::find(get_key(), key_less(), key);
    return {it, it == end() ? end() : next(it)};
  }
  template <class K, class LESS2 = LESS, class = typename LESS2::is_transparent>
  iter_pair<const_iterator> equal_range(const K &key) const {
    const iterator it = base_t::find(get_key(), key_less(), key);
    return {it, it == end() ? end() : next(it)};
  }
  iter_pair<iterator> equal_range(const key_type &key) {
    const iterator it = base_t::find(get_key(), key_less(), key);
    return {it, it == end() ? end() : next(it)};
  }
  iter_pair<const_iterator> equal_range(const key_type &key) const {
    const iterator it = base_t::find(get_key(), key_less(), key);
    return {it, it == end() ? end() : next(it)};
  }

  // extensions

  template <class UPRED>
  iterator partition_point(UPRED eq) {
    return base_t::partition_point(eq);
  }
  template <class UPRED>
  const_iterator partition_point(UPRED eq) const {
    return base_t::partition_point(eq);
  }

  template <class K, class K2,
            class LESS2 = LESS, class = typename LESS2::is_transparent>
  iter_pair<iterator> find_range(const K &key, const K2 &key2) {
    return base_t::find_range(get_key(), key_less(), key, key2);
  }
  template <class K, class K2,
            class LESS2 = LESS, class = typename LESS2::is_transparent>
  iter_pair<const_iterator> find_range(const K &key, const K2 &key2) const {
    return base_t::find_range(get_key(), key_less(), key, key2);
  }
  iter_pair<iterator> find_range(const key_type &key,
                                 const key_type &key2) {
    return base_t::find_range(get_key(), key_less(), key, key2);
  }
  iter_pair<const_iterator> find_range(const key_type &key,
                                       const key_type &key2) const {
    return base_t::find_range(get_key(), key_less(), key, key2);
  }

  template <class...S>
  iterator new_node(S &&...s) {
    return base_t::new_node(forward<S>(s)...);
  }
  void delete_node(const_iterator it) noexcept {
    base_t::delete_node(it.to_mutable());
  }

  iterator unlink(const_iterator it) noexcept {
    return base_t::unlink(it);
  }
  iterator unlink(const_iterator from, const_iterator to) noexcept {
    return base_t::unlink(from, to);
  }
  void unlink() noexcept {
    base_t::unlink();
  }
  size_type unlink_key(const key_type &key) {
    const auto it = base_t::find(get_key(), key_less(), key);
    if (it == end())
      return 0;
    unlink(it);
    return 1;
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  size_type unlink_key(const K &key) {
    const auto it = base_t::find(get_key(), key_less(), key);
    if (it == end())
      return 0;
    unlink(it);
    return 1;
  }
  pair<iterator, bool> link(const_iterator it) {
    return base_t::link(get_key(), key_less(), it.to_mutable());
  }
  iterator link(const_iterator hint, const_iterator it) {
    return base_t::link(get_key(), key_less(),
                        hint.to_mutable(), it.to_mutable());
  }

  template <class K, class GET_NODE, class DO_WHEN_EQ = empty_function>
  pair<iterator, bool> try_link(const K &key, GET_NODE get_node,
                                DO_WHEN_EQ do_when_eq = DO_WHEN_EQ{}) {
    return base_t::insert(get_key(), key_less(), key, get_node, do_when_eq);
  }
  template <class K, class GET_NODE, class DO_WHEN_EQ = empty_function>
  iterator try_link_hint(const_iterator hint, const K &key, GET_NODE get_node,
                         DO_WHEN_EQ do_when_eq = DO_WHEN_EQ{}) {
    return base_t::insert(get_key(), key_less(),
                          hint.to_mutable(), key, get_node, do_when_eq);
  }

  reference front() {
    return *base_t::leftmost();
  }
  const_reference front() const {
    return *base_t::leftmost();
  }
  reference back() {
    return *base_t::rightmost();
  }
  const_reference back() const {
    return *base_t::rightmost();
  }

  template <bool Y = inner::has_mfn_nth<base_t>>
  enable_if_t<Y, iterator> nth(difference_type n) noexcept {
    return base_t::nth(n);
  }
  template <bool Y = inner::has_mfn_nth<base_t>>
  enable_if_t<Y, const_iterator> nth(difference_type n) const noexcept {
    return base_t::nth(n);
  }
  template <bool Y = inner::has_mfn_nth<base_t>>
  enable_if_t<Y, difference_type> nth(const_iterator it) const noexcept {
    return base_t::nth(it);
  }

private:
  friend struct inner::fo_good;
  bool good() const noexcept {
    return base_t::good();
  }

public:
  template <bool Y = traits::store_node_allocator::value>
  enable_if_t<Y, iterator> erase_or_unlink(const_iterator it) noexcept {
    return erase(it);
  }
  template <bool Y = traits::store_node_allocator::value>
  enable_if_t<!Y, iterator> erase_or_unlink(const_iterator it) noexcept {
    return unlink(it);
  }

  void unique() {}
  template <class EQL>
  void unique(EQL eql) {
    list_unique(*this, eql, [this](auto it) {return erase_or_unlink(it);});
  };

  template <class IITR_RANGE, class = enable_if_t
            <is_rng<IITR_RANGE>
             && is_constructible_v<value_type, rng_ref<IITR_RANGE>>>>
  map_adaptor(from_range_t, IITR_RANGE &&r, const LESS &l = LESS{},
              const allocator_type &al = allocator_type{})
    : base_t(al), less_wrapper(l) {
    insert_range(r);
  }
  template <class IITR_RANGE, class = enable_if_t
            <is_rng<IITR_RANGE>
             && is_constructible_v<value_type, rng_ref<IITR_RANGE>>>>
  map_adaptor(from_range_t, IITR_RANGE &&r, const allocator_type &al)
    : base_t(al) {
    insert_range(r);
  }
  template <class IITR_RANGE, class = enable_if_t
            <!is_same_v<decay_t<IITR_RANGE>, this_t>
             && is_rng<IITR_RANGE>
             && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
             && !is_convertible_v<IITR_RANGE &&, const LESS &>
             && !is_convertible_v<IITR_RANGE &&, const alloc_t &>>>
  explicit map_adaptor(IITR_RANGE &&r) {
    base_t::insert_range(get_key(), key_less(), r);
  }
  template <class IITR_RANGE, class = enable_if_t
            <!is_same_v<decay_t<IITR_RANGE>, this_t>
             && is_rng<IITR_RANGE>
             && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
             && !is_convertible_v<IITR_RANGE &&, const LESS &>>>
  map_adaptor(IITR_RANGE &&r, const LESS &less, const alloc_t &al = alloc_t{})
    : base_t(al), less_wrapper(less) {
    base_t::insert_range(get_key(), key_less(), r);
  }
  template <class IITR_RANGE, class = enable_if_t
            <!is_same_v<decay_t<IITR_RANGE>, this_t>
             && is_rng<IITR_RANGE>
             && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
             && !is_convertible_v<IITR_RANGE &&, const LESS &>>>
  map_adaptor(IITR_RANGE &&r, const alloc_t &al) : base_t(al) {
    base_t::insert_range(get_key(), key_less(), r);
  }
  template <class IITR_RANGE>
  enable_if_t<!is_same_v<decay_t<IITR_RANGE>, this_t>
              && is_rng<IITR_RANGE>
              && is_constructible_v<value_type, rng_ref<IITR_RANGE>>, this_t &>
  operator =(IITR_RANGE &&r) {
    base_t::assign_range(get_key(), key_less(), r);
    return *this;
  }
  template <class IITR_RANGE>
  void assign(IITR_RANGE &&r) {
    assign_range(r);
  }
  template <class IITR_RANGE>
  void assign_range(IITR_RANGE &&r) {
    base_t::assign_range(get_key(), key_less(), r);
  }

  template <class IITR_RANGE>
  enable_if_t<!is_convertible_v<IITR_RANGE &&, value_type &&>
              && !is_convertible_v<IITR_RANGE &&, const value_type &>
              && !is_convertible_v<IITR_RANGE &&, node_type &&>>
  insert(IITR_RANGE &&r) {
    base_t::insert_range(get_key(), key_less(), r);
  }
  template <class IITR_RANGE>
  void insert_range(IITR_RANGE &&r) {
    base_t::insert_range(get_key(), key_less(), r);
  }

  this_t &append() {
    return *this;
  }
  template <class X, class...S>
  this_t &append(X &&x, S &&...s) {
    insert(forward<X>(x));
    return append(forward<S>(s)...);
  }
};
template <class TREE, class LESS>
bool operator ==(const map_adaptor<TREE, LESS> &x,
                 const map_adaptor<TREE, LESS> &y) {
  return equal(x, y);
}
template <class TREE, class LESS>
synth_3way_result<typename TREE::value_type>
operator <=>(const map_adaptor<TREE, LESS> &x,
             const map_adaptor<TREE, LESS> &y) {
  return lexicographical_synth_3way(x, y);
}

template <class TREE, class LESS>
class multimap_adaptor : TREE, derivable_wrapper<LESS> {
  using this_t = multimap_adaptor;

  using base_t = TREE;
  const base_t &base() const noexcept {
    return static_cast<const base_t &>(*this);
  }
  base_t &base() noexcept {
    return static_cast<base_t &>(*this);
  }

public:
  using traits = typename base_t::traits;
  using node_pointer = typename traits::node_base_pointer;

  typename base_t::iterator root() noexcept {
    return base().root();
  }
  typename base_t::const_iterator root() const noexcept {
    return base().root();
  }
  typename base_t::iterator leftmost() noexcept {
    return base().leftmost();
  }
  typename base_t::const_iterator leftmost() const noexcept {
    return base().leftmost();
  }
  typename base_t::iterator rightmost() noexcept {
    return base().rightmost();
  }
  typename base_t::const_iterator rightmost() const noexcept {
    return base().rightmost();
  }

private:
  using less_wrapper = derivable_wrapper<LESS>;
  LESS &less_ref() noexcept {
    return *static_cast<less_wrapper &>(*this);
  }
  const LESS &less_ref() const noexcept {
    return *static_cast<const less_wrapper &>(*this);
  }

protected:
  static auto get_key() noexcept {
    return [](const auto &x)->const auto & {
      return traits::key(x);
    };
  }
  static auto get_mapped() noexcept {
    return [](auto &x)->auto && {
      return traits::mapped(x);
    };
  }
  auto key_less() const noexcept {
    return ref(less_ref());
  }

  using alloc_t = typename base_t::allocator_type;

public:
  using pointer = alloc_ptr<alloc_t>;
  using const_pointer = alloc_cptr<alloc_t>;

  // container 

  using value_type = typename base_t::value_type;
  using reference = typename base_t::reference;
  using const_reference = typename base_t::const_reference;

  using iterator = typename base_t::iterator;
  using const_iterator = typename base_t::const_iterator;
  using difference_type = typename base_t::difference_type;
  using size_type = typename base_t::size_type;

  iterator begin() noexcept {
    return base_t::begin();
  }
  iterator end() noexcept {
    return base_t::end();
  }
  const_iterator begin() const noexcept {
    return base_t::begin();
  }
  const_iterator end() const noexcept {
    return base_t::end();
  }
  const_iterator cbegin() const noexcept {
    return base_t::cbegin();
  }
  const_iterator cend() const noexcept {
    return base_t::cend();
  }

  size_type max_size() const noexcept {
    return base_t::max_size();
  }
  template <bool Y = rng_is_sized<TREE>>
  enable_if_t<Y, size_type> size() const noexcept {
    return base_t::size();
  }
  bool empty() const noexcept {
    return base_t::empty();
  }

  multimap_adaptor() = default;
  ~multimap_adaptor() = default;
  multimap_adaptor(const multimap_adaptor &) = default;
  multimap_adaptor &operator =(const multimap_adaptor &) = default;
  multimap_adaptor(multimap_adaptor &&) = default;
  multimap_adaptor &operator =(multimap_adaptor &&) = default;
  friend void swap(multimap_adaptor &x, multimap_adaptor &y)
    noexcept(is_nothrow_swappable_v<base_t>
             && is_nothrow_swappable_v<LESS>) {
    adl_swap(x.base(), y.base());
    adl_swap(x.less_ref(), y.less_ref());
  }

  // optional container operations

  // reversible container

  using reverse_iterator = typename base_t::reverse_iterator;
  using const_reverse_iterator = typename base_t::const_reverse_iterator;

  reverse_iterator rbegin() noexcept {
    return reverse_iterator(end());
  }
  reverse_iterator rend() noexcept {
    return reverse_iterator(begin());
  }
  const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator(begin());
  }
  const_reverse_iterator crbegin() const noexcept {
    return rbegin();
  }
  const_reverse_iterator crend() const noexcept {
    return rend();
  }

  // allocator-aware container

  using allocator_type = alloc_t;
  allocator_type get_allocator() const noexcept {
    return base_t::get_allocator();
  }

  explicit multimap_adaptor(const alloc_t &al) noexcept : base_t(al) {}
  multimap_adaptor(const this_t &x, const alloc_t &al) : base_t(x.base(), al) {}
  multimap_adaptor(this_t &&x, const alloc_t &al)
    : base_t(move(x.base()), al) {}

  // associative container

  using key_type = typename traits::key_type;
  using mapped_type = typename traits::mapped_type;
  using key_compare = LESS;
  class value_compare {
    friend class multimap_adaptor;

    LESS l;
    explicit value_compare(const LESS &c) : l(c) {}

  public:
    value_compare() = delete;
    ~value_compare() = default;
    value_compare(const value_compare &) = default;
    value_compare &operator =(const value_compare &) = default;
    value_compare(value_compare &&) = default;
    value_compare &operator =(value_compare &&) = default;
    friend void swap(value_compare &x, value_compare &y)
      noexcept(is_nothrow_swappable_v<LESS>) {
      adl_swap(x.l, y.l);
    }

    bool operator ()(const value_type &x, const value_type &y) const {
      return l(traits::key(x), traits::key(y));
    }
  };
  using node_type = inner::map_node_handle<traits>;

  key_compare key_comp() const {
    return less_ref();
  }
  value_compare value_comp() const {
    return value_compare(less_ref());
  }

  explicit multimap_adaptor(const LESS &less) : base_t(), less_wrapper(less) {}
  multimap_adaptor(const LESS &less, const alloc_t &al)
    : base_t(al), less_wrapper(less) {}

  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  multimap_adaptor(IITR first, IITR last,
                   const LESS &less = LESS{}, const alloc_t &al = alloc_t{})
    : base_t(al), less_wrapper(less) {
    base_t::insert_range_equal(get_key(), key_less(), rng(first, last));
  }
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  multimap_adaptor(IITR first, IITR last, const allocator_type &al)
    : base_t(al) {
    base_t::insert_range_equal(get_key(), key_less(), rng(first, last));
  }
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  void assign(IITR first, IITR last) {
    assign_range(rng(first, last));
  }

  multimap_adaptor(initializer_list<value_type> il,
                   const LESS &less = LESS{}, const alloc_t &al = alloc_t{})
    : base_t(al), less_wrapper(less) {
    base_t::insert_range_equal(get_key(), key_less(), il);
  }
  multimap_adaptor(initializer_list<value_type> il, const alloc_t &al)
    : base_t(al) {
    base_t::insert_range_equal(get_key(), key_less(), il);
  }
  multimap_adaptor &operator =(initializer_list<value_type> il) {
    base_t::assign_range_equal(get_key(), key_less(), il);
    return *this;
  }
  void assign(initializer_list<value_type> il) {
    assign_range(il);
  }

  template <class...S>
  iterator emplace(S &&...s) {
    return base_t::emplace_equal(get_key(), key_less(), forward<S>(s)...);
  }
  template <class...S>
  iterator emplace_hint(const_iterator hint, S &&...s) {
    return base_t::emplace_equal_hint(get_key(), key_less(),
                                      hint.to_mutable(), forward<S>(s)...);
  }
  iterator insert(const value_type &x) {
    return base_t::emplace_equal(get_key(), key_less(), x);
  }
  iterator insert(value_type &&x) {
    return base_t::emplace_equal(get_key(), key_less(), move(x));
  }
  iterator insert(const_iterator hint, const value_type &x) {
    return base_t::emplace_equal_hint(get_key(), key_less(),
                                      hint.to_mutable(), x);
  }
  iterator insert(const_iterator hint, value_type &&x) {
    return base_t::emplace_equal_hint(get_key(), key_less(),
                                      hint.to_mutable(), move(x));
  }
  template <class IITR>
  void insert(IITR from, IITR to) {
    base_t::insert_range_equal(get_key(), key_less(), rng(from, to));
  }
  void insert(initializer_list<value_type> il) {
    base_t::insert_range_equal(get_key(), key_less(), il);
  }

  node_type extract(const_iterator pos) {
    return base_t::template extract<node_type>(pos);
  }
  node_type extract(const key_type &key) {
    return base_t::template extract<node_type>(get_key(), key_less(), key);
  }
  template <class K, class X = LESS, class = typename X::is_transparent,
            class = enable_if_t<!is_convertible_v<K &&, iterator>
                                && !is_convertible_v<K &&, const_iterator>>>
  node_type extract(K &&key) {
    return base_t::template extract<node_type>(get_key(), key_less(), key);
  }
  iterator insert(node_type &&nh) {
    return base_t::insert_node_handle_equal(get_key(), key_less(), move(nh));
  }
  iterator insert(const_iterator hint, node_type &&nh) {
    return base_t::insert_node_handle_equal(get_key(), key_less(),
                                            hint.to_mutable(), move(nh));
  }

  iterator erase(const_iterator pos) {
    return base_t::erase(pos);
  }
  iterator erase(const_iterator from, const_iterator to) {
    return base_t::erase(from, to);
  }
  void clear() noexcept {
    base_t::clear();
  }

  size_type erase(const key_type &key) {
    return base_t::erase(get_key(), key_less(), key);
  }
  template <class K, class X = LESS, class = typename X::is_transparent,
            class = enable_if_t<!is_convertible_v<K &&, iterator>
                                && !is_convertible_v<K &&, const_iterator>>>
  size_type erase(K &&key) {
    return base_t::erase(get_key(), key_less(), key);
  }

  size_type remove(const key_type &key) {
    if constexpr (traits::store_node_allocator::value) {
      return base_t::erase(get_key(), key_less(), key);
    }
    else {
      return base_t::unlink(get_key(), key_less(), key);
    }
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  size_type remove(const K &key) {
    if constexpr (traits::store_node_allocator::value) {
      return base_t::erase(get_key(), key_less(), key);
    }
    else {
      return base_t::unlink(get_key(), key_less(), key);
    }
  }
  template <class UF>
  size_type remove_if(UF eq) {
    size_type ret = 0;
    for (iterator it = begin(); it != end();) {
      if (eq(*it)) {
        it = erase_or_unlink(it);
        ++ret;
      }
      else
        ++it;
    }
    return ret;
  }

  template <class LESS2>
  void merge(map_adaptor<TREE, LESS2> &x) {
    base_t::merge_equal(get_key(), key_less(), x.base());
  }
  template <class LESS2>
  void merge(map_adaptor<TREE, LESS2> &&x) {
    base_t::merge_equal(get_key(), key_less(), x.base());
  }
  template <class LESS2>
  void merge(multimap_adaptor<TREE, LESS2> &x) {
    base_t::merge_equal(get_key(), key_less(), x.base());
  }
  template <class LESS2>
  void merge(multimap_adaptor<TREE, LESS2> &&x) {
    base_t::merge_equal(get_key(), key_less(), x.base());
  }

  template <class K, class LESS2 = LESS, class = typename LESS2::is_transparent>
  iterator find(const K &key) {
    return base_t::find(get_key(), key_less(), key);
  }
  template <class K, class LESS2 = LESS, class = typename LESS2::is_transparent>
  const_iterator find(const K &key) const {
    return base_t::find(get_key(), key_less(), key);
  }
  iterator find(const key_type &key) {
    return base_t::find(get_key(), key_less(), key);
  }
  const_iterator find(const key_type &key) const {
    return base_t::find(get_key(), key_less(), key);
  }

  template <class K, class LESS2 = LESS, class = typename LESS2::is_transparent>
  bool contains(const K &key) const {
    return find(key) != end();
  }
  bool contains(const key_type &key) const {
    return find(key) != end();
  }

  template <class K, class LESS2 = LESS, class = typename LESS2::is_transparent>
  size_type count(const K &key) const {
    return base_t::count(get_key(), key_less(), key);
  }
  size_type count(const key_type &key) const {
    return base_t::count(get_key(), key_less(), key);
  }

  template <class K, class LESS2 = LESS, class = typename LESS2::is_transparent>
  iterator lower_bound(const K &key) {
    return base_t::lower_bound(get_key(), key_less(), key);
  }
  template <class K, class LESS2 = LESS, class = typename LESS2::is_transparent>
  const_iterator lower_bound(const K &key) const {
    return base_t::lower_bound(get_key(), key_less(), key);
  }
  iterator lower_bound(const key_type &key) {
    return base_t::lower_bound(get_key(), key_less(), key);
  }
  const_iterator lower_bound(const key_type &key) const {
    return base_t::lower_bound(get_key(), key_less(), key);
  }

  template <class K, class LESS2 = LESS, class = typename LESS2::is_transparent>
  iterator upper_bound(const K &key) {
    return base_t::upper_bound(get_key(), key_less(), key);
  }
  template <class K, class LESS2 = LESS, class = typename LESS2::is_transparent>
  const_iterator upper_bound(const K &key) const {
    return base_t::upper_bound(get_key(), key_less(), key);
  }
  iterator upper_bound(const key_type &key) {
    return base_t::upper_bound(get_key(), key_less(), key);
  }
  const_iterator upper_bound(const key_type &key) const {
    return base_t::upper_bound(get_key(), key_less(), key);
  }

  template <class K, class LESS2 = LESS, class = typename LESS2::is_transparent>
  iter_pair<iterator> equal_range(const K &key) {
    return base_t::equal_range(get_key(), key_less(), key);
  }
  template <class K, class LESS2 = LESS, class = typename LESS2::is_transparent>
  iter_pair<const_iterator> equal_range(const K &key) const {
    return base_t::equal_range(get_key(), key_less(), key);
  }
  iter_pair<iterator> equal_range(const key_type &key) {
    return base_t::equal_range(get_key(), key_less(), key);
  }
  iter_pair<const_iterator> equal_range(const key_type &key) const {
    return base_t::equal_range(get_key(), key_less(), key);
  }

  // extensions

  template <class UPRED>
  iterator partition_point(UPRED eq) {
    return base_t::partition_point(eq);
  }
  template <class UPRED>
  const_iterator partition_point(UPRED eq) const {
    return base_t::partition_point(eq);
  }

  template <class K, class K2,
            class LESS2 = LESS, class = typename LESS2::is_transparent>
  iter_pair<iterator> find_range(const K &key, const K2 &key2) {
    return base_t::find_range(get_key(), key_less(), key, key2);
  }
  template <class K, class K2,
            class LESS2 = LESS, class = typename LESS2::is_transparent>
  iter_pair<const_iterator> find_range(const K &key, const K2 &key2) const {
    return base_t::find_range(get_key(), key_less(), key, key2);
  }
  iter_pair<iterator> find_range(const key_type &key,
                                 const key_type &key2) {
    return base_t::find_range(get_key(), key_less(), key, key2);
  }
  iter_pair<const_iterator> find_range(const key_type &key,
                                       const key_type &key2) const {
    return base_t::find_range(get_key(), key_less(), key, key2);
  }

  template <class...S>
  iterator new_node(S &&...s) {
    return base_t::new_node(forward<S>(s)...);
  }
  void delete_node(iterator it) noexcept {
    base_t::delete_node(it);
  }

  iterator unlink(const_iterator it) noexcept {
    return base_t::unlink(it);
  }
  iterator unlink(const_iterator from, const_iterator to) noexcept {
    return base_t::unlink(from, to);
  }
  void unlink() noexcept {
    base_t::unlink();
  }
  size_type unlink_key(const key_type &key) {
    return base_t::unlink(get_key(), key_less(), key);
  }
  template <class K, class X = LESS, class = typename X::is_transparent>
  size_type unlink_key(const K &key) {
    return base_t::unlink(get_key(), key_less(), key);
  }
  iterator link(const_iterator it) {
    return base_t::link_equal(get_key(), key_less(), it.to_mutable());
  }
  iterator link(const_iterator hint, const_iterator it) {
    return base_t::link_equal(get_key(), key_less(),
                              hint.to_mutable(), it.to_mutable());
  }

  template <class K, class GET_NODE>
  iterator try_link(const K &key, GET_NODE get_node) {
    return base_t::insert_equal(get_key(), key_less(), key, get_node);
  }
  template <class K, class GET_NODE>
  iterator try_link_hint(const_iterator hint,
                         const K &key, GET_NODE get_node) {
    return base_t::insert_equal(get_key(), key_less(),
                                hint.to_mutable(), key, get_node);
  }

  reference front() {
    return *base_t::leftmost();
  }
  const_reference front() const {
    return *base_t::leftmost();
  }
  reference back() {
    return *base_t::rightmost();
  }
  const_reference back() const {
    return *base_t::rightmost();
  }

  template <bool Y = inner::has_mfn_nth<base_t>>
  enable_if_t<Y, iterator> nth(difference_type n) noexcept {
    return base_t::nth(n);
  }
  template <bool Y = inner::has_mfn_nth<base_t>>
  enable_if_t<Y, const_iterator> nth(difference_type n) const noexcept {
    return base_t::nth(n);
  }
  template <bool Y = inner::has_mfn_nth<base_t>>
  enable_if_t<Y, difference_type> nth(const_iterator it) const noexcept {
    return base_t::nth(it);
  }

private:
  friend struct inner::fo_good;
  bool good() const noexcept {
    return base_t::good();
  }

public:
  template <bool Y = traits::store_node_allocator::value>
  enable_if_t<Y, iterator> erase_or_unlink(const_iterator it) noexcept {
    return erase(it);
  }
  template <bool Y = traits::store_node_allocator::value>
  enable_if_t<!Y, iterator> erase_or_unlink(const_iterator it) noexcept {
    return unlink(it);
  }

  void unique() {
    list_unique(*this, not_fn(bind(key_less(),
                                   bind(get_key(), _1), bind(get_key(), _2))),
                [this](auto it) {return erase_or_unlink(it);});
  };
  template <class EQL>
  void unique(EQL eql) {
    list_unique(*this, eql, [this](auto it) {return erase_or_unlink(it);});
  };

  template <class IITR_RANGE, class = enable_if_t
            <is_rng<IITR_RANGE>
             && is_constructible_v<value_type, rng_ref<IITR_RANGE>>>>
  multimap_adaptor(from_range_t, IITR_RANGE &&r, const LESS &l = LESS{},
                   const allocator_type &al = allocator_type{})
    : base_t(al), less_wrapper(l) {
    insert_range(r);
  }
  template <class IITR_RANGE, class = enable_if_t
            <is_rng<IITR_RANGE>
             && is_constructible_v<value_type, rng_ref<IITR_RANGE>>>>
  multimap_adaptor(from_range_t, IITR_RANGE &&r, const allocator_type &al)
    : base_t(al) {
    insert_range(r);
  }
  template <class IITR_RANGE, class = enable_if_t
            <!is_same_v<decay_t<IITR_RANGE>, this_t>
             && is_rng<IITR_RANGE>
             && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
             && !is_convertible_v<IITR_RANGE &&, const alloc_t &>
             && !is_convertible_v<IITR_RANGE &&, const LESS &>>>
  explicit multimap_adaptor(IITR_RANGE &&r) {
    base_t::insert_range_equal(get_key(), key_less(), r);
  }
  template <class IITR_RANGE, class = enable_if_t
            <!is_same_v<decay_t<IITR_RANGE>, this_t>
             && is_rng<IITR_RANGE>
             && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
             && !is_convertible_v<IITR_RANGE &&, const LESS &>>>
  multimap_adaptor(IITR_RANGE &&r, const LESS &less,
                   const alloc_t &al = alloc_t{})
    : base_t(al), less_wrapper(less) {
    base_t::insert_range_equal(get_key(), key_less(), r);
  }
  template <class IITR_RANGE, class = enable_if_t
            <!is_same_v<decay_t<IITR_RANGE>, this_t>
             && is_rng<IITR_RANGE>
             && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
             && !is_convertible_v<IITR_RANGE &&, const LESS &>>>
  multimap_adaptor(IITR_RANGE &&r, const alloc_t &al) : base_t(al) {
    base_t::insert_range_equal(get_key(), key_less(), r);
  }
  template <class IITR_RANGE>
  enable_if_t<!is_same_v<decay_t<IITR_RANGE>, this_t>
              && is_rng<IITR_RANGE>
              && is_constructible_v<value_type, rng_ref<IITR_RANGE>>, this_t &>
  operator =(IITR_RANGE &&r) {
    base_t::assign_range_equal(get_key(), key_less(), r);
    return *this;
  }
  template <class IITR_RANGE>
  void assign(IITR_RANGE &&r) {
    assign_range(r);
  }
  template <class IITR_RANGE>
  void assign_range(IITR_RANGE &&r) {
    base_t::assign_range_equal(get_key(), key_less(), r);
  }

  template <class IITR_RANGE>
  enable_if_t<!is_convertible_v<IITR_RANGE &&, value_type &&>
              && !is_convertible_v<IITR_RANGE &&, const value_type &>
              && !is_convertible_v<IITR_RANGE &&, node_type &&>>
  insert(IITR_RANGE &&r) {
    base_t::insert_range_equal(get_key(), key_less(), r);
  }
  template <class IITR_RANGE>
  void insert_range(IITR_RANGE &&r) {
    base_t::insert_range_equal(get_key(), key_less(), r);
  }

  this_t &append() {
    return *this;
  }
  template <class X, class...S>
  this_t &append(X &&x, S &&...s) {
    insert(forward<X>(x));
    return append(forward<S>(s)...);
  }
};
template <class TREE, class LESS>
bool operator ==(const multimap_adaptor<TREE, LESS> &x,
                 const multimap_adaptor<TREE, LESS> &y) {
  return equal(x, y);
}
template <class TREE, class LESS>
synth_3way_result<typename TREE::value_type>
operator <=>(const multimap_adaptor<TREE, LESS> &x,
             const multimap_adaptor<TREE, LESS> &y) {
  return lexicographical_synth_3way(x, y);
}

}
// (nosz_)rbtree
// (nosz_)rb_(set/map/multiset/multimap)
namespace re {

template <class T, class AL>
struct rbtt : rbtree_traits<rbtree_node<T, alloc_void_ptr<AL>>,
                            0, 1, 1, AL> {
  static_assert(is_same_v<T, alloc_vt<AL>>);
};
template <class T, class AL>
class rbsett : public rbtt<T, AL> {
  using base_t = rbtt<T, AL>;

public:
  using key_type = typename base_t::value_type;

  static const key_type &key(const typename base_t::value_type &x) {
    return x;
  }
};
template <class T, class AL>
class rbmapt : public rbtt<T, AL> {
  using base_t = rbtt<T, AL>;

public:
  using key_type = typename base_t::value_type::first_type;
  using mapped_type = typename base_t::value_type::second_type;

  static const key_type &key(const typename base_t::value_type &x) {
    return x.first;
  }
  static mapped_type &mapped(typename base_t::value_type &x) {
    return x.second;
  }
  static const mapped_type &mapped(const typename base_t::value_type &x) {
    return x.second;
  }
};
template <class T, class AL>
struct nosz_rbtt : rbtree_traits<rbtree_node<T, alloc_void_ptr<AL>>,
                                 0, 0, 1, AL> {
  static_assert(is_same_v<T, alloc_vt<AL>>);
};
template <class T, class AL>
class nosz_rbsett : public nosz_rbtt<T, AL> {
  using base_t = rbtt<T, AL>;

public:
  using key_type = typename base_t::value_type;

  static const key_type &key(const typename base_t::value_type &x) {
    return x;
  }
};
template <class T, class AL>
class nosz_rbmapt : public nosz_rbtt<T, AL> {
  using base_t = rbtt<T, AL>;

public:
  using key_type = typename base_t::value_type::first_type;
  using mapped_type = typename base_t::value_type::second_type;

  static const key_type &key(const typename base_t::value_type &x) {
    return x.first;
  }
  static mapped_type &mapped(typename base_t::value_type &x) {
    return x.second;
  }
  static const mapped_type &mapped(const typename base_t::value_type &x) {
    return x.second;
  }
};

template <class T, class AL = default_allocator<T>>
using rbtree = rbtree_adaptor<rbtt<T, AL>>;
template <class KEY, class LESS = less<KEY>,
          class AL = default_allocator<KEY>>
using rb_set = set_adaptor<rbtree_adaptor<rbsett<KEY, AL>>, LESS>;
template <class KEY, class LESS = less<KEY>,
          class AL = default_allocator<KEY>>
using rb_multiset = multiset_adaptor<rbtree_adaptor<rbsett<KEY, AL>>, LESS>;
template <class KEY, class MAPPED, class LESS = less<KEY>,
          class AL = default_allocator<pair<KEY, MAPPED>>>
using rb_map
  = map_adaptor<rbtree_adaptor<rbmapt<pair<KEY, MAPPED>, AL>>, LESS>;
template <class KEY, class MAPPED, class LESS = less<KEY>,
          class AL = default_allocator<pair<KEY, MAPPED>>>
using rb_multimap
  = multimap_adaptor<rbtree_adaptor<rbmapt<pair<KEY, MAPPED>, AL>>, LESS>;

template <class T, class AL = default_allocator<T>>
using nosz_rbtree = rbtree_adaptor<nosz_rbtt<T, AL>>;
template <class KEY, class LESS = less<KEY>,
          class AL = default_allocator<KEY>>
using nosz_rb_set = set_adaptor<rbtree_adaptor<nosz_rbsett<KEY, AL>>, LESS>;
template <class KEY, class LESS = less<KEY>,
          class AL = default_allocator<KEY>>
using nosz_rb_multiset
  = multiset_adaptor<rbtree_adaptor<nosz_rbsett<KEY, AL>>, LESS>;
template <class KEY, class MAPPED, class LESS = less<KEY>,
          class AL = default_allocator<pair<KEY, MAPPED>>>
using nosz_rb_map
  = map_adaptor<rbtree_adaptor<nosz_rbmapt<pair<KEY, MAPPED>, AL>>, LESS>;
template <class KEY, class MAPPED, class LESS = less<KEY>,
          class AL = default_allocator<pair<KEY, MAPPED>>>
using nosz_rb_multimap
  = multimap_adaptor<rbtree_adaptor<nosz_rbmapt<pair<KEY, MAPPED>, AL>>, LESS>;

}
// (nosz_)avltree
// (nosz_)avl_(set/map/multiset/multimap)
namespace re {

template <class T, class AL>
struct avltt : avltree_traits<avltree_node<T, AL>, 0, 1, 1, AL> {
  static_assert(is_same_v<T, alloc_vt<AL>>);
};
template <class T, class AL>
class avlsett : public avltt<T, AL> {
  using base_t = avltt<T, AL>;

public:
  using key_type = typename base_t::value_type;

  static const key_type &key(const typename base_t::value_type &x) {
    return x;
  }
};
template <class T, class AL>
class avlmapt : public avltt<T, AL> {
  using base_t = avltt<T, AL>;

public:
  using key_type = typename base_t::value_type::first_type;
  using mapped_type = typename base_t::value_type::second_type;

  static const key_type &key(const typename base_t::value_type &x) {
    return x.first;
  }
  static mapped_type &mapped(typename base_t::value_type &x) {
    return x.second;
  }
  static const mapped_type &mapped(const typename base_t::value_type &x) {
    return x.second;
  }
};
template <class T, class AL>
struct nosz_avltt : avltree_traits<avltree_node<T, AL>, 0, 0, 1, AL> {
  static_assert(is_same_v<T, alloc_vt<AL>>);
};
template <class T, class AL>
class nosz_avlsett : public nosz_avltt<T, AL> {
  using base_t = avltt<T, AL>;

public:
  using key_type = typename base_t::value_type;

  static const key_type &key(const typename base_t::value_type &x) {
    return x;
  }
};
template <class T, class AL>
class nosz_avlmapt : public nosz_avltt<T, AL> {
  using base_t = avltt<T, AL>;

public:
  using key_type = typename base_t::value_type::first_type;
  using mapped_type = typename base_t::value_type::second_type;

  static const key_type &key(const typename base_t::value_type &x) {
    return x.first;
  }
  static mapped_type &mapped(typename base_t::value_type &x) {
    return x.second;
  }
  static const mapped_type &mapped(const typename base_t::value_type &x) {
    return x.second;
  }
};

template <class T, class AL = default_allocator<T>>
using avltree = avltree_adaptor<avltt<T, AL>>;
template <class KEY, class LESS = less<KEY>,
          class AL = default_allocator<KEY>>
using avl_set = set_adaptor<avltree_adaptor<avlsett<KEY, AL>>, LESS>;
template <class KEY, class LESS = less<KEY>,
          class AL = default_allocator<KEY>>
using avl_multiset = multiset_adaptor<avltree_adaptor<avlsett<KEY, AL>>, LESS>;
template <class KEY, class MAPPED, class LESS = less<KEY>,
          class AL = default_allocator<pair<KEY, MAPPED>>>
using avl_map
  = map_adaptor<avltree_adaptor<avlmapt<pair<KEY, MAPPED>, AL>>, LESS>;
template <class KEY, class MAPPED, class LESS = less<KEY>,
          class AL = default_allocator<pair<KEY, MAPPED>>>
using avl_multimap
  = multimap_adaptor<avltree_adaptor<avlmapt<pair<KEY, MAPPED>, AL>>, LESS>;

template <class T, class AL = default_allocator<T>>
using nosz_avltree = avltree_adaptor<nosz_avltt<T, AL>>;
template <class KEY, class LESS = less<KEY>,
          class AL = default_allocator<KEY>>
using nosz_avl_set = set_adaptor<avltree_adaptor<nosz_avlsett<KEY, AL>>, LESS>;
template <class KEY, class LESS = less<KEY>,
          class AL = default_allocator<KEY>>
using nosz_avl_multiset
  = multiset_adaptor<avltree_adaptor<nosz_avlsett<KEY, AL>>, LESS>;
template <class KEY, class MAPPED, class LESS = less<KEY>,
          class AL = default_allocator<pair<KEY, MAPPED>>>
using nosz_avl_map
  = map_adaptor<avltree_adaptor<nosz_avlmapt<pair<KEY, MAPPED>, AL>>, LESS>;
template <class KEY, class MAPPED, class LESS = less<KEY>,
          class AL = default_allocator<pair<KEY, MAPPED>>>
using nosz_avl_multimap
  = multimap_adaptor<avltree_adaptor<nosz_avlmapt<pair<KEY, MAPPED>, AL>>,
                     LESS>;

}
// (nosz_)(set/map/multiset/multimap)
namespace re {

template <class KEY, class LESS = less<KEY>,
          class AL = default_allocator<KEY>>
using set = set_adaptor<avltree_adaptor<avlsett<KEY, AL>>, LESS>;
template <class KEY, class LESS = less<KEY>,
          class AL = default_allocator<KEY>>
using multiset = multiset_adaptor<avltree_adaptor<avlsett<KEY, AL>>, LESS>;
template <class KEY, class MAPPED, class LESS = less<KEY>,
          class AL = default_allocator<pair<KEY, MAPPED>>>
using map = map_adaptor<avltree_adaptor<avlmapt<pair<KEY, MAPPED>, AL>>, LESS>;
template <class KEY, class MAPPED, class LESS = less<KEY>,
          class AL = default_allocator<pair<KEY, MAPPED>>>
using multimap
  = multimap_adaptor<avltree_adaptor<avlmapt<pair<KEY, MAPPED>, AL>>, LESS>;

template <class KEY, class LESS = less<KEY>,
          class AL = default_allocator<KEY>>
using nosz_set = set_adaptor<avltree_adaptor<nosz_avlsett<KEY, AL>>, LESS>;
template <class KEY, class LESS = less<KEY>,
          class AL = default_allocator<KEY>>
using nosz_multiset
  = multiset_adaptor<avltree_adaptor<nosz_avlsett<KEY, AL>>, LESS>;
template <class KEY, class MAPPED, class LESS = less<KEY>,
          class AL = default_allocator<pair<KEY, MAPPED>>>
using nosz_map
  = map_adaptor<avltree_adaptor<nosz_avlmapt<pair<KEY, MAPPED>, AL>>, LESS>;
template <class KEY, class MAPPED, class LESS = less<KEY>,
          class AL = default_allocator<pair<KEY, MAPPED>>>
using nosz_multimap
  = multimap_adaptor<avltree_adaptor<nosz_avlmapt<pair<KEY, MAPPED>, AL>>,
                     LESS>;

}
// ranked_(set/map/multiset/multimap)
namespace re {

template <class T, class AL>
struct rrbtt
  : ranked_rbtree_traits<ranked_rbtree_node<T, alloc_void_ptr<AL>>,
                         0, 1, AL> {
  static_assert(is_same_v<T, alloc_vt<AL>>);
};
template <class T, class AL>
class rsett : public rrbtt<T, AL> {
  using base_t = avltt<T, AL>;

public:
  using key_type = typename base_t::value_type;

  static const key_type &key(const typename base_t::value_type &x) {
    return x;
  }
};
template <class T, class AL>
class rmapt : public rrbtt<T, AL> {
  using base_t = avltt<T, AL>;

public:
  using key_type = typename base_t::value_type::first_type;
  using mapped_type = typename base_t::value_type::second_type;

  static const key_type &key(const typename base_t::value_type &x) {
    return x.first;
  }
  static mapped_type &mapped(typename base_t::value_type &x) {
    return x.second;
  }
  static const mapped_type &mapped(const typename base_t::value_type &x) {
    return x.second;
  }
};

template <class T, class AL = default_allocator<T>>
using ranked_rbtree = ranked_rbtree_adaptor<rrbtt<T, AL>>;
template <class KEY, class LESS = less<KEY>,
          class AL = default_allocator<KEY>>
using ranked_set = set_adaptor<ranked_rbtree_adaptor<rsett<KEY, AL>>, LESS>;
template <class KEY, class LESS = less<KEY>,
          class AL = default_allocator<KEY>>
using ranked_multiset
  = multiset_adaptor<ranked_rbtree_adaptor<rsett<KEY, AL>>, LESS>;
template <class KEY, class MAPPED, class LESS = less<KEY>,
          class AL = default_allocator<pair<KEY, MAPPED>>>
using ranked_map
  = map_adaptor<ranked_rbtree_adaptor<rmapt<pair<KEY, MAPPED>, AL>>, LESS>;
template <class KEY, class MAPPED, class LESS = less<KEY>,
          class AL = default_allocator<pair<KEY, MAPPED>>>
using ranked_multimap
  = multimap_adaptor<ranked_rbtree_adaptor<rmapt<pair<KEY, MAPPED>, AL>>, LESS>;

}

// hashtable_adaptor
namespace re {

//                                                      |
//    XXX <--.            ### <-.  ### <-.              |
//    XXX -. |            ### -.|  ### -.|              |
//       .-' |             .---'|   .---'|              |
//      \|/  |            \|/   |  \|/   |              |
//      $$$  '-- @@@ <--- @@@   '- @@@   '- $$$         |
//      $$$ ---> @@@ ---> @@@ ---> @@@ ---> $$$         |
//                                                      |
//    XXX <--.                                          |
//    XXX -. |                                          |
//       .-' |                                          |
//      \|/  |                                          |
//      $$$  '----------------------------- $$$         |
//      $$$ ------------------------------> $$$         |
//                                                      |
//  X: placeholder node                                 |
//  #: index node                                       |
//  @: data node                                        |
//  $: end node                                         |

template <size_t ID = 0, class VOID_PTR = void *>
struct htb_node_base {
  pointer_rebind_t<VOID_PTR, htb_node_base> next;
};
template <size_t ID = 0, class VOID_PTR = void *>
struct join_hashtable : htb_node_base<ID, VOID_PTR> {
  pointer_rebind_t<VOID_PTR, htb_node_base<ID, VOID_PTR>> prev;
};
template <class T, class VOID_PTR = void *>
struct hashtable_node : join_hashtable<0, VOID_PTR> {
  alignas(T) byte data[sizeof(T)];

  T &operator *() const {
    return *reinterpret_cast<T *>(addressof(data));
  }
  T *operator ->() const {
    return reinterpret_cast<T *>(addressof(data));
  }
};
namespace inner {

template <class BASE, class BASE2, class SIZE_TYPE>
struct hashtable_header_data {
  mutable BASE holder;
  mutable BASE2 ed;
  SIZE_TYPE sz;
  float factor;
};

}

template <class NODE_T, size_t ID = 0, bool STORE_NODE_ALLOCATOR = true,
          class AL = default_allocator<NODE_T>>
struct hashtable_traits {
  using value_type = alloc_vt<AL>;
  using allocator_type = AL;
  using node_type = NODE_T;
  using node_pointer = alloc_rebind_ptr<AL, node_type>;
  using node_base_type = htb_node_base<ID, alloc_void_ptr<AL>>;
  using node_base_pointer = alloc_rebind_ptr<AL, node_base_type>;
  using difference_type = alloc_dft<AL>;
  using size_type = alloc_szt<AL>;

  using id = size_constant<ID>;
  using store_node_allocator = bool_constant<STORE_NODE_ALLOCATOR>;

  static node_base_pointer next(node_base_pointer p) {
    return p->next;
  }
  static void next(node_base_pointer p, node_base_pointer p2) {
    p->next = p2;
  }

  static node_base_pointer prev(node_base_pointer p) {
    return static_cast<join_hashtable<ID, alloc_void_ptr<AL>> &>(*p).prev;
  }
  static void prev(node_base_pointer p, node_base_pointer p2) {
    static_cast<join_hashtable<ID, alloc_void_ptr<AL>> &>(*p).prev = p2;
  }

  template <class VT = value_type>
  static enable_if_t<!is_same_v<VT, node_type>, value_type *>
  data(node_base_pointer p) {
    return reinterpret_cast<value_type *>
      (addressof(static_cast<node_type &>(*p).data));
  }
  template <class VT = value_type>
  static enable_if_t<is_same_v<VT, node_type>, value_type *>
  data(node_base_pointer p) {
    return to_address(static_cast<node_pointer>(p));
  }

  using header_type = inner::hashtable_header_data
    <node_base_type, join_hashtable<ID, alloc_void_ptr<AL>>, size_type>;

  static node_base_pointer end_node(const header_type &h) {
    return pointer_to<node_base_pointer>(static_cast<node_base_type &>(h.ed));
  }
  static node_base_pointer placeholder_node(const header_type &h) {
    return pointer_to<node_base_pointer>(h.holder);
  }
  static size_type size(const header_type &h) {
    return h.sz;
  }
  static void size(header_type &h, size_type n) {
    h.sz = n;
  }
  static float factor(const header_type &h) {
    return h.factor;
  }
  static void factor(header_type &h, float f) {
    h.factor = f;
  }

  template <class...S, class VT = value_type>
  static enable_if_t<!is_same_v<VT, node_type>, node_base_pointer>
  new_node(AL &al, S &&...s) {
    return allocator_wrapper<AL>(al)
      .template new_node<node_type>(forward<S>(s)...);
  }
  template <class VT = value_type>
  static enable_if_t<!is_same_v<VT, node_type>>
  delete_node(AL &al, node_base_pointer p) noexcept {
    allocator_wrapper<AL>(al).delete_node(static_cast<node_pointer>(p));
  }

  template <class...S, class VT = value_type>
  static enable_if_t<is_same_v<VT, node_type>, node_base_pointer>
  new_node(AL &al, S &&...s) {
    return static_cast<node_base_pointer>
      (allocator_wrapper<AL>(al).new_1(forward<S>(s)...));
  }
  template <class VT = value_type>
  static enable_if_t<is_same_v<VT, node_type>>
  delete_node(AL &al, node_base_pointer p) noexcept {
    allocator_wrapper<AL>(al).delete_1(static_cast<node_pointer>(p));
  }
};

template <class>
class hashtable_adaptor;
namespace inner {

inline constexpr uint32_t htb_prime_table_32[] = {
  5, 13, 23, 47, 89, 179, 359, 719, 1439, 2879, 5779,
  11519, 23039, 46091, 92173, 184321, 368647, 737279,
  1474559, 2949119, 5898253, 11796503, 23592967, 47185967,
  94371863, 188743679, 377487361, 754974721, 1509949451
};
inline constexpr uint64_t htb_prime_table_64[] = {
  5, 13, 23, 47, 89, 179, 359, 719, 1439, 2879, 5779,
  11519, 23039, 46091, 92173, 184321, 368647, 737279,
  1474559, 2949119, 5898253, 11796503, 23592967, 47185967,
  94371863, 188743679, 377487361, 754974721, 1509949451,

  3019898923, 6039797783, 12079595519, 24159191039,
  48318382109, 96636764167, 193273528337, 386547056647,
  773094113291, 1546188226607, 3092376453119, 6184752906239,
  12369505812487, 24739011624973, 49478023249927, 98956046499847,
  197912092999693, 395824185999373, 791648371998727,
  1583296743997459, 3166593487994899, 6333186975989773,
  12666373951979533, 25332747903959063, 50665495807918151,
  101330991615836183, 202661983231672339, 405323966463344777,
  810647932926689279, 1621295865853378657, 3242591731706757127,
  6485183463413514367
};

template <class, class>
class htb_local_iterator;
template <class T, class TRAITS>
class htb_iterator {
  static_assert(is_same_v<remove_const_t<T>, typename TRAITS::value_type>);

  using this_t = htb_iterator;

  template <class>
  friend class re::hashtable_adaptor;
  template <class, class>
  friend class htb_iterator;
  template <class, class>
  friend class htb_local_iterator;

  using node_pointer = typename TRAITS::node_base_pointer;
  node_pointer p{};

public:
  using value_type = remove_const_t<T>;
  using pointer = T *;
  using reference = T &;
  using difference_type = typename TRAITS::difference_type;
  using iterator_category = bidirectional_iterator_tag;

  htb_iterator() = default;
  htb_iterator(const this_t &) = default;
  htb_iterator &operator =(const this_t &) = default;
  htb_iterator(this_t &&) = default;
  htb_iterator &operator =(this_t &&) = default;
  friend void swap(this_t &x, this_t &y) noexcept {
    adl_swap(x.p, y.p);
  }

  template <class TT = T, class = enable_if_t<is_const_v<TT>>>
  htb_iterator(htb_iterator<remove_const_t<TT>, TRAITS> it) : p(it.p) {}
  template <class TT = T, class = enable_if_t<is_const_v<TT>>>
  this_t &operator =(htb_iterator<remove_const_t<TT>, TRAITS> it) {
    p = it.p;
    return *this;
  }

  explicit htb_iterator(node_pointer p) : p(p) {}
  node_pointer node() const {
    return p;
  }
  auto to_mutable() const requires is_const_v<T> {
    return htb_iterator<remove_const_t<T>, TRAITS>(p);
  }

private:
  this_t prev() const {
    return this_t(TRAITS::prev(p));
  }
  void prev(this_t it) const {
    TRAITS::prev(p, it.node());
  }
  this_t next() const {
    return this_t(TRAITS::next(p));
  }
  void next(this_t it) const {
    TRAITS::next(p, it.node());
  }

public:
  reference operator *() const {
    return *TRAITS::data(p);
  }
  pointer operator ->() const {
    return TRAITS::data(p);
  }

  this_t &operator ++() {
    p = TRAITS::next(p);
    return *this;
  }
  this_t operator ++(int) {
    return iter_post_increment(*this);
  }

  this_t &operator --() {
    const auto prev = this->prev();
    p = (prev.next() == *this) ? prev.node() : prev.next().node();
    return *this;
  }
  this_t operator --(int) {
    return iter_post_decrement(*this);
  }
};
template <class A, class AA, class B>
enable_if_t<is_same_v<remove_const_t<A>, remove_const_t<AA>>, bool>
operator ==(htb_iterator<A, B> x, htb_iterator<AA, B> y) {
  return x.node() == y.node();
}
template <class A, class B>
bool operator ==(htb_iterator<A, B> x, nullptr_t) {
  return x.node() == nullptr;
}

template <class T, class TRAITS>
class htb_local_iterator {
  using this_t = htb_local_iterator;
  using base_t = htb_iterator<T, TRAITS>;

  base_t iter;

public:
  using value_type = typename base_t::value_type;
  using pointer = typename base_t::pointer;
  using reference = typename base_t::reference;
  using difference_type = typename base_t::difference_type;
  using iterator_category = forward_iterator_tag;

  htb_local_iterator() = default;
  ~htb_local_iterator() = default;
  htb_local_iterator(const htb_local_iterator &) = default;
  htb_local_iterator &operator =(const htb_local_iterator &) = default;
  htb_local_iterator(htb_local_iterator &&) = default;
  htb_local_iterator &operator =(htb_local_iterator &&) = default;
  friend void swap(htb_local_iterator &x, htb_local_iterator &y) noexcept {
    adl_swap(x.iter, y.iter);
  }

  template <class TT = T, class = enable_if_t<is_const_v<TT>>>
  htb_local_iterator(htb_local_iterator<remove_const_t<TT>, TRAITS> it)
    : iter(it.node()) {}
  template <class TT = T, class = enable_if_t<is_const_v<TT>>>
  this_t &operator =(htb_local_iterator<remove_const_t<TT>, TRAITS> it) {
    iter = it.node();
    return *this;
  }
  auto to_mutable() requires is_const_v<T> {
    return htb_local_iterator<remove_const_t<T>, TRAITS>(iter);
  }

  using node_pointer = typename base_t::node_pointer;
  explicit htb_local_iterator(node_pointer p) : iter(p) {}
  auto node() const {
    return iter.node();
  }

  explicit htb_local_iterator(base_t x) : iter(x) {}
  this_t &operator =(base_t x) {
    iter = x;
    return *this;
  }
  auto base() const {
    return iter;
  }

  reference operator *() const {
    return *iter;
  }
  pointer operator ->() const {
    return iter.operator ->();
  }

private:
  this_t prev() const {
    return this_t(iter.prev());
  }
  this_t next() const {
    return this_t(iter.next());
  }
public:
  this_t &operator ++() {
    const this_t prev = this->prev();
    operator =((prev.next() == *this) ? prev : this_t(nullptr));
    return *this;
  }
  this_t operator ++(int) {
    return iter_post_increment(*this);
  }
};
template <class A, class AA, class B>
enable_if_t<is_same_v<remove_const_t<A>, remove_const_t<AA>>, bool>
operator ==(htb_local_iterator<A, B> x, htb_local_iterator<AA, B> y) {
  return x.base() == y.base();
}
template <class A, class B>
bool operator ==(htb_local_iterator<A, B> x, nullptr_t) {
  return x.base() == nullptr;
}

}
template <class TRAITS>
class hashtable_adaptor
  : TRAITS::header_type
  , allocator_wrapper<typename TRAITS::allocator_type> {
  static_assert(is_same_v<typename TRAITS::value_type,
                          alloc_vt<typename TRAITS::allocator_type>>);

  using this_t = hashtable_adaptor;

  template <class SZ_T = alloc_szt<typename TRAITS::allocator_type>>
  static enable_if_t<(sizeof(SZ_T) > sizeof(int32_t)
                      && sizeof(SZ_T) <= sizeof(int64_t)),
                     decltype(inner::htb_prime_table_64) &>
  prime_table() noexcept {
    return inner::htb_prime_table_64;
  }
  template <class SZ_T = alloc_szt<typename TRAITS::allocator_type>>
  static enable_if_t<(sizeof(SZ_T) <= sizeof(int32_t)),
                     decltype(inner::htb_prime_table_32) &>
  prime_table() noexcept {
    return inner::htb_prime_table_32;
  }

  using void_pointer = alloc_void_ptr<typename TRAITS::allocator_type>;

public:

  using traits = TRAITS;
  using node_pointer = typename traits::node_base_pointer;

private:

  iter_pair<typename traits::node_base_pointer> index_array;

  typename TRAITS::header_type &head() {
    return static_cast<typename TRAITS::header_type &>(*this);
  }
  const typename TRAITS::header_type &head() const {
    return static_cast<const typename TRAITS::header_type &>(*this);
  }

  using alloc_t = typename TRAITS::allocator_type;
  using alw_t = allocator_wrapper<alloc_t>;
  using alw_t::allocate;
  using alw_t::construct;
  using alw_t::destroy;
  using alw_t::deallocate;
  using alw_t::destroy_fn;
  using alw_t::new_1;
  using alw_t::new_n;
  using alw_t::delete_1;
  using alw_t::delete_n;
  using alw_t::make_temporary;
  using alw_t::new_array;
  using alw_t::new_array_move_individually;
  using alw_t::delete_array;
  using alw_t::uninitialized_fill;
  using alw_t::uninitialized_copy;
  using alw_t::uninitialized_move;
  using alw_t::uninitialized_fully_move;
  using alw_t::fully_move;

  auto index_array_alw() const noexcept {
    return static_cast<const alw_t &>(*this)
      .template rebind<typename traits::node_base_type>();
  }

  template <class R>
  static auto begin(R &&r) {return re::begin(r);}
  template <class R>
  static auto end(R &&r) {return re::end(r);}
  template <class R>
  static auto rbegin(R &&r) {return re::rbegin(r);}
  template <class R>
  static auto rend(R &&r) {return re::rend(r);}
  template <class R>
  static auto size(R &&r) {return re::size(r);}
  template <class R>
  static auto empty(R &&r) {return re::empty(r);}

public:

  // container

  using value_type = typename traits::value_type;
  using reference = value_type &;
  using const_reference = const value_type &;

  using iterator = inner::htb_iterator<value_type, traits>;
  using const_iterator = inner::htb_iterator<const value_type, traits>;
  using difference_type = typename traits::difference_type;
  using size_type = typename traits::size_type;

  iterator begin() noexcept {
    return iterator(traits::next(traits::end_node(head())));
  }
  iterator end() noexcept {
    return iterator(traits::end_node(head()));
  }
  const_iterator begin() const noexcept {
    return const_iterator(traits::next(traits::end_node(head())));
  }
  const_iterator end() const noexcept {
    return const_iterator(traits::end_node(head()));
  }
  const_iterator cbegin() const noexcept {
    return begin();
  }
  const_iterator cend() const noexcept {
    return end();
  }

  size_type max_size() const noexcept {
    return container_regular_max_size<this_t>();
  }
  size_type size() const noexcept {
    return traits::size(head());
  }
  bool empty() const noexcept {
    return size() == 0u;
  }

  // inner implements

  void set_size(size_type n) noexcept {
    TRAITS::size(head(), n);
  }

private:

  void set_factor(float f) noexcept {
    traits::factor(head(), f);
  }
  float factor() const noexcept {
    return traits::factor(head());
  }

  void index_array_fill_zero() noexcept {
    for (auto &x : index_array)
      iterator(pointer_to<void_pointer>(x)).next(iterator{});
  }
  iter_pair<node_pointer> new_index_array(size_type n) {
    iter_pair<node_pointer> ret = index_array_alw().new_array(n);
    for (auto &x : ret)
      iterator(pointer_to<void_pointer>(x)).next(iterator{});
    return ret;
  }

  iterator placeholder_node() const noexcept {
    return iterator(traits::placeholder_node(head()));
  }

  void relink_end_empty() noexcept {
    end().prev(placeholder_node());
    placeholder_node().next(end());
    end().next(end());
  }
  void relink_end_non_empty() noexcept {
    end().next().prev(placeholder_node());
    placeholder_node().next(end());
    end().prev().next().next(end());
  }
  void relink_end(bool is_empty) noexcept {
    is_empty ? relink_end_empty() : relink_end_non_empty();
  }

  void new_data_impl_prepare_for(const this_t &v) {
    index_array = new_index_array(size(v.index_array));
    set_factor(v.factor());
    set_size(v.size());
    relink_end_empty();
  }
  template <class THIS_T, class F, class FF>
  void new_data_impl_insert(THIS_T &&v, F prepare, FF get_new_node) {
    prepare(v);
    iterator v_index_it;
    for (iterator v_it = (v_index_it
                          = iterator(v.end().prev().node())).next();
         v_it != v.end();
         v_it = (v_index_it = iterator(v_it.prev().node())).next()) {
      const auto dif = v_index_it.node() - begin(v.index_array);
      const iterator index_it(pointer_to<void_pointer>
                              (ref(index_array, dif)));
      link_to_new_bucket(index_it, end(), get_new_node(*v_it));
      while (v_it.prev().next() == v_it) {
        const iterator node = get_new_node(*(v_it = v_it.prev()));
        const iterator bucket_first_node = end().next();
        node.next(bucket_first_node);
        bucket_first_node.prev(node);
        node.prev(placeholder_node());
        end().next(node);
      }
    }
  }
  template <class THIS_T, class F>
  void new_data_impl(THIS_T &&v, F get_new_node) {
#ifndef RE_NOEXCEPT
    try {
#endif
      new_data_impl_insert
        (v, [&](const this_t &x) {new_data_impl_prepare_for(x);}, get_new_node);
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      delete_data();
      throw;
    }
#endif
  }

  template <class THIS_T, class F>
  void assign_data_impl(THIS_T &&v, F get_val) {
    if (size(index_array) != size(v.index_array))
      index_array_alw().delete_array
        (exchange(index_array, new_index_array(size(v.index_array))));

    iterator it = begin();
    end().next(end());
    end().prev(placeholder_node());
    set_size(v.size());
    set_factor(v.factor());
    index_array_fill_zero();

    const auto guard = exit_fn([&]() {
      for_each_node(rng(it, end()), next, [&](iterator it) {delete_node(it);});
    });

    const auto get_new_node = [&]<class T>(T &&x)->iterator {
      if (it == end())
        return new_node(get_val(x));
      else {
        *it = get_val(x);
        return exchange(it, it.next());
      }
    };

#ifndef RE_NOEXCEPT
    try {
#endif
      new_data_impl_insert(v, empty_function{}, get_new_node);
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      delete_data();
      new_data();
      throw;
    }
#endif
  }

  friend class allocator_aware_container_ownership<this_t>;
  const alloc_t &alloc_ref() const noexcept {
    return alw_t::get();
  }
  alloc_t &alloc_ref() noexcept {
    return alw_t::get();
  }
  void new_data() noexcept {
    index_array = {};
    relink_end_empty();
    set_size(0);
  }
  void delete_data() noexcept {
    index_array_alw().delete_array(index_array);
  }
  void delete_data() noexcept
    requires traits::store_node_allocator::value {
    index_array_alw().delete_array(index_array);
    for_each_node(*this, next, [&](iterator it) {delete_node(it);});
  }
  void new_data(const this_t &v) {
    new_data_impl(v, [&](const value_type &x) {return new_node(x);});
  }
  void assign_data(const this_t &v) {
    assign_data_impl(v, as_lvalue);
  }
  void new_data(this_t &&v) noexcept {
    const bool y = v.empty();
    index_array = move(v.index_array);
    head() = move(v.head());
    relink_end(y);
    v.new_data();
  }
  void new_data_individually(this_t &&v) {
    index_array = index_array_alw()
      .new_array_move_individually(v.index_array, v.index_array_alw().get());
    const bool v_is_empty = v.empty();
    head() = move(v.head());
    relink_end(v_is_empty);
    v.new_data();
  }
  void new_data_individually(this_t &&v)
    requires traits::store_node_allocator::value {
    auto guard = exit_fn([&]() {
      v.delete_data();
      v.new_data();
    });
    new_data_impl(v, [&](value_type &x) {return new_node(move(x));});
  }
  void assign_data_individually(this_t &&v) {
    const bool v_is_empty = v.empty();

    index_array_alw().delete_array
      (exchange(index_array,
                index_array_alw().new_array_move_individually
                (v.index_array, v.index_array_alw().get())));

    head() = move(v.head());
    relink_end(v_is_empty);

    v.new_data();
  }
  void assign_data_individually(this_t &&v)
    requires traits::store_node_allocator::value {
    const auto guard = exit_fn([&]() {
      v.delete_data();
      v.new_data();
    });
    assign_data_impl(v, move);
  }
  void swap_data(this_t &v) noexcept {
    adl_swap(index_array, v.index_array);
    const bool y1 = empty();
    const bool y2 = v.empty();
    adl_swap(head(), v.head());
    relink_end(y2);
    v.relink_end(y1);
  }

public:
  // node operations

  template <class...S, bool Y = traits::store_node_allocator::value>
  iterator new_node(S &&...s) {
    static_assert(Y);
    return iterator(traits::new_node(alloc_ref(), forward<S>(s)...));
  }
  template <bool Y = traits::store_node_allocator::value>
  void delete_node(const_iterator it) {
    static_assert(Y);
    traits::delete_node(alloc_ref(), it.node());
  }
private:
  template <bool Y = traits::store_node_allocator::value>
  enable_if_t<Y> delete_node_if_storing_node_alloc(iterator it) {
    delete_node(it);
  }
  template <bool Y = traits::store_node_allocator::value>
  enable_if_t<!Y> delete_node_if_storing_node_alloc(iterator) {}

public:

  // container (continued)

  hashtable_adaptor() noexcept(noexcept(alloc_t{}))
    : hashtable_adaptor(alloc_t{}) {}
  ~hashtable_adaptor() {
    delete_data();
  }
  hashtable_adaptor(const hashtable_adaptor &) = delete;
  hashtable_adaptor(const hashtable_adaptor &v)
    requires traits::store_node_allocator::value
    : alw_t(alw_t::traits
            ::select_on_container_copy_construction(v.alloc_ref())) {
    new_data(v);
  }
  hashtable_adaptor &operator =(const hashtable_adaptor &) = delete;
  hashtable_adaptor &operator =(const hashtable_adaptor &v)
    requires traits::store_node_allocator::value {
    allocator_aware_container_ownership<this_t>::copy_assign(*this, v);
    return *this;
  }
  hashtable_adaptor(hashtable_adaptor &&v) noexcept
    : alw_t(move(v.alloc_ref())) {
    new_data(move(v));
  }
  hashtable_adaptor &operator =(hashtable_adaptor &&v)
    noexcept(alloc_move_prpg<alloc_t> || alloc_always_equal<alloc_t>) {
    allocator_aware_container_ownership<this_t>::move_assign(*this, v);
    return *this;
  }
  friend void swap(hashtable_adaptor &x, hashtable_adaptor &y)
    noexcept(alloc_swap_prpg<alloc_t> || alloc_always_equal<alloc_t>) {
    allocator_aware_container_ownership<this_t>::swap(x, y);
  }

  template <class TRAITS2>
  friend bool operator ==(const hashtable_adaptor<TRAITS2> &,
                          const hashtable_adaptor<TRAITS2> &);

  // reversible container

  using reverse_iterator = re::reverse_iterator<iterator>;
  using const_reverse_iterator = re::reverse_iterator<const_iterator>;

  reverse_iterator rbegin() noexcept {
    return reverse_iterator(end());
  }
  reverse_iterator rend() noexcept {
    return reverse_iterator(begin());
  }
  const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator(begin());
  }
  const_reverse_iterator crbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  const_reverse_iterator crend() const noexcept {
    return const_reverse_iterator(begin());
  }

  // allocator-aware container

  using allocator_type = typename traits::allocator_type;
  alloc_t get_allocator() const noexcept {
    return alw_t::get();
  }

  explicit hashtable_adaptor(const alloc_t &al) noexcept : alw_t(al) {
    set_factor(1.0f);
    new_data();
  }
  template <bool Y = traits::store_node_allocator::value>
  hashtable_adaptor(const this_t &x, const alloc_t &al) : alw_t(al) {
    static_assert(Y);
    new_data(x);
  }
  hashtable_adaptor(this_t &&x, const alloc_t &al) : alw_t(al) {
    allocator_aware_container_ownership<this_t>::move_construct(*this, x);
  }

  // specialized operations

  using local_iterator = inner::htb_local_iterator<value_type, traits>;
  using const_local_iterator
    = inner::htb_local_iterator<const value_type, traits>;
  local_iterator begin(size_type n) noexcept {
    return local_iterator
      (traits::next(pointer_to<void_pointer>(ref(index_array, n))));
  }
  local_iterator end(size_type n) noexcept {
    return local_iterator{};
  }
  const_local_iterator begin(size_type n) const noexcept {
    return const_local_iterator
      (traits::next(pointer_to<void_pointer>(ref(index_array, n))));
  }
  const_local_iterator end(size_type n) const noexcept {
    return const_local_iterator{};
  }
  const_local_iterator cbegin(size_type n) const noexcept {
    return begin(n);
  }
  const_local_iterator cend(size_type n) const noexcept {
    return end(n);
  }

  size_type bucket_count() const noexcept {
    return size(index_array);
  }
  size_type active_bucket_count() const noexcept {
    return count_if(index_array, [](auto &x) {
      return iterator(pointer_to<void_pointer>(x)).next() != nullptr;
    });
  }
  size_type max_bucket_count() const noexcept {
    return re::back(prime_table());
  }
  size_type bucket_size(size_type n) const {
    return size(bucket_range(n));
  }
  template <class HASH, class KEY>
  size_type bucket(HASH hash, const KEY &k) const {
    return hash(k) % size(index_array);
  }
  iter_pair<local_iterator> bucket_range(size_type n) {
    const iterator index_it(pointer_to<void_pointer>(ref(index_array, n)));
    return {
      local_iterator(index_it.next().node()),
      local_iterator{}
    };
  }
  iter_pair<const_local_iterator> bucket_range(size_type n) const {
    const iterator index_it(pointer_to<void_pointer>(ref(index_array, n)));
    return {
      const_local_iterator(index_it.next().node()),
      const_local_iterator{}
    };
  }

  float load_factor() const noexcept {
    return static_cast<float>(size()) / bucket_count();
  }
  float max_load_factor() const noexcept {
    return factor();
  }
  void max_load_factor(float f) {
    set_factor(f);
  }

  template <class GET_KEY, class HASH, class EQUAL, class KEY>
  iterator find(GET_KEY get_key, HASH hash, EQUAL eq,
                const KEY &key) const {
    if (!empty()) {
      const size_type k = hash(key) % bucket_count();
      const const_iterator index_it
        (pointer_to<void_pointer>(ref(index_array, k)));
      if (index_it.next() != nullptr)
        for (const_iterator it = index_it.next();; it = it.prev()) {
          if (eq(get_key(*it), key))
            return it.to_mutable();
          if (it.prev().next() != it)
            break;
        }
    }
    return end().to_mutable();
  }

  template <class GET_KEY, class HASH, class EQUAL, class KEY>
  iter_pair<iterator>
  equal_range(GET_KEY get_key, HASH hash, EQUAL eq, const KEY &key) const {
    if (!empty()) {
      const size_type k = hash(key) % bucket_count();
      const iterator index_it(pointer_to<void_pointer>(ref(index_array, k)));
      if (index_it.next() != nullptr) {
        iterator it = index_it.next();
        for (;;) {
          if (eq(get_key(*it), key)) {
            iterator it2 = it;
            while (it2.prev().next() == it2) {
              if (!eq(get_key(*it2.prev()), key))
                break;
              it2 = it2.prev();
            }
            return {it2, it.next()};
          }
          if (it.prev().next() != it)
            break;
          it = it.prev();
        }
      }
    }
    return {end().to_mutable(), end().to_mutable()};
  }

  template <class GET_KEY, class HASH, class EQUAL, class KEY>
  size_type count(GET_KEY get_key, HASH hash, EQUAL eq,
                  const KEY &key) const {
    if (!empty()) {
      const size_type k = hash(key) % bucket_count();
      const iterator index_it(pointer_to<void_pointer>(ref(index_array, k)));
      if (index_it.next() != nullptr) {
        iterator it = index_it.next();
        for (;;) {
          if (eq(get_key(*it), key)) {
            size_type c = 1;
            while (it.prev().next() == it) {
              it = it.prev();
              if (!eq(get_key(*it), key))
                break;
              ++c;
            }
            return c;
          }
          if (it.prev().next() != it)
            break;
          it = it.prev();
        }
      }
    }
    return 0;
  }

  iterator unlink(const_iterator cit) noexcept {
    const iterator it = cit.to_mutable();
    const iterator prev = it.prev();
    const iterator actual_prev = (prev.next() == it ? prev : prev.next());
    const iterator actual_next = it.next();
    if (actual_next.prev() != it) {
      if (prev != actual_prev) {
        actual_next.prev().next(iterator{});
        actual_next.prev(prev);
      }
      else
        actual_next.prev().next(actual_prev);
    }
    else
      actual_next.prev(prev);

    actual_prev.next(actual_next);

    set_size(size() - 1u);
    return actual_next;
  }
  iterator unlink(const_iterator from, const_iterator to) noexcept {
    while (from != to)
      from = unlink(from);
    return to.to_mutable();
  }
private:
  void bucket_unlink_impl(iterator it, iterator last_it) noexcept {
    const iterator prev = it.prev();
    const iterator actual_prev = prev.next() == it ? prev : prev.next();
    const iterator actual_next = last_it.next();
    if (actual_next.prev() != last_it) {
      if (prev != actual_prev) {
        actual_next.prev().next(iterator{});
        actual_next.prev(prev);
      }
      else
        actual_next.prev().next(actual_prev);
    }
    else
      actual_next.prev(prev);

    actual_prev.next(actual_next);
  }
  void bucket_erase_impl(iterator it, iterator last_it) noexcept {
    bucket_unlink_impl(it, last_it);
    for (;;) {
      const auto it2 = it.next();
      delete_node(it);
      if (it == last_it)
        break;
      it = it2;
    }
  }
  template <class GET_KEY, class HASH, class EQUAL, class KEY,
            class DF>
  size_type erase_impl(GET_KEY get_key, HASH hash, EQUAL eq, const KEY &key,
                       DF in_bucket_erase) {
    if (!empty()) {
      const size_type k = hash(key) % bucket_count();
      const iterator index_it(pointer_to<void_pointer>(ref(index_array, k)));
      if (index_it.next() != nullptr) {
        iterator it = index_it.next();
        for (;;) {
          if (eq(get_key(*it), key)) {
            size_type ret = 1;
            iterator it2 = it;
            while (it2.prev().next() == it2) {
              if (!eq(get_key(*it2.prev()), key))
                break;
              ++ret;
              it2 = it2.prev();
            }
            in_bucket_erase(it2, it);
            set_size(size() - ret);
            return ret;
          }
          if (it.prev().next() != it)
            break;
          it = it.prev();
        }
      }
    }
    return 0;
  }
public:
  void unlink() noexcept {
    relink_end_empty();
    set_size(0);
    index_array_fill_zero();
  }
  template <class GET_KEY, class HASH, class EQUAL, class KEY>
  size_type unlink(GET_KEY get_key, HASH hash, EQUAL eq, const KEY &key) {
    return erase_impl(get_key, hash, eq, key,
                      [&](iterator it, iterator it2) {
                        bucket_unlink_impl(it, it2);
                      });
  }
  iterator erase(const_iterator it) {
    const auto ret = unlink(it);
    delete_node(it);
    return ret;
  }
  iterator erase(const_iterator from, const_iterator to) {
    while (from != to)
      from = erase(from);
    return from.to_mutable();
  }
  template <class GET_KEY, class HASH, class EQUAL, class KEY>
  size_type erase(GET_KEY get_key, HASH hash, EQUAL eq, const KEY &key) {
    return erase_impl(get_key, hash, eq, key,
                      [&](iterator it, iterator it2) {
                        bucket_erase_impl(it, it2);
                      });
  }
  template <class NODE_HANDLE>
  NODE_HANDLE extract(const_iterator it) {
    unlink(it);
    return NODE_HANDLE(it.node(), alloc_ref());
  }
  template <class NODE_HANDLE,
            class GET_KEY, class HASH, class EQUAL, class KEY>
  NODE_HANDLE extract(GET_KEY get_key, HASH hash, EQUAL eq,
                      const KEY &key) {
    const iterator it = find(get_key, hash, eq, key);
    return it != end() ? extract<NODE_HANDLE>(it) : NODE_HANDLE{};
  }
  void clear() noexcept {
    for_each_node(*this, next, [&](auto it) {delete_node(it);});
    end().prev(placeholder_node());
    end().next(end());
    set_size(0);
    index_array_fill_zero();
  }

private:
  static iterator
  link_to_new_bucket(iterator index_it, iterator end_it,
                     iterator it) noexcept {
    const iterator prev = end_it;
    const iterator next = end_it.next();
    const iterator placeholder_it = next.prev();

    next.prev(index_it);
    index_it.next(it);
    it.next(next);

    it.prev(placeholder_it);
    prev.next(it);

    return it;
  }
  static iterator
  link_to_existed_bucket(iterator index_it,
                         iterator prev, iterator it) noexcept {
    const iterator next = prev.next();
    if (prev == index_it.next())
      index_it.next(it);
    else
      next.prev(it);
    prev.next(it);
    it.next(next);
    it.prev(prev);
    return it;
  }
  static iterator
  link_to_existed_bucket(iterator index_it, iterator it) noexcept {
    const iterator prev = index_it.next();
    const iterator next = prev.next();
    index_it.next(it);
    prev.next(it);
    it.prev(prev);
    it.next(next);
    return it;
  }

  // rehash_impl(..., n)
  // rehash_equal_impl(..., n)
  //   requires: n equal to one element of the prime_table
  template <class GET_KEY, class HASH, class EQUAL>
  void rehash_impl(GET_KEY get_key, HASH hash, EQUAL eq, size_type n) {
    index_array_alw().delete_array
      (exchange(index_array, new_index_array(n)));

    iterator it = begin();
    end().next(end());
    end().prev(placeholder_node());
#ifndef RE_NOEXCEPT
    try {
#endif
      while (it != end()) {
        const size_type k = hash(get_key(*it)) % size(index_array);
        const iterator index_it(pointer_to<void_pointer>(ref(index_array, k)));
        const auto next = it.next();
        index_it.next() == nullptr
          ? link_to_new_bucket(index_it, end(), it)
          : link_to_existed_bucket(index_it, it);
        it = next;
      }
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      set_size(distance(begin(), end()));
      for_each_node(rng(it, end()), next,
                    [&](auto it) {delete_node_if_storing_node_alloc(it);});
      throw;
    }
#endif
  }

public:
  template <class GET_KEY, class HASH, class EQUAL>
  void auto_rehash(GET_KEY get_key, HASH hash, EQUAL eq,
                   size_type current_size) {
    if (const size_type x
        = static_cast<size_type>(ceilf(current_size / factor()));
        current_size != 0 && bucket_count() < x) {
      auto it = partition_point(prime_table(), bind(less<size_type>{}, _1, x));
      if (it == end(prime_table()))
        --it;
      rehash_impl(get_key, hash, eq, *it);
    }
  }
  template <class GET_KEY, class HASH, class EQUAL>
  void auto_rehash(GET_KEY get_key, HASH hash, EQUAL eq) {
    auto_rehash(get_key, hash, eq, size());
  }

  template <class GET_KEY, class HASH, class EQUAL>
  void rehash(GET_KEY get_key, HASH hash, EQUAL eq, size_type n) {
    if (n == 0u && empty()) {
      index_array_alw().delete_array(index_array);
      index_array = {};
      return;
    }
    const float x = ceilf(size() / factor());
    auto it = partition_point(prime_table(), [=](auto count) {
      return !(count >= n && count >= x);
    });
    if (it == end(prime_table()))
      --it;
    rehash_impl(get_key, hash, eq, *it);
  }

  template <class GET_KEY, class HASH, class EQUAL>
  void reserve(GET_KEY get_key, HASH hash, EQUAL eq, size_type n) {
    rehash(get_key, hash, eq,
           static_cast<size_type>(ceilf(n / max_load_factor())));
  }

private:
  // insert(_equal)_impl(...) requires: bucket_count() != 0
  //   note: does not update size
  template <class GET_KEY, class HASH, class EQUAL, class KEY,
            class GET_NEW_NODE, class DO_WHEN_EQUAL>
  pair<iterator, bool>
  insert_impl(GET_KEY get_key, HASH hash, EQUAL eq, const KEY &key,
              GET_NEW_NODE get_new_node, DO_WHEN_EQUAL do_when_equal) {
    const size_type k = hash(key) % bucket_count();
    const iterator index_it(pointer_to<void_pointer>(ref(index_array, k)));
    if (index_it.next() == nullptr)
      return {link_to_new_bucket(index_it, end(), get_new_node()), true};
    else
      for (iterator pos = index_it.next();; pos = pos.prev()) {
        if (eq(get_key(*pos), key)) {
          do_when_equal(pos);
          return {pos, false};
        }
        if (pos.prev().next() != pos)
          return {link_to_existed_bucket(index_it, get_new_node()), true};
      }
  }
  template <class GET_KEY, class HASH, class EQUAL, class KEY,
            class GET_NEW_NODE>
  iterator insert_equal_impl(GET_KEY get_key, HASH hash, EQUAL eq,
                             const KEY &key, GET_NEW_NODE get_new_node) {
    const size_type k = hash(key) % bucket_count();
    const iterator index_it(pointer_to<void_pointer>(ref(index_array, k)));
    if (index_it.next() == nullptr)
      return link_to_new_bucket(index_it, end(), get_new_node());
    else
      for (iterator pos = index_it.next();; pos = pos.prev()) {
        if (eq(get_key(*pos), key))
          return link_to_existed_bucket(index_it, pos, get_new_node());
        if (pos.prev().next() != pos)
          return link_to_existed_bucket(index_it, get_new_node());
      }
  }
  template <class GET_KEY, class HASH, class EQUAL, class KEY,
            class GET_NEW_NODE>
  iterator insert_equal_impl(GET_KEY get_key, HASH hash, EQUAL eq,
                             iterator hint,
                             const KEY &key, GET_NEW_NODE get_new_node) {
    if (!empty()) {
      if (hint == end()) {
        if (eq(get_key(*prev(hint)), key))
          return link_to_existed_bucket(end().prev(), get_new_node());
      }
      else if (hint == begin()) {
        if (eq(key, get_key(*hint))) {
          const iterator it = get_new_node();
          it.prev(placeholder_node());
          end().next(it);
          it.next(hint);
          hint.prev(it);
          return it;
        }
      }
      else if (eq(key, get_key(*hint))) {
        const iterator it = get_new_node();

        const iterator p = hint.prev();
        if (p.next() == hint)
          p.next(it);
        else
          p.next().next(it);
        it.prev(p);

        it.next(hint);
        hint.prev(it);

        return it;
      }
      else if (eq(get_key(*--hint), key)) {
        const iterator it = get_new_node();

        const iterator p = hint.next();
        if (p.prev() == hint)
          p.prev(it);
        else
          p.prev().next(it);
        it.next(p);

        it.prev(hint);
        hint.next(it);

        return it;
      }
    }
    return insert_equal_impl(get_key, hash, eq, key, get_new_node);
  }

public:
  template <class GET_KEY, class HASH, class EQUAL, class KEY,
            class GET_NEW_NODE, class DO_WHEN_EQUAL>
  pair<iterator, bool>
  insert(GET_KEY get_key, HASH hash, EQUAL eq, const KEY &key,
         GET_NEW_NODE get_new_node, DO_WHEN_EQUAL do_when_equal) {
    auto_rehash(get_key, hash, eq, size() + 1u);
    return insert_impl(get_key, hash, eq, key,
                       [=, this]() {
                         iterator it = get_new_node();
                         set_size(size() + 1u);
                         return it;
                       },
                       do_when_equal);
  }
  template <class GET_KEY, class HASH, class EQUAL, class KEY,
            class GET_NEW_NODE>
  iterator insert_equal(GET_KEY get_key, HASH hash, EQUAL eq,
                        const KEY &key, GET_NEW_NODE get_new_node) {
    auto_rehash(get_key, hash, eq, size() + 1u);
    return insert_equal_impl(get_key, hash, eq, key,
                             [=, this]() {
                               const iterator it = get_new_node();
                               set_size(size() + 1u);
                               return it;
                             });
  }
  template <class GET_KEY, class HASH, class EQUAL, class KEY,
            class GET_NEW_NODE>
  iterator insert_equal(GET_KEY get_key, HASH hash, EQUAL eq, iterator hint,
                        const KEY &key, GET_NEW_NODE get_new_node) {
    auto_rehash(get_key, hash, eq, size() + 1u);
    return insert_equal_impl(get_key, hash, eq, hint, key,
                             [=, this]() {
                               const iterator it = get_new_node();
                               set_size(size() + 1u);
                               return it;
                             });
  }

  template <class GET_KEY, class HASH, class EQUAL>
  pair<iterator, bool> link(GET_KEY get_key, HASH hash, EQUAL eq,
                            iterator it) {
    auto_rehash(get_key, hash, eq, size() + 1u);
    return insert_impl(get_key, hash, eq, get_key(*it),
                       [=, this]() {set_size(size() + 1u); return it;},
                       empty_function{});
  }
  template <class GET_KEY, class HASH, class EQUAL, class...S>
  pair<iterator, bool> emplace(GET_KEY get_key, HASH hash, EQUAL eq,
                               S &&...s) {
    auto_rehash(get_key, hash, eq, size() + 1u);
    const iterator it = new_node(forward<S>(s)...);
#ifndef RE_NOEXCEPT
    try {
#endif
      return insert_impl(get_key, hash, eq, get_key(*it),
                         [=, this]() {set_size(size() + 1u); return it;},
                         [=, this](auto) {delete_node(it);});
#ifndef RE_NOEXCEPT
    }
    catch(...) {
      delete_node(it);
      throw;
    }
#endif
  }
  template <class GET_KEY, class HASH, class EQUAL>
  pair<iterator, bool> insert(GET_KEY get_key, HASH hash, EQUAL eq,
                              const value_type &x) {
    auto_rehash(get_key, hash, eq, size() + 1u);
    return insert_impl(get_key, hash, eq, get_key(x),
                       [&]() {set_size(size() + 1u); return new_node(x);},
                       empty_function{});
  }
  template <class GET_KEY, class HASH, class EQUAL>
  pair<iterator, bool> insert(GET_KEY get_key, HASH hash, EQUAL eq,
                              value_type &&x) {
    auto_rehash(get_key, hash, eq, size() + 1u);
    return insert_impl(get_key, hash, eq, get_key(x),
                       [&]() {set_size(size() + 1u); return new_node(move(x));},
                       empty_function{});
  }

  template <class GET_KEY, class HASH, class EQUAL, class KEY, class...S>
  pair<iterator, bool>
  try_emplace(GET_KEY get_key, HASH hash, EQUAL eq, KEY &&key, S &&...s) {
    auto_rehash(get_key, hash, eq, size() + 1u);
    return insert_impl(get_key, hash, eq, key,
                       [&]() {
                         const auto ret
                           = new_node(piecewise_construct,
                                      forward_as_tuple(forward<KEY>(key)),
                                      forward_as_tuple(forward<S>(s)...));
                         set_size(size() + 1u);
                         return ret;
                       },
                       empty_function{});
  }
  template <class GET_KEY, class GET_MAPPED, class HASH, class EQUAL,
            class KEY, class X>
  pair<iterator, bool>
  insert_or_assign(GET_KEY get_key, GET_MAPPED get_mapped, HASH hash, EQUAL eq,
                   KEY &&key, X &&x) {
    auto_rehash(get_key, hash, eq, size() + 1u);
    return insert_impl(get_key, hash, eq, key,
                       [&]() {
                         const auto ret
                           = new_node(forward<KEY>(key), forward<X>(x));
                         set_size(size() + 1u);
                         return ret;
                       },
                       [&](iterator it) {get_mapped(*it) = forward<X>(x);});
  }
  template <class ITERATOR, class GET_KEY, class HASH, class EQUAL,
            class NODE_HANDLE>
  inner::node_handle_insert_return_type
  <ITERATOR, remove_reference_t<NODE_HANDLE>>
  insert_node_handle(GET_KEY get_key, HASH hash, EQUAL eq,
                     NODE_HANDLE &&nh) {
    inner::node_handle_insert_return_type
      <ITERATOR, remove_reference_t<NODE_HANDLE>> ret;
    if (nh.empty()) {
      ret.position = end();
      ret.inserted = false;
    }
    else {
      auto_rehash(get_key, hash, eq, size() + 1u);
      tie(ret.position, ret.inserted)
        = insert_impl(get_key, hash, eq, get_key(*ITERATOR(nh.get())),
                      [&]() {
                        set_size(size() + 1u);
                        return iterator(nh.release());
                      },
                      empty_function{});
      ret.node = move(nh);
    }
    return ret;
  }

  template <class GET_KEY, class HASH, class EQUAL>
  iterator link_equal(GET_KEY get_key, HASH hash, EQUAL eq, iterator it) {
    auto_rehash(get_key, hash, eq, size() + 1u);
    return insert_equal_impl(get_key, hash, eq, get_key(*it),
                             [=, this]() {set_size(size() + 1u); return it;});
  }
  template <class GET_KEY, class HASH, class EQUAL, class...S>
  iterator emplace_equal(GET_KEY get_key, HASH hash, EQUAL eq, S &&...s) {
    auto_rehash(get_key, hash, eq, size() + 1u);
    const iterator it = new_node(forward<S>(s)...);
#ifndef RE_NOEXCEPT
    try {
#endif
      return insert_equal_impl(get_key, hash, eq, get_key(*it),
                               [=, this]() {set_size(size() + 1u); return it;});
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      delete_node(it);
      throw;
    }
#endif
  }
  template <class GET_KEY, class HASH, class EQUAL, class...S>
  iterator insert_equal(GET_KEY get_key, HASH hash, EQUAL eq,
                        const value_type &x) {
    return emplace_equal(get_key, hash, eq, x);
  }
  template <class GET_KEY, class HASH, class EQUAL, class...S>
  iterator insert_equal(GET_KEY get_key, HASH hash, EQUAL eq,
                        value_type &&x) {
    return emplace_equal(get_key, hash, eq, move(x));
  }
  template <class GET_KEY, class HASH, class EQUAL, class NODE_HANDLE>
  iterator insert_node_handle_equal(GET_KEY get_key, HASH hash, EQUAL eq,
                                    NODE_HANDLE &&nh) {
    if (nh.empty())
      return end();
    auto_rehash(get_key, hash, eq, size() + 1u);
    return insert_equal_impl(get_key, hash, eq, get_key(*iterator(nh.get())),
                             [&]() {
                               set_size(size() + 1u);
                               return iterator(nh.release());
                             });
  }

  template <class GET_KEY, class HASH, class EQUAL>
  iterator link_equal(GET_KEY get_key, HASH hash, EQUAL eq,
                      iterator hint, iterator it) {
    auto_rehash(get_key, hash, eq, size() + 1u);
    return insert_equal_impl(get_key, hash, eq, hint, get_key(*it),
                             [=, this]() {set_size(size() + 1u); return it;});
  }
  template <class GET_KEY, class HASH, class EQUAL, class...S>
  iterator emplace_equal_hint(GET_KEY get_key, HASH hash, EQUAL eq,
                              iterator hint, S &&...s) {
    auto_rehash(get_key, hash, eq, size() + 1u);
    const iterator it = new_node(forward<S>(s)...);
#ifndef RE_NOEXCEPT
    try {
#endif
      return insert_equal_impl(get_key, hash, eq, hint, get_key(*it),
                               [=, this]() {set_size(size() + 1u); return it;});
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      delete_node(it);
      throw;
    }
#endif
  }
  template <class GET_KEY, class HASH, class EQUAL, class...S>
  iterator insert_equal(GET_KEY get_key, HASH hash, EQUAL eq,
                        iterator hint, const value_type &x) {
    return emplace_equal_hint(get_key, hash, eq, hint, x);
  }
  template <class GET_KEY, class HASH, class EQUAL, class...S>
  iterator insert_equal(GET_KEY get_key, HASH hash, EQUAL eq,
                        iterator hint, value_type &&x) {
    return emplace_equal_hint(get_key, hash, eq, hint, move(x));
  }
  template <class GET_KEY, class HASH, class EQUAL, class NODE_HANDLE>
  iterator insert_node_handle_equal(GET_KEY get_key, HASH hash, EQUAL eq,
                                    iterator hint, NODE_HANDLE &&nh) {
    if (nh.empty())
      return end();
    auto_rehash(get_key, hash, eq, size() + 1u);
    return insert_equal_impl
      (get_key, hash, eq, hint, get_key(*iterator(nh.get())),
       [&]() {set_size(size() + 1u); return iterator(nh.release());});
  }

  template <class GET_KEY, class HASH, class EQUAL, class ANALOGOUS>
  void merge(GET_KEY get_key, HASH hash, EQUAL eq, ANALOGOUS &&other) {
    if (this != addressof(other)) {
      const auto n = other.size();
      auto_rehash(get_key, hash, eq,
                  (n > integral_traits<size_type>::max() - size()
                   ? integral_traits<size_type>::max()
                   : size() + n));
      for_each_node(other, next, [&](auto it) {
        insert_impl(get_key, hash, eq, get_key(*it),
                    [&]() {set_size(size() + 1u); other.unlink(it); return it;},
                    empty_function{});
      });
    }
  }

  template <class GET_KEY, class HASH, class EQUAL, class ANALOGOUS>
  void merge_equal(GET_KEY get_key, HASH hash, EQUAL eq,
                   ANALOGOUS &&other) {
    if (this != addressof(other)) {
      const auto n = other.size();
      if (n > integral_traits<size_type>::max() - size())
        throw_or_terminate<length_error>
          ("re::hashtable_adaptor: size overflow in merge_equal()\n");
      auto_rehash(get_key, hash, eq, size() + n);
      for_each_node(other, next, [&](auto it) {
        insert_equal_impl(get_key, hash, eq, get_key(*it), [&]() {
          set_size(size() + 1u);
          other.unlink(it);
          return it;
        });
      });
    }
  }

  template <class GET_KEY, class HASH, class EQUAL, class R,
            class INSERT>
  enable_if_t<rng_is_sized<R>>
  insert_range(GET_KEY get_key, HASH hash, EQUAL eq, R &&r, INSERT ins) {
    const auto n = size(r);
    auto_rehash(get_key, hash, eq,
                (n > integral_traits<size_type>::max() - size()
                 ? integral_traits<size_type>::max()
                 : size() + n));
    for (auto &i : iters(r))
      ins(*i);
  }
  template <class GET_KEY, class HASH, class EQUAL, class R, class INSERT>
  enable_if_t<!rng_is_sized<R>>
  insert_range(GET_KEY get_key, HASH hash, EQUAL eq, R &&r, INSERT ins) {
    for (auto &i : iters(r)) {
      auto_rehash(get_key, hash, eq, size() + 1u);
      ins(*i);
    }
  }

  template <class GET_KEY, class HASH, class EQUAL, class R>
  void insert_range_transparent(GET_KEY get_key, HASH hash, EQUAL eq,
                                R &&r) {
    insert_range(get_key, hash, eq, r, [=, this]<class T>(T &&x) {
      insert_impl(get_key, hash, eq, forward<T>(x),
                  [&x, this]() {
                    const iterator it = new_node(forward<T>(x));
                    set_size(size() + 1u);
                    return it;
                  },
                  empty_function{});
    });
  }
  template <class GET_KEY, class HASH, class EQUAL, class R>
  void insert_range(GET_KEY get_key, HASH hash, EQUAL eq, R &&r) {
    insert_range(get_key, hash, eq, r, [=, this]<class T>(T &&x) {
      const auto it = new_node(forward<T>(x));
#ifndef RE_NOEXCEPT
      try {
#endif
        insert_impl(get_key, hash, eq, get_key(*it),
                    [=, this]() {set_size(size() + 1u); return it;},
                    [=, this](...) {delete_node(it);});
#ifndef RE_NOEXCEPT
      }
      catch (...) {
        delete_node(it);
        throw;
      }
#endif
    });
  }

  template <class GET_KEY, class HASH, class EQUAL, class R, class INSERT>
  enable_if_t<rng_is_sized<R>>
  assign_range(GET_KEY get_key, HASH hash, EQUAL eq, R &&r, INSERT ins) {
    iterator it = begin();
    end().next(end());
    end().prev(placeholder_node());
    const auto guard = exit_fn([&]() {
      for_each_node(rng(it, end()), next, [this](auto it) {delete_node(it);});
    });
    set_size(0);
    index_array_fill_zero();

    auto_rehash(get_key, hash, eq,
                min_value(integral_traits<size_type>::max(), size(r)));

    for (auto &i : iters(r)) {
      if (it == end()) {
        for (auto &j : iters(i, end(r)))
          ins(*j);
        return;
      }
      *it = *i;
      insert_impl(get_key, hash, eq, get_key(*it),
                  [&]() {
                    set_size(size() + 1u);
                    return exchange(it, it.next());
                  },
                  empty_function{});
    }
  }
  template <class GET_KEY, class HASH, class EQUAL, class R, class INSERT>
  enable_if_t<!rng_is_sized<R>>
  assign_range(GET_KEY get_key, HASH hash, EQUAL eq, R &&r, INSERT ins) {
    iterator it = begin();
    end().next(end());
    end().prev(placeholder_node());
    const auto guard = exit_fn([&]() {
      for_each_node(rng(it, end()), next, [this](auto it) {delete_node(it);});
    });
    set_size(0);
    index_array_fill_zero();

    for (auto &i : iters(r)) {
      if (it == end()) {
        for (auto &j : iters(i, end(r))) {
          auto_rehash(get_key, hash, eq, size() + 1u);
          ins(*j);
        }
        return;
      }
      *it = *i;
      auto_rehash(get_key, hash, eq, size() + 1u);
      insert_impl(get_key, hash, eq, get_key(*it),
                  [&]() {
                    set_size(size() + 1u);
                    return exchange(it, it.next());
                  },
                  empty_function{});
    }
  }

  template <class GET_KEY, class HASH, class EQUAL, class R>
  void assign_range_transparent(GET_KEY get_key, HASH hash, EQUAL eq,
                                R &&r) {
    assign_range(get_key, hash, eq, r, [=, this]<class T>(T &&x) {
      insert_impl(get_key, hash, eq, forward<T>(x),
                  [&x, this]() {
                    const iterator it = new_node(forward<T>(x));
                    set_size(size() + 1u);
                    return it;
                  },
                  empty_function{});
    });
  }
  template <class GET_KEY, class HASH, class EQUAL, class R>
  void assign_range(GET_KEY get_key, HASH hash, EQUAL eq, R &&r) {
    assign_range(get_key, hash, eq, r, [=, this]<class T>(T &&x) {
      const auto it = new_node(forward<T>(x));
#ifndef RE_NOEXCEPT
      try {
#endif
        insert_impl(get_key, hash, eq, get_key(*it),
                    [=, this]() {set_size(size() + 1u); return it;},
                    [=, this](...) {delete_node(it);});
#ifndef RE_NOEXCEPT
      }
      catch (...) {
        delete_node(it);
        throw;
      }
#endif
    });
  }

  template <class GET_KEY, class HASH, class EQUAL, class R>
  enable_if_t<rng_is_sized<R>>
  insert_range_equal(GET_KEY get_key, HASH hash, EQUAL eq, R &&r) {
    const auto n = size(r);
    if (n > integral_traits<size_type>::max() - size())
      throw_or_terminate<length_error>
        ("re::hashtable_adaptor: size overflow in insert_range_equal()\n");
    auto_rehash(get_key, hash, eq, n + size());
    set_size(n + size());

    for (auto &i : iters(r)) {
      const iterator it = new_node(*i);
#ifndef RE_NOEXCEPT
      try {
#endif
        insert_equal_impl(get_key, hash, eq, get_key(*it), bind(copy, it));
#ifndef RE_NOEXCEPT
      }
      catch (...) {
        delete_node(it);
        set_size(distance(begin(), end()));
        throw;
      }
#endif
    }
  }
  template <class GET_KEY, class HASH, class EQUAL, class R>
  enable_if_t<!rng_is_sized<R>>
  insert_range_equal(GET_KEY get_key, HASH hash, EQUAL eq, R &&r) {
    for (auto &it : iters(r))
      emplace_equal(get_key, hash, eq, *it);
  }

  template <class GET_KEY, class HASH, class EQUAL, class R>
  enable_if_t<rng_is_sized<R>>
  assign_range_equal(GET_KEY get_key, HASH hash, EQUAL eq, R &&r) {
    iterator it = begin();
    end().next(end());
    end().prev(placeholder_node());
    const auto guard = exit_fn([&]() {
      for_each_node(rng(it, end()), next, [this](auto i) {delete_node(i);});
    });
    set_size(0);
    index_array_fill_zero();

    const auto n = size(r);
    if (n > integral_traits<size_type>::max())
      throw_or_terminate<length_error>
        ("re::hashtable_adaptor: size overflow in assign_range_equal()\n");
    auto_rehash(get_key, hash, eq, n);
    set_size(n);

    for (auto &i : iters(r)) {
      if (it == end()) {
        for (auto &j : iters(i, end(r))) {
          const iterator x = new_node(*j);
#ifndef RE_NOEXCEPT
          try {
#endif
            insert_equal_impl(get_key, hash, eq, get_key(*x), bind(copy, x));
#ifndef RE_NOEXCEPT
          }
          catch(...) {
            delete_node(x);
            throw;
          }
#endif
        }
        return;
      }
      *it = *i;
      insert_equal_impl(get_key, hash, eq, get_key(*it),
                        bind(exchange, ref(it), it.next()));
    }
  }
  template <class GET_KEY, class HASH, class EQUAL, class R>
  enable_if_t<!rng_is_sized<R>>
  assign_range_equal(GET_KEY get_key, HASH hash, EQUAL eq, R &&r) {
    iterator it = begin();
    end().next(end());
    end().prev(placeholder_node());
    const auto guard = exit_fn([&]() {
      for_each_node(rng(it, end()), next, [this](auto it) {delete_node(it);});
    });
    set_size(0);
    index_array_fill_zero();

    for (auto &i : iters(r)) {
      if (it == end()) {
        for (auto &j : iters(i, end(r)))
          emplace_equal(get_key, hash, eq, *j);
        return;
      }
      *it = *i;
      const auto tmp = it.next();
      link_equal(get_key, hash, eq, it);
      it = tmp;
    }
  }

  template <class GET_KEY, class HASH, class EQUAL>
  bool equal(GET_KEY get_key, HASH hash, EQUAL eq,
             HASH hash2, EQUAL eq2, const this_t &x) const {
    if (size(*this) != size(x))
      return false;
    for (auto &it : iters(*this)) {
      auto it2 = x.find(get_key, hash2, eq2, get_key(*it));
      if (it2 == x.end())
        return false;
      if (!(*it == *it2))
        return false;
    }
    return true;
  }
  template <class GET_KEY, class HASH, class EQUAL>
  bool equal_equal(GET_KEY get_key, HASH hash, EQUAL eq,
                   HASH hash2, EQUAL eq2, const this_t &x) const {
    if (size(*this) != size(x))
      return false;
    const_iterator it = begin();
    for (;;) {
      if (it == end())
        return true;
      const const_iterator it2
        = re::find(rng(next(it), end()), ref(get_key(*it)),
                   not_fn(bind(eq, bind(get_key, _1), _2)));

      if (!is_permutation(rng(it, it2),
                          x.equal_range(get_key, hash2, eq2, get_key(*it))))
        return false;

      it = it2;
    }
  }

  static constexpr size_type default_bucket_count = 20;
};

}
// unordered_(set/map/multiset/multimap)_adaptor
namespace re {

template <class TABLE, class HASH, class EQ>
class unordered_set_adaptor;
template <class TABLE, class HASH, class EQ>
class unordered_multiset_adaptor;
template <class TABLE, class HASH, class EQ>
class unordered_map_adaptor;
template <class TABLE, class HASH, class EQ>
class unordered_multimap_adaptor;

template <class TABLE, class HASH, class EQ>
class unordered_set_adaptor
  : TABLE, derivable_wrapper<HASH>, derivable_wrapper<EQ> {
  using this_t = unordered_set_adaptor;

  using base_t = TABLE;
  const base_t &base() const noexcept {
    return *this;
  }
  base_t &base() noexcept {
    return *this;
  }

  static constexpr bool transparent
    = is_transparent_function_v<HASH> && is_transparent_function_v<EQ>;

public:
  using traits = typename base_t::traits;
  using node_pointer = typename traits::node_base_pointer;

private:
  using hash_wrapper = derivable_wrapper<HASH>;
  using eq_wrapper = derivable_wrapper<EQ>;
  HASH &hash_ref() {
    return *static_cast<hash_wrapper &>(*this);
  }
  const HASH &hash_ref() const {
    return *static_cast<const hash_wrapper &>(*this);
  }
  EQ &eq_ref() {
    return *static_cast<eq_wrapper &>(*this);
  }
  const EQ &eq_ref() const {
    return *static_cast<const eq_wrapper &>(*this);
  }

protected:
  static auto get_key() noexcept {
    return [](const auto &x)->const auto & {
      return traits::key(x);
    };
  }
  auto hash() const noexcept {
    return ref(hash_ref());
  }
  auto eq() const noexcept {
    return ref(eq_ref());
  }

  using alloc_t = typename base_t::allocator_type;

public:
  using pointer = alloc_ptr<alloc_t>;
  using const_pointer = alloc_cptr<alloc_t>;

  // container 

  using value_type = typename base_t::value_type;
  using reference = typename base_t::reference;
  using const_reference = typename base_t::const_reference;

  using iterator = typename base_t::iterator;
  using const_iterator = typename base_t::const_iterator;
  using difference_type = typename base_t::difference_type;
  using size_type = typename base_t::size_type;

  iterator begin() noexcept {
    return base_t::begin();
  }
  iterator end() noexcept {
    return base_t::end();
  }
  const_iterator begin() const noexcept {
    return base_t::begin();
  }
  const_iterator end() const noexcept {
    return base_t::end();
  }
  const_iterator cbegin() const noexcept {
    return base_t::cbegin();
  }
  const_iterator cend() const noexcept {
    return base_t::cend();
  }

  size_type max_size() const noexcept {
    return base_t::max_size();
  }
  size_type size() const noexcept {
    return base_t::size();
  }
  bool empty() const noexcept {
    return base_t::empty();
  }

  unordered_set_adaptor() = default;
  ~unordered_set_adaptor() = default;
  unordered_set_adaptor(const unordered_set_adaptor &) = default;
  unordered_set_adaptor &operator =(const unordered_set_adaptor &) = default;
  unordered_set_adaptor(unordered_set_adaptor &&) = default;
  unordered_set_adaptor &operator =(unordered_set_adaptor &&) = default;
  friend void swap(unordered_set_adaptor &x, unordered_set_adaptor &y)
    noexcept(is_nothrow_swappable_v<base_t>
             && is_nothrow_swappable_v<HASH>
             && is_nothrow_swappable_v<EQ>) {
    adl_swap(x.base(), y.base());
    adl_swap(x.hash_ref(), y.hash_ref());
    adl_swap(x.eq_ref(), y.eq_ref());
  }

  template <class TABLE2, class HASH2, class EQ2>
  friend bool operator ==(const unordered_set_adaptor<TABLE2, HASH2, EQ2> &,
                          const unordered_set_adaptor<TABLE2, HASH2, EQ2> &);

  // reversible container

  using reverse_iterator = re::reverse_iterator<iterator>;
  using const_reverse_iterator = re::reverse_iterator<const_iterator>;

  reverse_iterator rbegin() noexcept {
    return reverse_iterator(end());
  }
  reverse_iterator rend() noexcept {
    return reverse_iterator(begin());
  }
  const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator(begin());
  }
  const_reverse_iterator crbegin() const noexcept {
    return rbegin();
  }
  const_reverse_iterator crend() const noexcept {
    return rend();
  }

  // allocator-aware container

  using allocator_type = alloc_t;
  allocator_type get_allocator() const noexcept {
    return base_t::get_allocator();
  }

  explicit unordered_set_adaptor(const alloc_t &al) noexcept : base_t(al) {}
  unordered_set_adaptor(const this_t &x, const alloc_t &al)
    : base_t(x.base(), al)
    , hash_wrapper(x.hash_ref())
    , eq_wrapper(x.eq_ref()) {}
  unordered_set_adaptor(this_t &&x, const alloc_t &al)
    : base_t(move(x.base()), al)
    , hash_wrapper(move(x.hash_ref()))
    , eq_wrapper(move(x.eq_ref())) {}

  // unordered associative container

  using key_type = typename traits::key_type;
  using hasher = HASH;
  using key_equal = EQ;
  using node_type = inner::set_node_handle<traits>;
  using insert_return_type
    = inner::node_handle_insert_return_type<iterator, node_type>;

  hasher hash_function() const {
    return hash_ref();
  }
  key_equal key_eq() const {
    return eq_ref();
  }

  unordered_set_adaptor(const hasher &hf, const key_equal &eql,
                        const alloc_t &al = alloc_t{})
    : base_t(al), hash_wrapper(hf), eq_wrapper(eql) {}
  explicit unordered_set_adaptor(size_type n,
                                 const hasher &hf = hasher{},
                                 const key_equal &eql = key_equal{},
                                 const alloc_t &al = alloc_t{})
    : base_t(al), hash_wrapper(hf), eq_wrapper(eql) {
    base_t::reserve(get_key(), hash(), eq(), n);
  }
  unordered_set_adaptor(size_type n, const alloc_t &al)
    : unordered_set_adaptor(n, hasher{}, key_equal{}, al) {}
  unordered_set_adaptor(size_type n, const hasher &hf, const alloc_t &al)
    : unordered_set_adaptor(n, hf, key_equal{}, al) {}

  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  unordered_set_adaptor(IITR f, IITR l,
                        size_type n = base_t::default_bucket_count,
                        const hasher &hf = hasher{},
                        const key_equal &eql = key_equal{},
                        const alloc_t &al = alloc_t{})
    : base_t(al), hash_wrapper(hf), eq_wrapper(eql) {
    base_t::reserve(get_key(), hash(), eq(), n);
    insert_range(rng(f, l));
  }
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  unordered_set_adaptor(IITR f, IITR l, const alloc_t &al)
    : unordered_set_adaptor(f, l, base_t::default_bucket_count,
                            HASH{}, EQ{}, al) {}
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  unordered_set_adaptor(IITR f, IITR l, size_type n, const alloc_t &al)
    : unordered_set_adaptor(f, l, n, HASH{}, EQ{}, al) {}
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  unordered_set_adaptor(IITR f, IITR l,
                        size_type n, const hasher &hf, const alloc_t &al)
    : unordered_set_adaptor(f, l, n, hf, EQ{}, al) {}
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  void assign(IITR f, IITR l) {
    assign_range(rng(f, l));
  }

  unordered_set_adaptor(initializer_list<value_type> il,
                        size_type n = base_t::default_bucket_count,
                        const hasher &hf = hasher{},
                        const key_equal &eql = key_equal{},
                        const alloc_t &al = alloc_t{})
    : base_t(al), hash_wrapper(hf), eq_wrapper(eql) {
    base_t::reserve(get_key(), hash(), eq(), n);
    insert_range(il);
  }
  unordered_set_adaptor(initializer_list<value_type> il, const alloc_t &al)
    : unordered_set_adaptor(il, base_t::default_bucket_count,
                            hasher{}, key_equal{}, al) {}
  unordered_set_adaptor(initializer_list<value_type> il,
                        size_type n, const alloc_t &al)
    : unordered_set_adaptor(il, n, hasher{}, key_equal{}, al) {}
  unordered_set_adaptor(initializer_list<value_type> il,
                        size_type n, const hasher &hf, const alloc_t &al)
    : unordered_set_adaptor(il, n, hf, key_equal{}, al) {}
  unordered_set_adaptor &operator =(initializer_list<value_type> il) {
    assign_range(il);
    return *this;
  }
  void assign(initializer_list<value_type> il) {
    assign_range(il);
  }

  template <class...S>
  pair<iterator, bool> emplace(S &&...s) {
    return base_t::emplace(get_key(), hash(), eq(), forward<S>(s)...);
  }
  template <class...S>
  iterator emplace_hint(const_iterator hint, S &&...s) {
    return base_t::emplace(get_key(), hash(), eq(), forward<S>(s)...).first;
  }
  pair<iterator, bool> insert(const value_type &x) {
    return base_t::insert(get_key(), hash(), eq(), x);
  }
  pair<iterator, bool> insert(value_type &&x) {
    return base_t::insert(get_key(), hash(), eq(), move(x));
  }
  template <class K>
  pair<iterator, bool> insert(K &&key)
    requires (transparent && is_constructible_v<value_type, K &&>) {
    return base_t::insert(get_key(), hash(), eq(), key,
                          [&]() {return new_node(forward<K>(key));},
                          empty_function{});
  }
  iterator insert(const_iterator hint, const value_type &x) {
    return base_t::insert(get_key(), hash(), eq(), x).first;
  }
  iterator insert(const_iterator hint, value_type &&x) {
    return base_t::insert(get_key(), hash(), eq(), move(x)).first;
  }
  template <class K>
  iterator insert(const_iterator hint, K &&key)
    requires (transparent && is_constructible_v<value_type, K &&>) {
    return insert(forward<K>(key)).first;
  }
  template <class IITR>
  void insert(IITR from, IITR to) {
    insert_range(rng(from, to));
  }
  void insert(initializer_list<value_type> il) {
    insert_range(il);
  }

  node_type extract(const_iterator pos) {
    return base_t::template extract<node_type>(pos.to_mutable());
  }
  node_type extract(const key_type &key) {
    return base_t::template extract<node_type>(get_key(), hash(), eq(), key);
  }
  template <class K>
  node_type extract(K &&key)
    requires (transparent
              && !is_convertible_v<K &&, iterator>
              && !is_convertible_v<K &&, const_iterator>) {
    return base_t::template extract<node_type>(get_key(), hash(), eq(), key);
  }
  insert_return_type insert(node_type &&nh) {
    return base_t::template insert_node_handle<iterator>
      (get_key(), hash(), eq(), move(nh));
  }
  iterator insert(const_iterator hint, node_type &&nh) {
    auto x = base_t::template insert_node_handle<iterator>
      (get_key(), hash(), eq(), move(nh));
    nh = move(x.node);
    return x.position;
  }

  iterator erase(const_iterator pos) {
    return base_t::erase(pos.to_mutable());
  }
  iterator erase(const_iterator from, const_iterator to) {
    while (from != to)
      from = erase(from);
    return from.to_mutable();
  }
  void clear() noexcept {
    base_t::clear();
  }

  size_type erase(const key_type &key) {
    const auto it = base_t::find(get_key(), hash(), eq(), key);
    if (it == end())
      return 0;
    erase(it);
    return 1;
  }
  template <class K>
  size_type erase(K &&key)
    requires (transparent
              && !is_convertible_v<K &&, iterator>
              && !is_convertible_v<K &&, const_iterator>) {
    const auto it = base_t::find(get_key(), hash(), eq(), key);
    if (it == end())
      return 0;
    erase(it);
    return 1;
  }

  size_type remove(const key_type &key) {
    const auto it = base_t::find(get_key(), hash(), eq(), key);
    if (it == end())
      return 0;
    erase_or_unlink(it);
    return 1;
  }
  template <class K>
  size_type remove(const K &key) requires transparent {
    const auto it = base_t::find(get_key(), hash(), eq(), key);
    if (it == end())
      return 0;
    erase_or_unlink(it);
    return 1;
  }
  template <class UF>
  size_type remove_if(UF eq) {
    size_type ret = 0;
    for (iterator it = begin(); it != end();) {
      if (eq(*it)) {
        it = erase_or_unlink(it);
        ++ret;
      }
      else
        ++it;
    }
    return ret;
  }

  template <class HASH2, class EQ2>
  void merge(unordered_set_adaptor<base_t, HASH2, EQ2> &x) {
    base_t::merge(get_key(), hash(), eq(), x.base());
  }
  template <class HASH2, class EQ2>
  void merge(unordered_set_adaptor<base_t, HASH2, EQ2> &&x) {
    base_t::merge(get_key(), hash(), eq(), x.base());
  }
  template <class HASH2, class EQ2>
  void merge(unordered_multiset_adaptor<base_t, HASH2, EQ2> &x) {
    base_t::merge(get_key(), hash(), eq(), x.base());
  }
  template <class HASH2, class EQ2>
  void merge(unordered_multiset_adaptor<base_t, HASH2, EQ2> &&x) {
    base_t::merge(get_key(), hash(), eq(), x.base());
  }

  iterator find(const key_type &key) {
    return base_t::find(get_key(), hash(), eq(), key);
  }
  template <class K>
  iterator find(const K &key) requires transparent {
    return base_t::find(get_key(), hash(), eq(), key);
  }
  const_iterator find(const key_type &key) const {
    return base_t::find(get_key(), hash(), eq(), key);
  }
  template <class K>
  const_iterator find(const K &key) const requires transparent {
    return base_t::find(get_key(), hash(), eq(), key);
  }

  bool contains(const key_type &key) const {
    return find(key) != end();
  }
  template <class K>
  bool contains(const K &key) const requires transparent {
    return find(key) != end();
  }

  size_type count(const key_type &key) const {
    return find(key) != end() ? 1 : 0;
  }
  template <class K>
  size_type count(const K &key) const requires transparent {
    return find(key) != end() ? 1 : 0;
  }

  iter_pair<iterator> equal_range(const key_type &key) {
    const iterator it = base_t::find(get_key(), hash(), eq(), key);
    return {it, it == end() ? end() : next(it)};
  }
  template <class K>
  iter_pair<iterator> equal_range(const K &key) requires transparent {
    const iterator it = base_t::find(get_key(), hash(), eq(), key);
    return {it, it == end() ? end() : next(it)};
  }
  iter_pair<const_iterator> equal_range(const key_type &key) const {
    const const_iterator it = base_t::find(get_key(), hash(), eq(), key);
    return {it, it == end() ? end() : next(it)};
  }
  template <class K>
  iter_pair<const_iterator> equal_range(const K &key) const
    requires transparent {
    const const_iterator it = base_t::find(get_key(), hash(), eq(), key);
    return {it, it == end() ? end() : next(it)};
  }

  size_type bucket_count() const noexcept {
    return base_t::bucket_count();
  }
  size_type active_bucket_count() const noexcept {
    return base_t::active_bucket_count();
  }
  size_type max_bucket_count() const noexcept {
    return base_t::max_bucket_count();
  }
  size_type bucket_size(size_type n) const {
    return base_t::bucket_size(n);
  }
  size_type bucket(const key_type &k) const {
    return base_t::bucket(hash(), k);
  }

  using local_iterator = typename base_t::local_iterator;
  using const_local_iterator = typename base_t::const_local_iterator;

  local_iterator begin(size_type n) noexcept {
    return base_t::begin(n);
  }
  local_iterator end(size_type n) noexcept {
    return base_t::end(n);
  }
  const_local_iterator begin(size_type n) const noexcept {
    return base_t::begin(n);
  }
  const_local_iterator end(size_type n) const noexcept {
    return base_t::end(n);
  }
  const_local_iterator cbegin(size_type n) const noexcept {
    return begin(n);
  }
  const_local_iterator cend(size_type n) const noexcept {
    return end(n);
  }

  iter_pair<local_iterator> bucket_range(size_type n) {
    return base_t::bucket_range(n);
  }
  iter_pair<const_local_iterator> bucket_range(size_type n) const {
    return base_t::bucket_range(n);
  }

  float load_factor() const noexcept {
    return base_t::load_factor();
  }
  float max_load_factor() const noexcept {
    return base_t::max_load_factor();
  }
  void max_load_factor(float f) {
    base_t::max_load_factor(f);
  }
  void rehash(size_type n) {
    base_t::rehash(get_key(), hash(), eq(), n);
  }
  void reserve(size_type n) {
    base_t::reserve(get_key(), hash(), eq(), n);
  }

  // extensions

  template <class...S>
  iterator new_node(S &&...s) {
    return base_t::new_node(forward<S>(s)...);
  }
  void delete_node(const_iterator it) noexcept {
    base_t::delete_node(it.to_mutable());
  }

  iterator unlink(const_iterator it) noexcept {
    return base_t::unlink(it.to_mutable());
  }
  iterator unlink(const_iterator from, const_iterator to) noexcept {
    return base_t::unlink(from.to_mutable(), to.to_mutable());
  }
  void unlink() noexcept {
    base_t::unlink();
  }
  size_type unlink_key(const key_type &key) {
    const auto it = base_t::find(get_key(), hash(), eq(), key);
    if (it == end())
      return 0;
    unlink(it);
    return 1;
  }
  template <class K>
  size_type unlink_key(const K &key) requires transparent {
    const auto it = base_t::find(get_key(), hash(), eq(), key);
    if (it == end())
      return 0;
    unlink(it);
    return 1;
  }
  pair<iterator, bool> link(const_iterator it) {
    return base_t::link(get_key(), hash(), eq(), it.to_mutable());
  }
  iterator link(const_iterator hint, const_iterator it) {
    return base_t::link(get_key(), hash(), eq(), it.to_mutable()).first;
  }

  template <class K, class GET_NODE, class DO_WHEN_EQ = empty_function>
  pair<iterator, bool> try_link(const K &key, GET_NODE get_node,
                                DO_WHEN_EQ do_when_eq = DO_WHEN_EQ{}) {
    return base_t::insert(get_key(), hash(), eq(), key, get_node, do_when_eq);
  }
  template <class K, class GET_NODE, class DO_WHEN_EQ = empty_function>
  iterator try_link_hint(const_iterator hint, const K &key, GET_NODE get_node,
                         DO_WHEN_EQ do_when_eq = DO_WHEN_EQ{}) {
    return try_link(key, get_node, do_when_eq).first;
  }

  template <bool Y = traits::store_node_allocator::value>
  enable_if_t<Y, iterator> erase_or_unlink(const_iterator it) noexcept {
    return erase(it);
  }
  template <bool Y = traits::store_node_allocator::value>
  enable_if_t<!Y, iterator> erase_or_unlink(const_iterator it) noexcept {
    return unlink(it);
  }

  void unique() {}
  template <class EQL>
  void unique(EQL eql) {
    list_unique(*this, eql, [=, this](auto it) {return erase_or_unlink(it);});
  };

  template <class IITR_RANGE>
  unordered_set_adaptor(from_range_t, IITR_RANGE &&r,
                        size_type n = base_t::default_bucket_count,
                        const hasher &hf = hasher{},
                        const key_equal &eql = key_equal{},
                        const alloc_t &al = alloc_t{})
    : base_t(al), hash_wrapper(hf), eq_wrapper(eql) {
    base_t::reserve(get_key(), hash(), eq(), n);
    insert_range(r);
  }
  template <class IITR_RANGE>
  unordered_set_adaptor(from_range_t, IITR_RANGE &&r, const alloc_t &al)
    : unordered_set_adaptor(from_range, r, base_t::default_bucket_count,
                            HASH{}, EQ{}, al) {}
  template <class IITR_RANGE>
  unordered_set_adaptor(from_range_t, IITR_RANGE &&r, size_type n,
                        const alloc_t &al)
    : unordered_set_adaptor(from_range, r, n, HASH{}, EQ{}, al) {}
  template <class IITR_RANGE>
  unordered_set_adaptor(from_range_t, IITR_RANGE &&r,
                        size_type n, const hasher &hf, const alloc_t &al)
    : unordered_set_adaptor(from_range, r, n, hf, EQ{}, al) {}
  template <class IITR_RANGE, class = enable_if_t
            <is_rng<IITR_RANGE>
             && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
             && !is_same_v<decay_t<IITR_RANGE>, this_t>
             && !is_convertible_v<IITR_RANGE &&, const alloc_t &>>>
  explicit unordered_set_adaptor(IITR_RANGE &&r) {
    base_t::reserve(get_key(), hash(), eq(), base_t::default_bucket_count);
    insert_range(r);
  }
  template <class IITR_RANGE, class = enable_if_t
            <is_rng<IITR_RANGE>
             && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
             && !is_same_v<decay_t<IITR_RANGE>, this_t>
             && !is_convertible_v<IITR_RANGE &&, const hasher &>>>
  unordered_set_adaptor(IITR_RANGE &&r, size_type n,
                        const hasher &hf = hasher{},
                        const key_equal &eql = key_equal{},
                        const alloc_t &al = alloc_t{})
    : base_t(al), hash_wrapper(hf), eq_wrapper(eql) {
    base_t::reserve(get_key(), hash(), eq(), n);
    insert_range(r);
  }
  template <class IITR_RANGE, class = enable_if_t
            <is_rng<IITR_RANGE>
             && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
             && !is_same_v<decay_t<IITR_RANGE>, this_t>
             && !is_convertible_v<IITR_RANGE &&, const hasher &>>>
  unordered_set_adaptor(IITR_RANGE &&r, const alloc_t &al)
    : unordered_set_adaptor(r, base_t::default_bucket_count,
                            hasher{}, key_equal{}, al) {}
  template <class IITR_RANGE, class = enable_if_t
            <is_rng<IITR_RANGE>
             && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
             && !is_same_v<decay_t<IITR_RANGE>, this_t>
             && !is_convertible_v<IITR_RANGE &&, const hasher &>>>
  unordered_set_adaptor(IITR_RANGE &&r, size_type n, const alloc_t &al)
    : unordered_set_adaptor(r, n, hasher{}, key_equal{}, al) {}
  template <class IITR_RANGE, class = enable_if_t
            <is_rng<IITR_RANGE>
             && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
             && !is_same_v<decay_t<IITR_RANGE>, this_t>
             && !is_convertible_v<IITR_RANGE &&, const hasher &>>>
  unordered_set_adaptor(IITR_RANGE &&r,
                        size_type n, const hasher &hf, const alloc_t &al)
    : unordered_set_adaptor(r, n, hf, key_equal{}, al) {}
  template <class IITR_RANGE>
  enable_if_t<!is_same_v<decay_t<IITR_RANGE>, this_t>
              && is_rng<IITR_RANGE>
              && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
              && is_assignable_v<value_type &, rng_ref<IITR_RANGE>>,
              this_t &>
  operator =(IITR_RANGE &&r) {
    assign_range(r);
    return *this;
  }
  template <class IITR_RANGE>
  void assign_range(IITR_RANGE &&r) {
    base_t::assign_range(get_key(), hash(), eq(), r);
  }
  template <class IITR_RANGE>
  void assign_range(IITR_RANGE &&r)
    requires (transparent
              && is_constructible_v<value_type, rng_ref<IITR_RANGE &&>>) {
    base_t::assign_range_transparent(get_key(), hash(), eq(), r);
  }
  template <class IITR_RANGE>
  void assign(IITR_RANGE &r) {
    assign_range(r);
  }

  template <class IITR_RANGE>
  enable_if_t<(!transparent
               && !is_convertible_v<IITR_RANGE &&, value_type &&>
               && !is_convertible_v<IITR_RANGE &&, const value_type &>
               && !is_convertible_v<IITR_RANGE &&, node_type &&>)
              || !is_constructible_v<value_type, IITR_RANGE &&>>
  insert(IITR_RANGE &&r) {
    insert_range(r);
  }
  template <class IITR_RANGE>
  void insert_range(IITR_RANGE &&r) {
    base_t::insert_range(get_key(), hash(), eq(), r);
  }
  template <class IITR_RANGE>
  void insert_range(IITR_RANGE &&r)
    requires (transparent
              && is_constructible_v<value_type, rng_ref<IITR_RANGE &&>>) {
    base_t::insert_range_transparent(get_key(), hash(), eq(), r);
  }

  this_t &append() {
    return *this;
  }
  template <class X, class...S>
  this_t &append(X &&x, S &&...s) {
    insert(forward<X>(x));
    return append(forward<S>(s)...);
  }
};
template <class TABLE, class HASH, class EQ>
bool operator ==(const unordered_set_adaptor<TABLE, HASH, EQ> &x,
                 const unordered_set_adaptor<TABLE, HASH, EQ> &y) {
  return x.base().equal(x.get_key(), x.hash(), x.eq(), y.hash(), y.eq(), y);
}

template <class TABLE, class HASH, class EQ>
class unordered_multiset_adaptor
  : TABLE, derivable_wrapper<HASH>, derivable_wrapper<EQ> {
  using this_t = unordered_multiset_adaptor;

  using base_t = TABLE;
  const base_t &base() const noexcept {
    return *this;
  }
  base_t &base() noexcept {
    return *this;
  }

  static constexpr bool transparent
    = is_transparent_function_v<HASH> && is_transparent_function_v<EQ>;

public:
  using traits = typename base_t::traits;
  using node_pointer = typename traits::node_base_pointer;

private:
  using hash_wrapper = derivable_wrapper<HASH>;
  using eq_wrapper = derivable_wrapper<EQ>;
  HASH &hash_ref() {
    return *static_cast<hash_wrapper &>(*this);
  }
  const HASH &hash_ref() const {
    return *static_cast<const hash_wrapper &>(*this);
  }
  EQ &eq_ref() {
    return *static_cast<eq_wrapper &>(*this);
  }
  const EQ &eq_ref() const {
    return *static_cast<const eq_wrapper &>(*this);
  }

protected:
  static auto get_key() noexcept {
    return [](const auto &x)->const auto & {
      return traits::key(x);
    };
  }
  auto hash() const noexcept {
    return ref(hash_ref());
  }
  auto eq() const noexcept {
    return ref(eq_ref());
  }

  using alloc_t = typename base_t::allocator_type;

public:
  using pointer = alloc_ptr<alloc_t>;
  using const_pointer = alloc_cptr<alloc_t>;

  // container 

  using value_type = typename base_t::value_type;
  using reference = typename base_t::const_reference;
  using const_reference = typename base_t::const_reference;

  using iterator = typename base_t::iterator;
  using const_iterator = typename base_t::const_iterator;
  using difference_type = typename base_t::difference_type;
  using size_type = typename base_t::size_type;

  iterator begin() noexcept {
    return base_t::begin();
  }
  iterator end() noexcept {
    return base_t::end();
  }
  const_iterator begin() const noexcept {
    return base_t::begin();
  }
  const_iterator end() const noexcept {
    return base_t::end();
  }
  const_iterator cbegin() const noexcept {
    return base_t::cbegin();
  }
  const_iterator cend() const noexcept {
    return base_t::cend();
  }

  size_type max_size() const noexcept {
    return base_t::max_size();
  }
  size_type size() const noexcept {
    return base_t::size();
  }
  bool empty() const noexcept {
    return base_t::empty();
  }

  unordered_multiset_adaptor() = default;
  ~unordered_multiset_adaptor() = default;
  unordered_multiset_adaptor(const unordered_multiset_adaptor &) = default;
  this_t &operator =(const unordered_multiset_adaptor &) = default;
  unordered_multiset_adaptor(unordered_multiset_adaptor &&) = default;
  this_t &operator =(unordered_multiset_adaptor &&) = default;
  friend void swap(unordered_multiset_adaptor &x,
                   unordered_multiset_adaptor &y)
    noexcept(is_nothrow_swappable_v<base_t>
             && is_nothrow_swappable_v<HASH>
             && is_nothrow_swappable_v<EQ>) {
    adl_swap(x.base(), y.base());
    adl_swap(x.hash_ref(), y.hash_ref());
    adl_swap(x.eq_ref(), y.eq_ref());
  }

  template <class TABLE2, class HASH2, class EQ2>
  friend bool operator ==
  (const unordered_multiset_adaptor<TABLE2, HASH2, EQ2> &,
   const unordered_multiset_adaptor<TABLE2, HASH2, EQ2> &);

  // reversible container

  using reverse_iterator = re::reverse_iterator<iterator>;
  using const_reverse_iterator = re::reverse_iterator<const_iterator>;

  reverse_iterator rbegin() noexcept {
    return reverse_iterator(end());
  }
  reverse_iterator rend() noexcept {
    return reverse_iterator(begin());
  }
  const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator(begin());
  }
  const_reverse_iterator crbegin() const noexcept {
    return rbegin();
  }
  const_reverse_iterator crend() const noexcept {
    return rend();
  }

  // allocator-aware container

  using allocator_type = alloc_t;
  allocator_type get_allocator() const noexcept {
    return base_t::get_allocator();
  }

  explicit unordered_multiset_adaptor(const alloc_t &al) noexcept
    : base_t(al) {}
  unordered_multiset_adaptor(const this_t &x, const alloc_t &al)
    : base_t(x.base(), al)
    , hash_wrapper(x.hash_ref())
    , eq_wrapper(x.eq_ref()) {}
  unordered_multiset_adaptor(this_t &&x, const alloc_t &al)
    : base_t(move(x.base()), al)
    , hash_wrapper(move(x.hash_ref()))
    , eq_wrapper(move(x.eq_ref())) {}

  // unordered associative container

  using key_type = typename traits::key_type;
  using hasher = HASH;
  using key_equal = EQ;
  using node_type = inner::set_node_handle<traits>;

  hasher hash_function() const {
    return hash_ref();
  }
  key_equal key_eq() const {
    return eq_ref();
  }

  unordered_multiset_adaptor(const hasher &hf, const key_equal &eql,
                             const alloc_t &al = alloc_t{})
    : base_t(al), hash_wrapper(hf), eq_wrapper(eql) {}
  explicit unordered_multiset_adaptor(size_type n,
                                      const hasher &hf = hasher{},
                                      const key_equal &eql = key_equal{},
                                      const alloc_t &al = alloc_t{})
    : base_t(al), hash_wrapper(hf), eq_wrapper(eql) {
    base_t::reserve(get_key(), hash(), eq(), n);
  }
  unordered_multiset_adaptor(size_type n, const alloc_t &al)
    : unordered_multiset_adaptor(n, hasher{}, key_equal{}, al) {}
  unordered_multiset_adaptor(size_type n, const hasher &hf, const alloc_t &al)
    : unordered_multiset_adaptor(n, hf, key_equal{}, al) {}

  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  unordered_multiset_adaptor(IITR f, IITR l,
                             size_type n = base_t::default_bucket_count,
                             const hasher &hf = hasher{},
                             const key_equal &eql = key_equal{},
                             const alloc_t &al = alloc_t{})
    : base_t(al), hash_wrapper(hf), eq_wrapper(eql) {
    base_t::reserve(get_key(), hash(), eq(), n);
    base_t::insert_range_equal(get_key(), hash(), eq(), rng(f, l));
  }
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  unordered_multiset_adaptor(IITR f, IITR l, const alloc_t &al)
    : unordered_multiset_adaptor(f, l, base_t::default_bucket_count,
                                 HASH{}, EQ{}, al) {}
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  unordered_multiset_adaptor(IITR f, IITR l, size_type n, const alloc_t &al)
    : unordered_multiset_adaptor(f, l, n, HASH{}, EQ{}, al) {}
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  unordered_multiset_adaptor(IITR f, IITR l,
                        size_type n, const hasher &hf, const alloc_t &al)
    : unordered_multiset_adaptor(f, l, n, hf, EQ{}, al) {}
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  void assign(IITR f, IITR l) {
    assign_range(rng(f, l));
  }

  unordered_multiset_adaptor(initializer_list<value_type> il,
                             size_type n = base_t::default_bucket_count,
                             const hasher &hf = hasher{},
                             const key_equal &eql = key_equal{},
                             const alloc_t &al = alloc_t{})
    : base_t(al), hash_wrapper(hf), eq_wrapper(eql) {
    base_t::reserve(get_key(), hash(), eq(), n);
    base_t::insert_range_equal(get_key(), hash(), eq(), il);
  }
  unordered_multiset_adaptor(initializer_list<value_type> il,
                             const alloc_t &al)
    : unordered_multiset_adaptor(il, base_t::default_bucket_count,
                                 hasher{}, key_equal{}, al) {}
  unordered_multiset_adaptor(initializer_list<value_type> il,
                             size_type n, const alloc_t &al)
    : unordered_multiset_adaptor(il, n, hasher{}, key_equal{}, al) {}
  unordered_multiset_adaptor(initializer_list<value_type> il,
                             size_type n, const hasher &hf, const alloc_t &al)
    : unordered_multiset_adaptor(il, n, hf, key_equal{}, al) {}
  unordered_multiset_adaptor &operator =(initializer_list<value_type> il) {
    base_t::assign_range_equal(get_key(), hash(), eq(), il);
    return *this;
  }
  void assign(initializer_list<value_type> il) {
    assign_range(il);
  }

  template <class...S>
  iterator emplace(S &&...s) {
    return base_t::emplace_equal(get_key(), hash(), eq(), forward<S>(s)...);
  }
  template <class...S>
  iterator emplace_hint(const_iterator hint, S &&...s) {
    return base_t::emplace_equal_hint(get_key(), hash(), eq(),
                                      hint.to_mutable(), forward<S>(s)...);
  }
  iterator insert(const value_type &x) {
    return base_t::emplace_equal(get_key(), hash(), eq(), x);
  }
  iterator insert(value_type &&x) {
    return base_t::emplace_equal(get_key(), hash(), eq(), move(x));
  }
  iterator insert(const_iterator hint, const value_type &x) {
    return base_t::emplace_equal_hint(get_key(), hash(), eq(),
                                      hint.to_mutable(), x);
  }
  iterator insert(const_iterator hint, value_type &&x) {
    return base_t::emplace_equal_hint(get_key(), hash(), eq(),
                                      hint.to_mutable(), move(x));
  }
  template <class IITR>
  void insert(IITR from, IITR to) {
    base_t::insert_range_equal(get_key(), hash(), eq(), rng(from, to));
  }
  void insert(initializer_list<value_type> il) {
    base_t::insert_range_equal(get_key(), hash(), eq(), il);
  }

  node_type extract(const_iterator pos) {
    return base_t::template extract<node_type>(pos.to_mutable());
  }
  node_type extract(const key_type &key) {
    return base_t::template extract<node_type>(get_key(), hash(), eq(), key);
  }
  template <class K>
  node_type extract(K &&key)
    requires (transparent
              && !is_convertible_v<K &&, iterator>
              && !is_convertible_v<K &&, const_iterator>) {
    return base_t::template extract<node_type>(get_key(), hash(), eq(), key);
  }
  iterator insert(node_type &&nh) {
    return base_t::template insert_node_handle_equal
      (get_key(), hash(), eq(), move(nh));
  }
  iterator insert(const_iterator hint, node_type &&nh) {
    return base_t::template insert_node_handle_equal
      (get_key(), hash(), eq(), hint.to_mutable(), move(nh));
  }

  iterator erase(const_iterator pos) {
    return base_t::erase(pos.to_mutable());
  }
  iterator erase(const_iterator from, const_iterator to) {
    while (from != to)
      from = erase(from);
    return from.to_mutable();
  }
  void clear() noexcept {
    base_t::clear();
  }

  size_type erase(const key_type &key) {
    return base_t::erase(get_key(), hash(), eq(), key);
  }
  template <class K>
  size_type erase(K &&key)
    requires (transparent
              && !is_convertible_v<K &&, iterator>
              && !is_convertible_v<K &&, const_iterator>) {
    return base_t::erase(get_key(), hash(), eq(), key);
  }

  size_type remove(const key_type &key) {
    if constexpr (traits::store_node_allocator::value) {
      return base_t::erase(get_key(), hash(), eq(), key);
    }
    else {
      return base_t::unlink(get_key(), hash(), eq(), key);
    }
  }
  template <class K>
  size_type remove(const K &key) requires transparent {
    if constexpr (traits::store_node_allocator::value) {
      return base_t::erase(get_key(), hash(), eq(), key);
    }
    else {
      return base_t::unlink(get_key(), hash(), eq(), key);
    }
  }
  template <class UF>
  size_type remove_if(UF eq) {
    size_type ret = 0;
    for (iterator it = begin(); it != end();) {
      if (eq(*it)) {
        it = erase_or_unlink(it);
        ++ret;
      }
      else
        ++it;
    }
    return ret;
  }

  template <class HASH2, class EQ2>
  void merge(unordered_set_adaptor<base_t, HASH2, EQ2> &x) {
    base_t::merge_equal(get_key(), hash(), eq(), x.base());
  }
  template <class HASH2, class EQ2>
  void merge(unordered_set_adaptor<base_t, HASH2, EQ2> &&x) {
    base_t::merge_equal(get_key(), hash(), eq(), x.base());
  }
  template <class HASH2, class EQ2>
  void merge(unordered_multiset_adaptor<base_t, HASH2, EQ2> &x) {
    base_t::merge_equal(get_key(), hash(), eq(), x.base());
  }
  template <class HASH2, class EQ2>
  void merge(unordered_multiset_adaptor<base_t, HASH2, EQ2> &&x) {
    base_t::merge_equal(get_key(), hash(), eq(), x.base());
  }

  iterator find(const key_type &key) {
    return base_t::find(get_key(), hash(), eq(), key);
  }
  template <class K>
  iterator find(const K &key) requires transparent {
    return base_t::find(get_key(), hash(), eq(), key);
  }
  const_iterator find(const key_type &key) const {
    return base_t::find(get_key(), hash(), eq(), key);
  }
  template <class K>
  const_iterator find(const K &key) const requires transparent {
    return base_t::find(get_key(), hash(), eq(), key);
  }

  bool contains(const key_type &key) const {
    return find(key) != end();
  }
  template <class K>
  bool contains(const K &key) const requires transparent {
    return find(key) != end();
  }

  size_type count(const key_type &key) const {
    return base_t::count(get_key(), hash(), eq(), key);
  }
  template <class K>
  size_type count(const K &key) const requires transparent {
    return base_t::count(get_key(), hash(), eq(), key);
  }

  iter_pair<iterator> equal_range(const key_type &key) {
    return base_t::equal_range(get_key(), hash(), eq(), key);
  }
  template <class K>
  iter_pair<iterator> equal_range(const K &key) requires transparent {
    return base_t::equal_range(get_key(), hash(), eq(), key);
  }
  iter_pair<const_iterator> equal_range(const key_type &key) const {
    return base_t::equal_range(get_key(), hash(), eq(), key);
  }
  template <class K>
  iter_pair<const_iterator> equal_range(const K &key) const
    requires transparent {
    return base_t::equal_range(get_key(), hash(), eq(), key);
  }

  size_type bucket_count() const noexcept {
    return base_t::bucket_count();
  }
  size_type active_bucket_count() const noexcept {
    return base_t::active_bucket_count();
  }
  size_type max_bucket_count() const noexcept {
    return base_t::max_bucket_count();
  }
  size_type bucket_size(size_type n) const {
    return base_t::bucket_size(n);
  }
  size_type bucket(const key_type &k) const {
    return base_t::bucket(hash(), k);
  }

  using local_iterator = typename base_t::local_iterator;
  using const_local_iterator = typename base_t::const_local_iterator;

  local_iterator begin(size_type n) noexcept {
    return base_t::begin(n);
  }
  local_iterator end(size_type n) noexcept {
    return base_t::end(n);
  }
  const_local_iterator begin(size_type n) const noexcept {
    return base_t::begin(n);
  }
  const_local_iterator end(size_type n) const noexcept {
    return base_t::end(n);
  }
  const_local_iterator cbegin(size_type n) const noexcept {
    return begin(n);
  }
  const_local_iterator cend(size_type n) const noexcept {
    return end(n);
  }

  iter_pair<local_iterator> bucket_range(size_type n) {
    return base_t::bucket_range(n);
  }
  iter_pair<const_local_iterator> bucket_range(size_type n) const {
    return base_t::bucket_range(n);
  }

  float load_factor() const noexcept {
    return base_t::load_factor();
  }
  float max_load_factor() const noexcept {
    return base_t::max_load_factor();
  }
  void max_load_factor(float f) {
    base_t::max_load_factor(f);
  }
  void rehash(size_type n) {
    base_t::rehash(get_key(), hash(), eq(), n);
  }
  void reserve(size_type n) {
    base_t::reserve(get_key(), hash(), eq(), n);
  }

  // extensions

  template <class...S>
  iterator new_node(S &&...s) {
    return base_t::new_node(forward<S>(s)...);
  }
  void delete_node(const_iterator it) noexcept {
    base_t::delete_node(it.to_mutable());
  }

  iterator unlink(const_iterator it) noexcept {
    return base_t::unlink(it.to_mutable());
  }
  iterator unlink(const_iterator from, const_iterator to) noexcept {
    return base_t::unlink(from.to_mutable(), to.to_mutable());
  }
  void unlink() noexcept {
    base_t::unlink();
  }
  size_type unlink_key(const key_type &key) {
    return base_t::unlink(get_key(), hash(), eq(), key);
  }
  template <class K>
  size_type unlink_key(const K &key) requires transparent {
    return base_t::unlink(get_key(), hash(), eq(), key);
  }
  iterator link(const_iterator it) {
    return base_t::link_equal(get_key(), hash(), eq(), it.to_mutable());
  }
  iterator link(const_iterator hint, const_iterator it) {
    return base_t::link_equal(get_key(), hash(), eq(),
                              hint.to_mutable(), it.to_mutable());
  }

  template <class K, class GET_NODE>
  iterator try_link(const K &key, GET_NODE get_node) {
    return base_t::insert_equal(get_key(), hash(), eq(), key, get_node);
  }
  template <class K, class GET_NODE>
  iterator try_link_hint(const_iterator hint,
                         const K &key, GET_NODE get_node) {
    return base_t::insert_equal(get_key(), hash(), eq(),
                                hint.to_mutable(), key, get_node);
  }

  template <bool Y = traits::store_node_allocator::value>
  enable_if_t<Y, iterator> erase_or_unlink(const_iterator it) noexcept {
    return erase(it);
  }
  template <bool Y = traits::store_node_allocator::value>
  enable_if_t<!Y, iterator> erase_or_unlink(const_iterator it) noexcept {
    return unlink(it);
  }

  void unique() {
    list_unique(*this, eq(), [this](auto it) {return erase_or_unlink(it);});
  };
  template <class EQL>
  void unique(EQL eql) {
    list_unique(*this, eql, [this](auto it) {return erase_or_unlink(it);});
  };

  template <class IITR_RANGE>
  unordered_multiset_adaptor(from_range_t, IITR_RANGE &&r,
                             size_type n = base_t::default_bucket_count,
                             const hasher &hf = hasher{},
                             const key_equal &eql = key_equal{},
                             const alloc_t &al = alloc_t{})
    : base_t(al), hash_wrapper(hf), eq_wrapper(eql) {
    base_t::reserve(get_key(), hash(), eq(), n);
    insert_range(r);
  }
  template <class IITR_RANGE>
  unordered_multiset_adaptor(from_range_t, IITR_RANGE &&r, const alloc_t &al)
    : unordered_multiset_adaptor(from_range, r, base_t::default_bucket_count,
                                 HASH{}, EQ{}, al) {}
  template <class IITR_RANGE>
  unordered_multiset_adaptor(from_range_t, IITR_RANGE &&r, size_type n,
                             const alloc_t &al)
    : unordered_multiset_adaptor(from_range, r, n, HASH{}, EQ{}, al) {}
  template <class IITR_RANGE>
  unordered_multiset_adaptor(from_range_t, IITR_RANGE &&r,
                             size_type n, const hasher &hf, const alloc_t &al)
    : unordered_multiset_adaptor(from_range, r, n, hf, EQ{}, al) {}
  template <class IITR_RANGE, class = enable_if_t
            <is_rng<IITR_RANGE>
             && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
             && !is_same_v<decay_t<IITR_RANGE>, this_t>
             && !is_convertible_v<IITR_RANGE &&, const alloc_t &>>>
  explicit unordered_multiset_adaptor(IITR_RANGE &&r) {
    base_t::reserve(get_key(), hash(), eq(), base_t::default_bucket_count);
    base_t::insert_range_equal(get_key(), hash(), eq(), r);
  }
  template <class IITR_RANGE, class = enable_if_t
            <is_rng<IITR_RANGE>
             && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
             && !is_same_v<decay_t<IITR_RANGE>, this_t>
             && !is_convertible_v<IITR_RANGE &&, const hasher &>>>
  unordered_multiset_adaptor(IITR_RANGE &&r, size_type n,
                             const hasher &hf = hasher{},
                             const key_equal &eql = key_equal{},
                             const alloc_t &al = alloc_t{})
    : base_t(al), hash_wrapper(hf), eq_wrapper(eql) {
    base_t::reserve(get_key(), hash(), eq(), n);
    base_t::insert_range_equal(get_key(), hash(), eq(), r);
  }
  template <class IITR_RANGE, class = enable_if_t
            <is_rng<IITR_RANGE>
             && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
             && !is_same_v<decay_t<IITR_RANGE>, this_t>
             && !is_convertible_v<IITR_RANGE &&, const hasher &>>>
  unordered_multiset_adaptor(IITR_RANGE &&r, const alloc_t &al)
    : unordered_multiset_adaptor(r, base_t::default_bucket_count,
                                 hasher{}, key_equal{}, al) {}
  template <class IITR_RANGE, class = enable_if_t
            <is_rng<IITR_RANGE>
             && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
             && !is_same_v<decay_t<IITR_RANGE>, this_t>
             && !is_convertible_v<IITR_RANGE &&, const hasher &>>>
  unordered_multiset_adaptor(IITR_RANGE &&r, size_type n, const alloc_t &al)
    : unordered_multiset_adaptor(r, n, hasher{}, key_equal{}, al) {}
  template <class IITR_RANGE, class = enable_if_t
            <is_rng<IITR_RANGE>
             && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
             && !is_same_v<decay_t<IITR_RANGE>, this_t>
             && !is_convertible_v<IITR_RANGE &&, const hasher &>>>
  unordered_multiset_adaptor(IITR_RANGE &&r,
                             size_type n, const hasher &hf, const alloc_t &al)
    : unordered_multiset_adaptor(r, n, hf, key_equal{}, al) {}
  template <class IITR_RANGE>
  enable_if_t<!is_same_v<decay_t<IITR_RANGE>, this_t>
              && is_rng<IITR_RANGE>
              && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
              && is_assignable_v<value_type &, rng_ref<IITR_RANGE>>,
              this_t &>
  operator =(IITR_RANGE &&r) {
    base_t::assign_range_equal(get_key(), hash(), eq(), r);
    return *this;
  }
  template <class IITR_RANGE>
  void assign_range(IITR_RANGE &&r) {
    base_t::assign_range_equal(get_key(), hash(), eq(), r);
  }
  template <class IITR_RANGE>
  void assign(IITR_RANGE &r) {
    assign_range(r);
  }

  template <class IITR_RANGE>
  enable_if_t<!is_convertible_v<IITR_RANGE &&, value_type &&>
              && !is_convertible_v<IITR_RANGE &&, const value_type &>
              && !is_convertible_v<IITR_RANGE &&, node_type &&>>
  insert(IITR_RANGE &&r) {
    base_t::insert_range_equal(get_key(), hash(), eq(), r);
  }
  template <class IITR_RANGE>
  void insert_range(IITR_RANGE &&r) {
    base_t::insert_range_equal(get_key(), hash(), eq(), r);
  }

  this_t &append() {
    return *this;
  }
  template <class X, class...S>
  this_t &append(X &&x, S &&...s) {
    insert(forward<X>(x));
    return append(forward<S>(s)...);
  }
};
template <class TABLE, class HASH, class EQ>
bool operator ==(const unordered_multiset_adaptor<TABLE, HASH, EQ> &x,
                 const unordered_multiset_adaptor<TABLE, HASH, EQ> &y) {
  return x.base().equal_equal(x.get_key(), x.hash(), x.eq(), y.hash(), y.eq(),
                              y);
}

template <class TABLE, class HASH, class EQ>
class unordered_map_adaptor
  : TABLE, derivable_wrapper<HASH>, derivable_wrapper<EQ> {
  using this_t = unordered_map_adaptor;

  using base_t = TABLE;
  const base_t &base() const noexcept {
    return *this;
  }
  base_t &base() noexcept {
    return *this;
  }

  static constexpr bool transparent
    = is_transparent_function_v<HASH> && is_transparent_function_v<EQ>;

public:
  using traits = typename base_t::traits;
  using node_pointer = typename traits::node_base_pointer;

private:
  using hash_wrapper = derivable_wrapper<HASH>;
  using eq_wrapper = derivable_wrapper<EQ>;
  HASH &hash_ref() {
    return *static_cast<hash_wrapper &>(*this);
  }
  const HASH &hash_ref() const {
    return *static_cast<const hash_wrapper &>(*this);
  }
  EQ &eq_ref() {
    return *static_cast<eq_wrapper &>(*this);
  }
  const EQ &eq_ref() const {
    return *static_cast<const eq_wrapper &>(*this);
  }

protected:
  static auto get_key() noexcept {
    return [](const auto &x)->const auto & {
      return traits::key(x);
    };
  }
  static auto get_mapped() noexcept {
    return [](auto &x)->auto & {
      return traits::mapped(x);
    };
  }
  auto hash() const noexcept {
    return ref(hash_ref());
  }
  auto eq() const noexcept {
    return ref(eq_ref());
  }

  using alloc_t = typename base_t::allocator_type;

public:
  using pointer = alloc_ptr<alloc_t>;
  using const_pointer = alloc_cptr<alloc_t>;

  // container 

  using value_type = typename base_t::value_type;
  using reference = typename base_t::reference;
  using const_reference = typename base_t::const_reference;

  using iterator = typename base_t::iterator;
  using const_iterator = typename base_t::const_iterator;
  using difference_type = typename base_t::difference_type;
  using size_type = typename base_t::size_type;

  iterator begin() noexcept {
    return base_t::begin();
  }
  iterator end() noexcept {
    return base_t::end();
  }
  const_iterator begin() const noexcept {
    return base_t::begin();
  }
  const_iterator end() const noexcept {
    return base_t::end();
  }
  const_iterator cbegin() const noexcept {
    return base_t::cbegin();
  }
  const_iterator cend() const noexcept {
    return base_t::cend();
  }

  size_type max_size() const noexcept {
    return base_t::max_size();
  }
  size_type size() const noexcept {
    return base_t::size();
  }
  bool empty() const noexcept {
    return base_t::empty();
  }

  unordered_map_adaptor() = default;
  ~unordered_map_adaptor() = default;
  unordered_map_adaptor(const unordered_map_adaptor &) = default;
  unordered_map_adaptor &operator =(const unordered_map_adaptor &) = default;
  unordered_map_adaptor(unordered_map_adaptor &&) = default;
  unordered_map_adaptor &operator =(unordered_map_adaptor &&) = default;
  friend void swap(unordered_map_adaptor &x,
                   unordered_map_adaptor &y)
    noexcept(is_nothrow_swappable_v<base_t>
             && is_nothrow_swappable_v<HASH>
             && is_nothrow_swappable_v<EQ>) {
    adl_swap(x.base(), y.base());
    adl_swap(x.hash_ref(), y.hash_ref());
    adl_swap(x.eq_ref(), y.eq_ref());
  }

  template <class TABLE2, class HASH2, class EQ2>
  friend bool operator ==(const unordered_map_adaptor<TABLE2, HASH2, EQ2> &,
                          const unordered_map_adaptor<TABLE2, HASH2, EQ2> &);

  // reversible container

  using reverse_iterator = re::reverse_iterator<iterator>;
  using const_reverse_iterator = re::reverse_iterator<const_iterator>;

  reverse_iterator rbegin() noexcept {
    return reverse_iterator(end());
  }
  reverse_iterator rend() noexcept {
    return reverse_iterator(begin());
  }
  const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator(begin());
  }
  const_reverse_iterator crbegin() const noexcept {
    return rbegin();
  }
  const_reverse_iterator crend() const noexcept {
    return rend();
  }

  // allocator-aware container

  using allocator_type = alloc_t;
  allocator_type get_allocator() const noexcept {
    return base_t::get_allocator();
  }

  explicit unordered_map_adaptor(const alloc_t &al) noexcept : base_t(al) {}
  unordered_map_adaptor(const this_t &x, const alloc_t &al)
    : base_t(x.base(), al)
    , hash_wrapper(x.hash_ref())
    , eq_wrapper(x.eq_ref()) {}
  unordered_map_adaptor(this_t &&x, const alloc_t &al)
    : base_t(move(x.base()), al)
    , hash_wrapper(move(x.hash_ref()))
    , eq_wrapper(move(x.eq_ref())) {}

  // unordered associative container

  using key_type = typename traits::key_type;
  using mapped_type = typename traits::mapped_type;
  using hasher = HASH;
  using key_equal = EQ;
  using node_type = inner::map_node_handle<traits>;
  using insert_return_type
    = inner::node_handle_insert_return_type<iterator, node_type>;

  hasher hash_function() const {
    return hash_ref();
  }
  key_equal key_eq() const {
    return eq_ref();
  }

  unordered_map_adaptor(const hasher &hf, const key_equal &eql,
                        const alloc_t &al = alloc_t{})
    : base_t(al), hash_wrapper(hf), eq_wrapper(eql) {}
  explicit unordered_map_adaptor(size_type n,
                                 const hasher &hf = hasher{},
                                 const key_equal &eql = key_equal{},
                                 const alloc_t &al = alloc_t{})
    : base_t(al), hash_wrapper(hf), eq_wrapper(eql) {
    base_t::reserve(get_key(), hash(), eq(), n);
  }
  unordered_map_adaptor(size_type n, const alloc_t &al)
    : unordered_map_adaptor(n, hasher{}, key_equal{}, al) {}
  unordered_map_adaptor(size_type n, const hasher &hf, const alloc_t &al)
    : unordered_map_adaptor(n, hf, key_equal{}, al) {}

  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  unordered_map_adaptor(IITR f, IITR l,
                        size_type n = base_t::default_bucket_count,
                        const hasher &hf = hasher{},
                        const key_equal &eql = key_equal{},
                        const alloc_t &al = alloc_t{})
    : base_t(al), hash_wrapper(hf), eq_wrapper(eql) {
    base_t::reserve(get_key(), hash(), eq(), n);
    base_t::insert_range(get_key(), hash(), eq(), rng(f, l));
  }
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  unordered_map_adaptor(IITR f, IITR l, const alloc_t &al)
    : unordered_map_adaptor(f, l, base_t::default_bucket_count,
                            HASH{}, EQ{}, al) {}
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  unordered_map_adaptor(IITR f, IITR l, size_type n, const alloc_t &al)
    : unordered_map_adaptor(f, l, n, HASH{}, EQ{}, al) {}
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  unordered_map_adaptor(IITR f, IITR l,
                        size_type n, const hasher &hf, const alloc_t &al)
    : unordered_map_adaptor(f, l, n, hf, EQ{}, al) {}
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  void assign(IITR f, IITR l) {
    assign_range(rng(f, l));
  }

  unordered_map_adaptor(initializer_list<value_type> il,
                        size_type n = base_t::default_bucket_count,
                        const hasher &hf = hasher{},
                        const key_equal &eql = key_equal{},
                        const alloc_t &al = alloc_t{})
    : base_t(al), hash_wrapper(hf), eq_wrapper(eql) {
    base_t::reserve(get_key(), hash(), eq(), n);
    base_t::insert_range(get_key(), hash(), eq(), il);
  }
  unordered_map_adaptor(initializer_list<value_type> il, const alloc_t &al)
    : unordered_map_adaptor(il, base_t::default_bucket_count,
                            hasher{}, key_equal{}, al) {}
  unordered_map_adaptor(initializer_list<value_type> il,
                        size_type n, const alloc_t &al)
    : unordered_map_adaptor(il, n, hasher{}, key_equal{}, al) {}
  unordered_map_adaptor(initializer_list<value_type> il,
                        size_type n, const hasher &hf, const alloc_t &al)
    : unordered_map_adaptor(il, n, hf, key_equal{}, al) {}
  unordered_map_adaptor &operator =(initializer_list<value_type> il) {
    base_t::assign_range(get_key(), hash(), eq(), il);
    return *this;
  }
  void assign(initializer_list<value_type> il) {
    assign_range(il);
  }

  template <class...S>
  pair<iterator, bool> emplace(S &&...s) {
    return base_t::emplace(get_key(), hash(), eq(), forward<S>(s)...);
  }
  template <class...S>
  iterator emplace_hint(const_iterator hint, S &&...s) {
    return base_t::emplace(get_key(), hash(), eq(), forward<S>(s)...).first;
  }
  pair<iterator, bool> insert(const value_type &x) {
    return base_t::insert(get_key(), hash(), eq(), x);
  }
  pair<iterator, bool> insert(value_type &&x) {
    return base_t::insert(get_key(), hash(), eq(), move(x));
  }
  iterator insert(const_iterator hint, const value_type &x) {
    return base_t::insert(get_key(), hash(), eq(), x).first;
  }
  iterator insert(const_iterator hint, value_type &&x) {
    return base_t::insert(get_key(), hash(), eq(), move(x)).first;
  }
  template <class IITR>
  void insert(IITR from, IITR to) {
    base_t::insert_range(get_key(), hash(), eq(), rng(from, to));
  }
  void insert(initializer_list<value_type> il) {
    base_t::insert_range(get_key(), hash(), eq(), il);
  }

  template <class...S>
  pair<iterator, bool> try_emplace(const key_type &key, S &&...s) {
    return base_t::try_emplace(get_key(), hash(), eq(), key, forward<S>(s)...);
  }
  template <class...S>
  pair<iterator, bool> try_emplace(key_type &&key, S &&...s) {
    return base_t::try_emplace(get_key(), hash(), eq(), move(key),
                               forward<S>(s)...);
  }
  template <class K, class...S>
  pair<iterator, bool> try_emplace(K &&k, S &&...s)
    requires (transparent
              && !is_convertible_v<K &&, const_iterator>
              && !is_convertible_v<K &&, iterator>) {
    return base_t::try_emplace(get_key(), hash(), eq(), forward<K>(k),
                               forward<S>(s)...);
  }

  template <class...S>
  iterator try_emplace(const_iterator hint, const key_type &key, S &&...s) {
    return base_t::try_emplace(get_key(), hash(), eq(),
                               key, forward<S>(s)...).first;
  }
  template <class...S>
  iterator try_emplace(const_iterator hint, key_type &&key, S &&...s) {
    return base_t::try_emplace(get_key(), hash(), eq(),
                               move(key), forward<S>(s)...).first;
  }
  template <class K, class...S>
  iterator try_emplace(const_iterator hint, K &&key, S &&...s)
    requires transparent {
    return base_t::try_emplace(get_key(), hash(), eq(),
                               forward<K>(key), forward<S>(s)...).first;
  }

  template <class M>
  pair<iterator, bool> insert_or_assign(const key_type &key, M &&obj) {
    return base_t::insert_or_assign(get_key(), get_mapped(), hash(), eq(),
                                    key, forward<M>(obj));
  }
  template <class M>
  pair<iterator, bool> insert_or_assign(key_type &&key, M &&obj) {
    return base_t::insert_or_assign(get_key(), get_mapped(), hash(), eq(),
                                    move(key), forward<M>(obj));
  }
  template <class K, class M>
  pair<iterator, bool> insert_or_assign(K &&key, M &&obj)
    requires transparent {
    return base_t::insert_or_assign(get_key(), get_mapped(), hash(), eq(),
                                    forward<K>(key), forward<M>(obj));
  }
  template <class M>
  iterator insert_or_assign(const_iterator hint,
                            const key_type &key, M &&obj) {
    return base_t::insert_or_assign(get_key(), get_mapped(), hash(), eq(),
                                    key, forward<M>(obj)).first;
  }
  template <class M>
  iterator insert_or_assign(const_iterator hint,
                            key_type &&key, M &&obj) {
    return base_t::insert_or_assign(get_key(), get_mapped(), hash(), eq(),
                                    move(key), forward<M>(obj)).first;
  }
  template <class K, class M>
  iterator insert_or_assign(const_iterator hint, K &&key, M &&obj)
    requires transparent {
    return base_t::insert_or_assign(get_key(), get_mapped(), hash(), eq(),
                                    forward<K>(key), forward<M>(obj)).first;
  }

  mapped_type &operator [](const key_type &key) {
    return traits::mapped(*try_emplace(key).first);
  }
  mapped_type &operator [](key_type &&key) {
    return traits::mapped(*try_emplace(move(key)).first);
  }
  template <class K>
  mapped_type &operator [](K &&key) requires transparent {
    return traits::mapped(*try_emplace(forward<K>(key)).first);
  }

  const mapped_type &operator [](const key_type &key) const {
    return traits::mapped(*find(key));
  }
  template <class K>
  const mapped_type &operator [](const K &key) const requires transparent {
    return traits::mapped(*find(key));
  }

  mapped_type &at(const key_type &key) {
    const iterator it = find(key);
    if (it == end())
      throw_or_terminate<out_of_range>
        ("re::unordered_map_adaptor: at(key) failed");
    return traits::mapped(*it);
  }
  template <class K>
  mapped_type &at(const K &key) requires transparent {
    const iterator it = find(key);
    if (it == end())
      throw_or_terminate<out_of_range>
        ("re::unordered_map_adaptor: at(key) failed");
    return traits::mapped(*it);
  }

  const mapped_type &at(const key_type &key) const {
    const const_iterator it = find(key);
    if (it == end())
      throw_or_terminate<out_of_range>
        ("re::unordered_map_adaptor: at(key) failed");
    return traits::mapped(*it);
  }
  template <class K>
  const mapped_type &at(const K &key) const requires transparent {
    const const_iterator it = find(key);
    if (it == end())
      throw_or_terminate<out_of_range>
        ("re::unordered_map_adaptor: at(key) failed");
    return traits::mapped(*it);
  }

  node_type extract(const_iterator pos) {
    return base_t::template extract<node_type>(pos.to_mutable());
  }
  node_type extract(const key_type &key) {
    return base_t::template extract<node_type>(get_key(), hash(), eq(), key);
  }
  template <class K>
  node_type extract(K &&key)
    requires (transparent
              && !is_convertible_v<K &&, iterator>
              && !is_convertible_v<K &&, const_iterator>) {
    return base_t::template extract<node_type>(get_key(), hash(), eq(), key);
  }

  insert_return_type insert(node_type &&nh) {
    return base_t::template insert_node_handle<iterator>
      (get_key(), hash(), eq(), move(nh));
  }
  iterator insert(const_iterator hint, node_type &&nh) {
    auto x = base_t::template insert_node_handle<iterator>
      (get_key(), hash(), eq(), move(nh));
    nh = move(x.node);
    return x.position;
  }

  iterator erase(const_iterator pos) {
    return base_t::erase(pos.to_mutable());
  }
  iterator erase(const_iterator from, const_iterator to) {
    while (from != to)
      from = erase(from);
    return from.to_mutable();
  }
  void clear() noexcept {
    base_t::clear();
  }

  size_type erase(const key_type &key) {
    const auto it = base_t::find(get_key(), hash(), eq(), key);
    if (it == end())
      return 0;
    erase(it);
    return 1;
  }
  template <class K>
  size_type erase(K &&key)
    requires (transparent
              && !is_convertible_v<K &&, iterator>
              && !is_convertible_v<K &&, const_iterator>) {
    const auto it = base_t::find(get_key(), hash(), eq(), key);
    if (it == end())
      return 0;
    erase(it);
    return 1;
  }

  size_type remove(const key_type &key) {
    const auto it = base_t::find(get_key(), hash(), eq(), key);
    if (it == end())
      return 0;
    erase_or_unlink(it);
    return 1;
  }
  template <class K>
  size_type remove(const K &key) requires transparent {
    const auto it = base_t::find(get_key(), hash(), eq(), key);
    if (it == end())
      return 0;
    erase_or_unlink(it);
    return 1;
  }
  template <class UF>
  size_type remove_if(UF eq) {
    size_type ret = 0;
    for (iterator it = begin(); it != end();) {
      if (eq(*it)) {
        it = erase_or_unlink(it);
        ++ret;
      }
      else
        ++it;
    }
    return ret;
  }

  template <class HASH2, class EQ2>
  void merge(unordered_map_adaptor<base_t, HASH2, EQ2> &x) {
    base_t::merge(get_key(), hash(), eq(), x.base());
  }
  template <class HASH2, class EQ2>
  void merge(unordered_map_adaptor<base_t, HASH2, EQ2> &&x) {
    base_t::merge(get_key(), hash(), eq(), x.base());
  }
  template <class HASH2, class EQ2>
  void merge(unordered_multimap_adaptor<base_t, HASH2, EQ2> &x) {
    base_t::merge(get_key(), hash(), eq(), x.base());
  }
  template <class HASH2, class EQ2>
  void merge(unordered_multimap_adaptor<base_t, HASH2, EQ2> &&x) {
    base_t::merge(get_key(), hash(), eq(), x.base());
  }

  iterator find(const key_type &key) {
    return base_t::find(get_key(), hash(), eq(), key);
  }
  template <class K>
  iterator find(const K &key) requires transparent {
    return base_t::find(get_key(), hash(), eq(), key);
  }
  const_iterator find(const key_type &key) const {
    return base_t::find(get_key(), hash(), eq(), key);
  }
  template <class K>
  const_iterator find(const K &key) const requires transparent {
    return base_t::find(get_key(), hash(), eq(), key);
  }

  bool contains(const key_type &key) const {
    return find(key) != end();
  }
  template <class K>
  bool contains(const K &key) const requires transparent {
    return find(key) != end();
  }

  size_type count(const key_type &key) const {
    return find(key) != end() ? 1 : 0;
  }
  template <class K>
  size_type count(const K &key) const requires transparent {
    return find(key) != end() ? 1 : 0;
  }

  iter_pair<iterator> equal_range(const key_type &key) {
    const iterator it = base_t::find(get_key(), hash(), eq(), key);
    return {it, it == end() ? end() : next(it)};
  }
  template <class K>
  iter_pair<iterator> equal_range(const K &key) requires transparent {
    const iterator it = base_t::find(get_key(), hash(), eq(), key);
    return {it, it == end() ? end() : next(it)};
  }
  iter_pair<const_iterator> equal_range(const key_type &key) const {
    const const_iterator it = base_t::find(get_key(), hash(), eq(), key);
    return {it, it == end() ? end() : next(it)};
  }
  template <class K>
  iter_pair<const_iterator> equal_range(const K &key) const
    requires transparent {
    const const_iterator it = base_t::find(get_key(), hash(), eq(), key);
    return {it, it == end() ? end() : next(it)};
  }

  size_type bucket_count() const noexcept {
    return base_t::bucket_count();
  }
  size_type active_bucket_count() const noexcept {
    return base_t::active_bucket_count();
  }
  size_type max_bucket_count() const noexcept {
    return base_t::max_bucket_count();
  }
  size_type bucket_size(size_type n) const {
    return base_t::bucket_size(n);
  }
  size_type bucket(const key_type &k) const {
    return base_t::bucket(hash(), k);
  }

  using local_iterator = typename base_t::local_iterator;
  using const_local_iterator = typename base_t::const_local_iterator;

  local_iterator begin(size_type n) noexcept {
    return base_t::begin(n);
  }
  local_iterator end(size_type n) noexcept {
    return base_t::end(n);
  }
  const_local_iterator begin(size_type n) const noexcept {
    return base_t::begin(n);
  }
  const_local_iterator end(size_type n) const noexcept {
    return base_t::end(n);
  }
  const_local_iterator cbegin(size_type n) const noexcept {
    return begin(n);
  }
  const_local_iterator cend(size_type n) const noexcept {
    return end(n);
  }

  iter_pair<local_iterator> bucket_range(size_type n) {
    return base_t::bucket_range(n);
  }
  iter_pair<const_local_iterator> bucket_range(size_type n) const {
    return base_t::bucket_range(n);
  }

  float load_factor() const noexcept {
    return base_t::load_factor();
  }
  float max_load_factor() const noexcept {
    return base_t::max_load_factor();
  }
  void max_load_factor(float f) {
    base_t::max_load_factor(f);
  }
  void rehash(size_type n) {
    base_t::rehash(get_key(), hash(), eq(), n);
  }
  void reserve(size_type n) {
    base_t::reserve(get_key(), hash(), eq(), n);
  }

  // extensions

  template <class...S>
  iterator new_node(S &&...s) {
    return base_t::new_node(forward<S>(s)...);
  }
  void delete_node(const_iterator it) noexcept {
    base_t::delete_node(it.to_mutable());
  }

  iterator unlink(const_iterator it) noexcept {
    return base_t::unlink(it.to_mutable());
  }
  iterator unlink(const_iterator from, const_iterator to) noexcept {
    return base_t::unlink(from.to_mutable(), to.to_mutable());
  }
  void unlink() noexcept {
    base_t::unlink();
  }
  size_type unlink_key(const key_type &key) {
    const auto it = base_t::find(get_key(), hash(), eq(), key);
    if (it == end())
      return 0;
    unlink(it);
    return 1;
  }
  template <class K>
  size_type unlink_key(const K &key) requires transparent {
    const auto it = base_t::find(get_key(), hash(), eq(), key);
    if (it == end())
      return 0;
    unlink(it);
    return 1;
  }
  pair<iterator, bool> link(const_iterator it) {
    return base_t::link(get_key(), hash(), eq(), it.to_mutable());
  }
  iterator link(iterator hint, const_iterator it) {
    return base_t::link(get_key(), hash(), eq(), it.to_mutable()).first;
  }

  template <class K, class GET_NODE, class DO_WHEN_EQ = empty_function>
  pair<iterator, bool> try_link(const K &key, GET_NODE get_node,
                                DO_WHEN_EQ do_when_eq = DO_WHEN_EQ{}) {
    return base_t::insert(get_key(), hash(), eq(), key, get_node, do_when_eq);
  }
  template <class K, class GET_NODE, class DO_WHEN_EQ = empty_function>
  iterator try_link_hint(const_iterator hint, const K &key, GET_NODE get_node,
                         DO_WHEN_EQ do_when_eq = DO_WHEN_EQ{}) {
    return try_link(key, get_node, do_when_eq).first;
  }

  template <bool Y = traits::store_node_allocator::value>
  enable_if_t<Y, iterator> erase_or_unlink(const_iterator it) noexcept {
    return erase(it);
  }
  template <bool Y = traits::store_node_allocator::value>
  enable_if_t<!Y, iterator> erase_or_unlink(const_iterator it) noexcept {
    return unlink(it);
  }

  void unique() {}
  template <class EQL>
  void unique(EQL eql) {
    list_unique(*this, eql, [this](auto it) {return erase_or_unlink(it);});
  };

  template <class IITR_RANGE>
  unordered_map_adaptor(from_range_t, IITR_RANGE &&r,
                        size_type n = base_t::default_bucket_count,
                        const hasher &hf = hasher{},
                        const key_equal &eql = key_equal{},
                        const alloc_t &al = alloc_t{})
    : base_t(al), hash_wrapper(hf), eq_wrapper(eql) {
    base_t::reserve(get_key(), hash(), eq(), n);
    insert_range(r);
  }
  template <class IITR_RANGE>
  unordered_map_adaptor(from_range_t, IITR_RANGE &&r, const alloc_t &al)
    : unordered_map_adaptor(from_range, r, base_t::default_bucket_count,
                            HASH{}, EQ{}, al) {}
  template <class IITR_RANGE>
  unordered_map_adaptor(from_range_t, IITR_RANGE &&r, size_type n,
                        const alloc_t &al)
    : unordered_map_adaptor(from_range, r, n, HASH{}, EQ{}, al) {}
  template <class IITR_RANGE>
  unordered_map_adaptor(from_range_t, IITR_RANGE &&r,
                        size_type n, const hasher &hf, const alloc_t &al)
    : unordered_map_adaptor(from_range, r, n, hf, EQ{}, al) {}
  template <class IITR_RANGE, class = enable_if_t
            <is_rng<IITR_RANGE>
             && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
             && !is_same_v<decay_t<IITR_RANGE>, this_t>
             && !is_convertible_v<IITR_RANGE &&, const alloc_t &>>>
  explicit unordered_map_adaptor(IITR_RANGE &&r) {
    base_t::reserve(get_key(), hash(), eq(), base_t::default_bucket_count);
    base_t::insert_range(get_key(), hash(), eq(), r);
  }
  template <class IITR_RANGE, class = enable_if_t
            <is_rng<IITR_RANGE>
             && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
             && !is_same_v<decay_t<IITR_RANGE>, this_t>
             && !is_convertible_v<IITR_RANGE &&, const hasher &>>>
  unordered_map_adaptor(IITR_RANGE &&r, size_type n,
                        const hasher &hf = hasher{},
                        const key_equal &eql = key_equal{},
                        const alloc_t &al = alloc_t{})
    : base_t(al), hash_wrapper(hf), eq_wrapper(eql) {
    base_t::reserve(get_key(), hash(), eq(), n);
    base_t::insert_range(get_key(), hash(), eq(), r);
  }
  template <class IITR_RANGE, class = enable_if_t
            <is_rng<IITR_RANGE>
             && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
             && !is_same_v<decay_t<IITR_RANGE>, this_t>
             && !is_convertible_v<IITR_RANGE &&, const hasher &>>>
  unordered_map_adaptor(IITR_RANGE &&r, const alloc_t &al)
    : unordered_map_adaptor(r, base_t::default_bucket_count,
                            hasher{}, key_equal{}, al) {}
  template <class IITR_RANGE, class = enable_if_t
            <is_rng<IITR_RANGE>
             && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
             && !is_same_v<decay_t<IITR_RANGE>, this_t>
             && !is_convertible_v<IITR_RANGE &&, const hasher &>>>
  unordered_map_adaptor(IITR_RANGE &&r, size_type n, const alloc_t &al)
    : unordered_map_adaptor(r, n, hasher{}, key_equal{}, al) {}
  template <class IITR_RANGE, class = enable_if_t
            <is_rng<IITR_RANGE>
             && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
             && !is_same_v<decay_t<IITR_RANGE>, this_t>
             && !is_convertible_v<IITR_RANGE &&, const hasher &>>>
  unordered_map_adaptor(IITR_RANGE &&r,
                        size_type n, const hasher &hf, const alloc_t &al)
    : unordered_map_adaptor(r, n, hf, key_equal{}, al) {}
  template <class IITR_RANGE>
  enable_if_t<!is_same_v<decay_t<IITR_RANGE>, this_t>
              && is_rng<IITR_RANGE>
              && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
              && is_assignable_v<value_type &, rng_ref<IITR_RANGE>>,
              this_t &>
  operator =(IITR_RANGE &&r) {
    base_t::assign_range(get_key(), hash(), eq(), r);
    return *this;
  }
  template <class IITR_RANGE>
  void assign_range(IITR_RANGE &&r) {
    base_t::assign_range(get_key(), hash(), eq(), r);
  }
  template <class IITR_RANGE>
  void assign(IITR_RANGE &r) {
    assign_range(r);
  }

  template <class IITR_RANGE>
  enable_if_t<!is_convertible_v<IITR_RANGE &&, value_type &&>
              && !is_convertible_v<IITR_RANGE &&, const value_type &>
              && !is_convertible_v<IITR_RANGE &&, node_type &&>>
  insert(IITR_RANGE &&r) {
    base_t::insert_range(get_key(), hash(), eq(), r);
  }
  template <class IITR_RANGE>
  void insert_range(IITR_RANGE &&r) {
    base_t::insert_range(get_key(), hash(), eq(), r);
  }

  this_t &append() {
    return *this;
  }
  template <class X, class...S>
  this_t &append(X &&x, S &&...s) {
    insert(forward<X>(x));
    return append(forward<S>(s)...);
  }
};
template <class TABLE, class HASH, class EQ>
bool operator ==(const unordered_map_adaptor<TABLE, HASH, EQ> &x,
                 const unordered_map_adaptor<TABLE, HASH, EQ> &y) {
  return x.base().equal(x.get_key(), x.hash(), x.eq(), y.hash(), y.eq(), y);
}

template <class TABLE, class HASH, class EQ>
class unordered_multimap_adaptor
  : TABLE, derivable_wrapper<HASH>, derivable_wrapper<EQ> {
  using this_t = unordered_multimap_adaptor;

  using base_t = TABLE;
  const base_t &base() const noexcept {
    return *this;
  }
  base_t &base() noexcept {
    return *this;
  }

  static constexpr bool transparent
    = is_transparent_function_v<HASH> && is_transparent_function_v<EQ>;

public:
  using traits = typename base_t::traits;
  using node_pointer = typename traits::node_base_pointer;

private:
  using hash_wrapper = derivable_wrapper<HASH>;
  using eq_wrapper = derivable_wrapper<EQ>;
  HASH &hash_ref() {
    return *static_cast<hash_wrapper &>(*this);
  }
  const HASH &hash_ref() const {
    return *static_cast<const hash_wrapper &>(*this);
  }
  EQ &eq_ref() {
    return *static_cast<eq_wrapper &>(*this);
  }
  const EQ &eq_ref() const {
    return *static_cast<const eq_wrapper &>(*this);
  }

protected:
  static auto get_key() noexcept {
    return [](const auto &x)->const auto & {
      return traits::key(x);
    };
  }
  auto hash() const noexcept {
    return ref(hash_ref());
  }
  auto eq() const noexcept {
    return ref(eq_ref());
  }

  using alloc_t = typename base_t::allocator_type;

public:
  using pointer = alloc_ptr<alloc_t>;
  using const_pointer = alloc_cptr<alloc_t>;

  // container 

  using value_type = typename base_t::value_type;
  using reference = typename base_t::reference;
  using const_reference = typename base_t::const_reference;

  using iterator = typename base_t::iterator;
  using const_iterator = typename base_t::const_iterator;
  using difference_type = typename base_t::difference_type;
  using size_type = typename base_t::size_type;

  iterator begin() noexcept {
    return base_t::begin();
  }
  iterator end() noexcept {
    return base_t::end();
  }
  const_iterator begin() const noexcept {
    return base_t::begin();
  }
  const_iterator end() const noexcept {
    return base_t::end();
  }
  const_iterator cbegin() const noexcept {
    return base_t::cbegin();
  }
  const_iterator cend() const noexcept {
    return base_t::cend();
  }

  size_type max_size() const noexcept {
    return base_t::max_size();
  }
  size_type size() const noexcept {
    return base_t::size();
  }
  bool empty() const noexcept {
    return base_t::empty();
  }

  unordered_multimap_adaptor() = default;
  ~unordered_multimap_adaptor() = default;
  unordered_multimap_adaptor(const unordered_multimap_adaptor &) = default;
  this_t &operator =(const unordered_multimap_adaptor &) = default;
  unordered_multimap_adaptor(unordered_multimap_adaptor &&) = default;
  this_t &operator =(unordered_multimap_adaptor &&) = default;
  friend void swap(unordered_multimap_adaptor &x,
                   unordered_multimap_adaptor &y)
    noexcept(is_nothrow_swappable_v<base_t>
             && is_nothrow_swappable_v<HASH>
             && is_nothrow_swappable_v<EQ>) {
    adl_swap(x.base(), y.base());
    adl_swap(x.hash_ref(), y.hash_ref());
    adl_swap(x.eq_ref(), y.eq_ref());
  }

  template <class TABLE2, class HASH2, class EQ2>
  friend bool operator ==
  (const unordered_multimap_adaptor<TABLE2, HASH2, EQ2> &,
   const unordered_multimap_adaptor<TABLE2, HASH2, EQ2> &);

  // reversible container

  using reverse_iterator = re::reverse_iterator<iterator>;
  using const_reverse_iterator = re::reverse_iterator<const_iterator>;

  reverse_iterator rbegin() noexcept {
    return reverse_iterator(end());
  }
  reverse_iterator rend() noexcept {
    return reverse_iterator(begin());
  }
  const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator(begin());
  }
  const_reverse_iterator crbegin() const noexcept {
    return rbegin();
  }
  const_reverse_iterator crend() const noexcept {
    return rend();
  }

  // allocator-aware container

  using allocator_type = alloc_t;
  allocator_type get_allocator() const noexcept {
    return base_t::get_allocator();
  }

  explicit unordered_multimap_adaptor(const alloc_t &al) noexcept
    : base_t(al) {}
  unordered_multimap_adaptor(const this_t &x, const alloc_t &al)
    : base_t(x.base(), al)
    , hash_wrapper(x.hash_ref())
    , eq_wrapper(x.eq_ref()) {}
  unordered_multimap_adaptor(this_t &&x, const alloc_t &al)
    : base_t(move(x.base()), al)
    , hash_wrapper(move(x.hash_ref()))
    , eq_wrapper(move(x.eq_ref())) {}

  // unordered associative container

  using key_type = typename traits::key_type;
  using mapped_type = typename traits::mapped_type;
  using hasher = HASH;
  using key_equal = EQ;
  using node_type = inner::map_node_handle<traits>;

  hasher hash_function() const {
    return hash_ref();
  }
  key_equal key_eq() const {
    return eq_ref();
  }

  unordered_multimap_adaptor(const hasher &hf, const key_equal &eql,
                             const alloc_t &al = alloc_t{})
    : base_t(al), hash_wrapper(hf), eq_wrapper(eql) {}
  explicit unordered_multimap_adaptor(size_type n,
                                      const hasher &hf = hasher{},
                                      const key_equal &eql = key_equal{},
                                      const alloc_t &al = alloc_t{})
    : base_t(al), hash_wrapper(hf), eq_wrapper(eql) {
    base_t::reserve(get_key(), hash(), eq(), n);
  }
  unordered_multimap_adaptor(size_type n, const alloc_t &al)
    : unordered_multimap_adaptor(n, hasher{}, key_equal{}, al) {}
  unordered_multimap_adaptor(size_type n, const hasher &hf, const alloc_t &al)
    : unordered_multimap_adaptor(n, hf, key_equal{}, al) {}

  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  unordered_multimap_adaptor(IITR f, IITR l,
                             size_type n = base_t::default_bucket_count,
                             const hasher &hf = hasher{},
                             const key_equal &eql = key_equal{},
                             const alloc_t &al = alloc_t{})
    : base_t(al), hash_wrapper(hf), eq_wrapper(eql) {
    base_t::reserve(get_key(), hash(), eq(), n);
    base_t::insert_range_equal(get_key(), hash(), eq(), rng(f, l));
  }
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  unordered_multimap_adaptor(IITR f, IITR l, const alloc_t &al)
    : unordered_multimap_adaptor(f, l, base_t::default_bucket_count,
                                 HASH{}, EQ{}, al) {}
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  unordered_multimap_adaptor(IITR f, IITR l, size_type n, const alloc_t &al)
    : unordered_multimap_adaptor(f, l, n, HASH{}, EQ{}, al) {}
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  unordered_multimap_adaptor(IITR f, IITR l,
                             size_type n, const hasher &hf, const alloc_t &al)
    : unordered_multimap_adaptor(f, l, n, hf, EQ{}, al) {}
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  void assign(IITR f, IITR l) {
    assign_range(rng(f, l));
  }

  unordered_multimap_adaptor(initializer_list<value_type> il,
                             size_type n = base_t::default_bucket_count,
                             const hasher &hf = hasher{},
                             const key_equal &eql = key_equal{},
                             const alloc_t &al = alloc_t{})
    : base_t(al), hash_wrapper(hf), eq_wrapper(eql) {
    base_t::reserve(get_key(), hash(), eq(), n);
    base_t::insert_range_equal(get_key(), hash(), eq(), il);
  }
  unordered_multimap_adaptor(initializer_list<value_type> il, const alloc_t &al)
    : unordered_multimap_adaptor(il, base_t::default_bucket_count,
                                 hasher{}, key_equal{}, al) {}
  unordered_multimap_adaptor(initializer_list<value_type> il,
                             size_type n, const alloc_t &al)
    : unordered_multimap_adaptor(il, n, hasher{}, key_equal{}, al) {}
  unordered_multimap_adaptor(initializer_list<value_type> il,
                             size_type n, const hasher &hf, const alloc_t &al)
    : unordered_multimap_adaptor(il, n, hf, key_equal{}, al) {}
  unordered_multimap_adaptor &operator =(initializer_list<value_type> il) {
    base_t::assign_range_equal(get_key(), hash(), eq(), il);
    return *this;
  }
  void assign(initializer_list<value_type> il) {
    assign_range(il);
  }

  template <class...S>
  iterator emplace(S &&...s) {
    return base_t::emplace_equal(get_key(), hash(), eq(), forward<S>(s)...);
  }
  template <class...S>
  iterator emplace_hint(const_iterator hint, S &&...s) {
    return base_t::emplace_equal_hint(get_key(), hash(), eq(),
                                      hint.to_mutable(), forward<S>(s)...);
  }
  iterator insert(const value_type &x) {
    return base_t::emplace_equal(get_key(), hash(), eq(), x);
  }
  iterator insert(value_type &&x) {
    return base_t::emplace_equal(get_key(), hash(), eq(), move(x));
  }
  iterator insert(const_iterator hint, const value_type &x) {
    return base_t::emplace_equal_hint(get_key(), hash(), eq(),
                                      hint.to_mutable(), x);
  }
  iterator insert(const_iterator hint, value_type &&x) {
    return base_t::emplace_equal_hint(get_key(), hash(), eq(),
                                      hint.to_mutable(), move(x));
  }
  template <class IITR>
  void insert(IITR from, IITR to) {
    base_t::insert_range_equal(get_key(), hash(), eq(), rng(from, to));
  }
  void insert(initializer_list<value_type> il) {
    base_t::insert_range_equal(get_key(), hash(), eq(), il);
  }

  node_type extract(const_iterator pos) {
    return base_t::template extract<node_type>(pos.to_mutable());
  }
  node_type extract(const key_type &key) {
    return base_t::template extract<node_type>(get_key(), hash(), eq(), key);
  }
  template <class K>
  node_type extract(K &&key)
    requires (transparent
              && !is_convertible_v<K &&, iterator>
              && !is_convertible_v<K &&, const_iterator>) {
    return base_t::template extract<node_type>(get_key(), hash(), eq(), key);
  }

  iterator insert(node_type &&nh) {
    return base_t::template insert_node_handle_equal
      (get_key(), hash(), eq(), move(nh));
  }
  iterator insert(const_iterator hint, node_type &&nh) {
    return base_t::template insert_node_handle_equal
      (get_key(), hash(), eq(), hint.to_mutable(), move(nh));
  }

  iterator erase(const_iterator pos) {
    return base_t::erase(pos.to_mutable());
  }
  iterator erase(const_iterator from, const_iterator to) {
    while (from != to)
      from = erase(from);
    return from.to_mutable();
  }
  void clear() noexcept {
    base_t::clear();
  }

  size_type erase(const key_type &key) {
    return base_t::erase(get_key(), hash(), eq(), key);
  }
  template <class K>
  size_type erase(K &&key)
    requires (transparent
              && !is_convertible_v<K &&, iterator>
              && !is_convertible_v<K &&, const_iterator>) {
    return base_t::erase(get_key(), hash(), eq(), key);
  }

  size_type remove(const key_type &key) {
    if constexpr (traits::store_node_allocator::value) {
      return base_t::erase(get_key(), hash(), eq(), key);
    }
    else {
      return base_t::unlink(get_key(), hash(), eq(), key);
    }
  }
  template <class K>
  size_type remove(const K &key) requires transparent {
    if constexpr (traits::store_node_allocator::value) {
      return base_t::erase(get_key(), hash(), eq(), key);
    }
    else {
      return base_t::unlink(get_key(), hash(), eq(), key);
    }
  }
  template <class UF>
  size_type remove_if(UF eq) {
    size_type ret = 0;
    for (iterator it = begin(); it != end();) {
      if (eq(*it)) {
        it = erase_or_unlink(it);
        ++ret;
      }
      else
        ++it;
    }
    return ret;
  }

  template <class HASH2, class EQ2>
  void merge(unordered_map_adaptor<base_t, HASH2, EQ2> &x) {
    base_t::merge_equal(get_key(), hash(), eq(), x.base());
  }
  template <class HASH2, class EQ2>
  void merge(unordered_map_adaptor<base_t, HASH2, EQ2> &&x) {
    base_t::merge_equal(get_key(), hash(), eq(), x.base());
  }
  template <class HASH2, class EQ2>
  void merge(unordered_multimap_adaptor<base_t, HASH2, EQ2> &x) {
    base_t::merge_equal(get_key(), hash(), eq(), x.base());
  }
  template <class HASH2, class EQ2>
  void merge(unordered_multimap_adaptor<base_t, HASH2, EQ2> &&x) {
    base_t::merge_equal(get_key(), hash(), eq(), x.base());
  }

  iterator find(const key_type &key) {
    return base_t::find(get_key(), hash(), eq(), key);
  }
  template <class K>
  iterator find(const K &key) requires transparent {
    return base_t::find(get_key(), hash(), eq(), key);
  }
  const_iterator find(const key_type &key) const {
    return base_t::find(get_key(), hash(), eq(), key);
  }
  template <class K>
  const_iterator find(const K &key) const requires transparent {
    return base_t::find(get_key(), hash(), eq(), key);
  }

  bool contains(const key_type &key) const {
    return find(key) != end();
  }
  template <class K>
  bool contains(const K &key) const requires transparent {
    return find(key) != end();
  }

  size_type count(const key_type &key) const {
    return base_t::count(get_key(), hash(), eq(), key);
  }
  template <class K>
  size_type count(const K &key) const requires transparent {
    return base_t::count(get_key(), hash(), eq(), key);
  }

  iter_pair<iterator> equal_range(const key_type &key) {
    return base_t::equal_range(get_key(), hash(), eq(), key);
  }
  template <class K>
  iter_pair<iterator> equal_range(const K &key) requires transparent {
    return base_t::equal_range(get_key(), hash(), eq(), key);
  }
  iter_pair<const_iterator> equal_range(const key_type &key) const {
    return base_t::equal_range(get_key(), hash(), eq(), key);
  }
  template <class K>
  iter_pair<const_iterator> equal_range(const K &key) const
    requires transparent {
    return base_t::equal_range(get_key(), hash(), eq(), key);
  }

  size_type bucket_count() const noexcept {
    return base_t::bucket_count();
  }
  size_type active_bucket_count() const noexcept {
    return base_t::active_bucket_count();
  }
  size_type max_bucket_count() const noexcept {
    return base_t::max_bucket_count();
  }
  size_type bucket_size(size_type n) const {
    return base_t::bucket_size(n);
  }
  size_type bucket(const key_type &k) const {
    return base_t::bucket(hash(), k);
  }

  using local_iterator = typename base_t::local_iterator;
  using const_local_iterator = typename base_t::const_local_iterator;

  local_iterator begin(size_type n) noexcept {
    return base_t::begin(n);
  }
  local_iterator end(size_type n) noexcept {
    return base_t::end(n);
  }
  const_local_iterator begin(size_type n) const noexcept {
    return base_t::begin(n);
  }
  const_local_iterator end(size_type n) const noexcept {
    return base_t::end(n);
  }
  const_local_iterator cbegin(size_type n) const noexcept {
    return begin(n);
  }
  const_local_iterator cend(size_type n) const noexcept {
    return end(n);
  }

  iter_pair<local_iterator> bucket_range(size_type n) {
    return base_t::bucket_range(n);
  }
  iter_pair<const_local_iterator> bucket_range(size_type n) const {
    return base_t::bucket_range(n);
  }

  float load_factor() const noexcept {
    return base_t::load_factor();
  }
  float max_load_factor() const noexcept {
    return base_t::max_load_factor();
  }
  void max_load_factor(float f) {
    base_t::max_load_factor(f);
  }
  void rehash(size_type n) {
    base_t::rehash(get_key(), hash(), eq(), n);
  }
  void reserve(size_type n) {
    base_t::reserve(get_key(), hash(), eq(), n);
  }

  // extensions

  template <class...S>
  iterator new_node(S &&...s) {
    return base_t::new_node(forward<S>(s)...);
  }
  void delete_node(const_iterator it) noexcept {
    base_t::delete_node(it.to_mutable());
  }

  iterator unlink(const_iterator it) noexcept {
    return base_t::unlink(it.to_mutable());
  }
  iterator unlink(const_iterator from, const_iterator to) noexcept {
    return base_t::unlink(from.to_mutable(), to.to_mutable());
  }
  void unlink() noexcept {
    base_t::unlink();
  }
  size_type unlink_key(const key_type &key) {
    return base_t::unlink(get_key(), hash(), eq(), key);
  }
  template <class K>
  size_type unlink_key(const K &key) requires transparent {
    return base_t::unlink(get_key(), hash(), eq(), key);
  }
  iterator link(const_iterator it) {
    return base_t::link_equal(get_key(), hash(), eq(), it.to_mutable());
  }
  iterator link(const_iterator hint, const_iterator it) {
    return base_t::link_equal(get_key(), hash(), eq(), hint.to_mutable(),
                              it.to_mutable());
  }

  template <class K, class GET_NODE>
  iterator try_link(const K &key, GET_NODE get_node) {
    return base_t::insert_equal(get_key(), hash(), eq(), key, get_node);
  }
  template <class K, class GET_NODE>
  iterator try_link_hint(const_iterator hint,
                         const K &key, GET_NODE get_node) {
    return base_t::insert_equal(get_key(), hash(), eq(),
                                hint.to_mutable(), key, get_node);
  }

  template <bool Y = traits::store_node_allocator::value>
  enable_if_t<Y, iterator> erase_or_unlink(const_iterator it) noexcept {
    return erase(it);
  }
  template <bool Y = traits::store_node_allocator::value>
  enable_if_t<!Y, iterator> erase_or_unlink(const_iterator it) noexcept {
    return unlink(it);
  }

  void unique() {
    list_unique(*this, bind(eq(), bind(get_key(), _1), bind(get_key(), _2)),
                [this](auto it) {return erase_or_unlink(it);});
  };
  template <class EQL>
  void unique(EQL eql) {
    list_unique(*this, eql, [this](auto it) {return erase_or_unlink(it);});
  };

  template <class IITR_RANGE>
  unordered_multimap_adaptor(from_range_t, IITR_RANGE &&r,
                             size_type n = base_t::default_bucket_count,
                             const hasher &hf = hasher{},
                             const key_equal &eql = key_equal{},
                             const alloc_t &al = alloc_t{})
    : base_t(al), hash_wrapper(hf), eq_wrapper(eql) {
    base_t::reserve(get_key(), hash(), eq(), n);
    insert_range(r);
  }
  template <class IITR_RANGE>
  unordered_multimap_adaptor(from_range_t, IITR_RANGE &&r, const alloc_t &al)
    : unordered_multimap_adaptor(from_range, r, base_t::default_bucket_count,
                                 HASH{}, EQ{}, al) {}
  template <class IITR_RANGE>
  unordered_multimap_adaptor(from_range_t, IITR_RANGE &&r, size_type n,
                             const alloc_t &al)
    : unordered_multimap_adaptor(from_range, r, n, HASH{}, EQ{}, al) {}
  template <class IITR_RANGE>
  unordered_multimap_adaptor(from_range_t, IITR_RANGE &&r,
                             size_type n, const hasher &hf, const alloc_t &al)
    : unordered_multimap_adaptor(from_range, r, n, hf, EQ{}, al) {}
  template <class IITR_RANGE, class = enable_if_t
            <is_rng<IITR_RANGE>
             && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
             && !is_same_v<decay_t<IITR_RANGE>, this_t>
             && !is_convertible_v<IITR_RANGE &&, const alloc_t &>>>
  explicit unordered_multimap_adaptor(IITR_RANGE &&r) {
    base_t::reserve(get_key(), hash(), eq(), base_t::default_bucket_count);
    base_t::insert_range_equal(get_key(), hash(), eq(), r);
  }
  template <class IITR_RANGE, class = enable_if_t
            <is_rng<IITR_RANGE>
             && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
             && !is_same_v<decay_t<IITR_RANGE>, this_t>
             && !is_convertible_v<IITR_RANGE &&, const hasher &>>>
  unordered_multimap_adaptor(IITR_RANGE &&r, size_type n,
                             const hasher &hf = hasher{},
                             const key_equal &eql = key_equal{},
                             const alloc_t &al = alloc_t{})
    : base_t(al), hash_wrapper(hf), eq_wrapper(eql) {
    base_t::reserve(get_key(), hash(), eq(), n);
    base_t::insert_range_equal(get_key(), hash(), eq(), r);
  }
  template <class IITR_RANGE, class = enable_if_t
            <is_rng<IITR_RANGE>
             && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
             && !is_same_v<decay_t<IITR_RANGE>, this_t>
             && !is_convertible_v<IITR_RANGE &&, const hasher &>>>
  unordered_multimap_adaptor(IITR_RANGE &&r, const alloc_t &al)
    : unordered_multimap_adaptor(r, base_t::default_bucket_count,
                                 hasher{}, key_equal{}, al) {}
  template <class IITR_RANGE, class = enable_if_t
            <is_rng<IITR_RANGE>
             && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
             && !is_same_v<decay_t<IITR_RANGE>, this_t>
             && !is_convertible_v<IITR_RANGE &&, const hasher &>>>
  unordered_multimap_adaptor(IITR_RANGE &&r, size_type n, const alloc_t &al)
    : unordered_multimap_adaptor(r, n, hasher{}, key_equal{}, al) {}
  template <class IITR_RANGE, class = enable_if_t
            <is_rng<IITR_RANGE>
             && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
             && !is_same_v<decay_t<IITR_RANGE>, this_t>
             && !is_convertible_v<IITR_RANGE &&, const hasher &>>>
  unordered_multimap_adaptor(IITR_RANGE &&r,
                             size_type n, const hasher &hf, const alloc_t &al)
    : unordered_multimap_adaptor(r, n, hf, key_equal{}, al) {}
  template <class IITR_RANGE>
  enable_if_t<!is_same_v<decay_t<IITR_RANGE>, this_t>
              && is_rng<IITR_RANGE>
              && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
              && is_assignable_v<value_type &, rng_ref<IITR_RANGE>>, this_t &>
  operator =(IITR_RANGE &&r) {
    base_t::assign_range_equal(get_key(), hash(), eq(), r);
    return *this;
  }
  template <class IITR_RANGE>
  void assign_range(IITR_RANGE &&r) {
    base_t::assign_range_equal(get_key(), hash(), eq(), r);
  }
  template <class IITR_RANGE>
  void assign(IITR_RANGE &r) {
    assign_range(r);
  }

  template <class IITR_RANGE>
  enable_if_t<!is_convertible_v<IITR_RANGE &&, value_type &&>
              && !is_convertible_v<IITR_RANGE &&, const value_type &>
              && !is_convertible_v<IITR_RANGE &&, node_type &&>>
  insert(IITR_RANGE &&r) {
    base_t::insert_range_equal(get_key(), hash(), eq(), r);
  }
  template <class IITR_RANGE>
  void insert_range(IITR_RANGE &&r) {
    base_t::insert_range_equal(get_key(), hash(), eq(), r);
  }

  this_t &append() {
    return *this;
  }
  template <class X, class...S>
  this_t &append(X &&x, S &&...s) {
    insert(forward<X>(x));
    return append(forward<S>(s)...);
  }
};
template <class TABLE, class HASH, class EQ>
bool operator ==(const unordered_multimap_adaptor<TABLE, HASH, EQ> &x,
                 const unordered_multimap_adaptor<TABLE, HASH, EQ> &y) {
  return x.base().equal_equal(x.get_key(), x.hash(), x.eq(), y.hash(), y.eq(),
                              y);
}

}
// unordered_(set/map/multiset/multimap)
namespace re {

template <class T, class AL>
struct htbt
  : hashtable_traits<hashtable_node<T, alloc_void_ptr<AL>>, 0, 1, AL> {};
template <class T, class AL>
class hsett : public htbt<T, AL> {
  using base_t = htbt<T, AL>;

public:
  using key_type = typename base_t::value_type;

  static const key_type &key(const typename base_t::value_type &x) {
    return x;
  }
};
template <class T, class AL>
class hmapt : public htbt<T, AL> {
  using base_t = htbt<T, AL>;

public:
  using key_type = typename base_t::value_type::first_type;
  using mapped_type = typename base_t::value_type::second_type;

  static const key_type &key(const typename base_t::value_type &x) {
    return x.first;
  }
  static mapped_type &mapped(typename base_t::value_type &x) {
    return x.second;
  }
  static const mapped_type &mapped(const typename base_t::value_type &x) {
    return x.second;
  }
};
template <class T, class AL = default_allocator<T>>
using hashtable = hashtable_adaptor<htbt<T, AL>>;
template <class KEY,
          class HASH = hash<KEY>, class EQ = equal_to<KEY>,
          class AL = default_allocator<KEY>>
using unordered_set = unordered_set_adaptor<hashtable_adaptor<hsett<KEY, AL>>,
                                            HASH, EQ>;
template <class KEY, class MAPPED,
          class HASH = hash<KEY>, class EQ = equal_to<KEY>,
          class AL = default_allocator<pair<KEY, MAPPED>>>
using unordered_map = unordered_map_adaptor<hashtable_adaptor
                                            <hmapt<pair<KEY, MAPPED>, AL>>,
                                            HASH, EQ>;
template <class KEY,
          class HASH = hash<KEY>, class EQ = equal_to<KEY>,
          class AL = default_allocator<KEY>>
using unordered_multiset = unordered_multiset_adaptor
  <hashtable_adaptor<hsett<KEY, AL>>, HASH, EQ>;
template <class KEY, class MAPPED,
          class HASH = hash<KEY>, class EQ = equal_to<KEY>,
          class AL = default_allocator<pair<KEY, MAPPED>>>
using unordered_multimap
  = unordered_multimap_adaptor<hashtable_adaptor<hmapt<pair<KEY, MAPPED>, AL>>,
                               HASH, EQ>;

}

// mixed_(set/map/multiset/multimap)_adaptor
namespace re {

namespace inner {

template <class TRAITS>
struct mxd_set_traits : TRAITS {
  using key_type = typename TRAITS::value_type;

  static const key_type &key(const key_type &x) {
    return x;
  }
};
template <class TRAITS>
struct mxd_map_traits : TRAITS {
  using key_type = typename TRAITS::value_type::first_type;
  using mapped_type = typename TRAITS::value_type::second_type;

  static const key_type &key(const typename TRAITS::value_type &x) {
    return x.first;
  }
  static mapped_type &mapped(typename TRAITS::value_type &x) {
    return x.second;
  }
  static const mapped_type &mapped(const typename TRAITS::value_type &x) {
    return x.second;
  }
};

}

template <class T, class AL>
struct mixed_container_node
  : join_avltree<0, alloc_void_ptr<AL>>
  , join_hashtable<0, alloc_void_ptr<AL>> {
  alignas(T) byte data[sizeof(T)];

  T &operator *() const {
    return *reinterpret_cast<T *>(addressof(data));
  }
  T *operator ->() const {
    return reinterpret_cast<T *>(addressof(data));
  }
};
template <class T, class AL>
struct mxdsett {
  struct tree_traits
    : inner::mxd_set_traits<avltree_traits
                            <mixed_container_node<T, AL>, 0, 0, 0, AL>> {};
  struct hashtable_traits
    : inner::mxd_set_traits<re::hashtable_traits
                            <mixed_container_node<T, AL>, 0, 1, AL>> {};
  using tree = avltree_adaptor<tree_traits>;
  using hashtable = re::hashtable_adaptor<hashtable_traits>;
};
template <class T, class AL>
struct mxdmapt {
  struct tree_traits
    : inner::mxd_map_traits<avltree_traits
                            <mixed_container_node<T, AL>, 0, 0, 0, AL>> {};
  struct hashtable_traits
    : inner::mxd_map_traits<re::hashtable_traits
                            <mixed_container_node<T, AL>, 0, 1, AL>> {};
  using tree = avltree_adaptor<tree_traits>;
  using hashtable = re::hashtable_adaptor<hashtable_traits>;
};

template <class T, class AL>
struct mixed_ranked_container_node
  : join_ranked_rbtree<0, alloc_void_ptr<AL>>
  , join_hashtable<0, alloc_void_ptr<AL>> {
  alignas(T) byte data[sizeof(T)];

  T &operator *() const {
    return *reinterpret_cast<T *>(addressof(data));
  }
  T *operator ->() const {
    return reinterpret_cast<T *>(addressof(data));
  }
};
template <class T, class AL>
struct mxdrkdsett {
  struct tree_traits
    : inner::mxd_set_traits<ranked_rbtree_traits
                            <mixed_ranked_container_node<T, AL>, 0, 0, AL>> {};
  struct hashtable_traits
    : inner::mxd_set_traits<re::hashtable_traits
                            <mixed_ranked_container_node<T, AL>, 0, 1, AL>> {};
  using tree = ranked_rbtree_adaptor<tree_traits>;
  using hashtable = re::hashtable_adaptor<hashtable_traits>;
};
template <class T, class AL>
struct mxdrkdmapt {
  struct tree_traits
    : inner::mxd_map_traits<ranked_rbtree_traits
                            <mixed_ranked_container_node<T, AL>, 0, 0, AL>> {};
  struct hashtable_traits
    : inner::mxd_map_traits<re::hashtable_traits
                            <mixed_ranked_container_node<T, AL>, 0, 1, AL>> {};
  using tree = ranked_rbtree_adaptor<tree_traits>;
  using hashtable = re::hashtable_adaptor<hashtable_traits>;
};

namespace inner {

struct mixed_helper {
  template <class T>
  static void swap(T &x, T &y) {
    if constexpr (T::traits::hashtable_traits::store_node_allocator::value
                  && !alloc_swap_prpg<typename T::allocator_type>
                  && !alloc_always_equal<typename T::allocator_type>) {
      if (x.unordered().get_allocator() != y.unordered().get_allocator()) {
        auto guard = exit_fn([&]() {
          x.unordered().clear();
          y.unordered().clear();
          x.tree().unlink();
          y.tree().unlink();
        }, true);

        adl_swap(x.unordered(), y.unordered());

        using tree_t = typename T::tree_type;
        const auto cmp = y.tree().key_comp();
        y.tree() = tree_t(x.tree().key_comp());
        x.tree() = tree_t(cmp);

        for (auto &i : iters(x.unordered()))
          x.tree().link(x.no_ed_tree_iter(i));
        for (auto &i : iters(y.unordered()))
          y.tree().link(y.no_ed_tree_iter(i));
        guard.unset();
      }
      else {
        adl_swap(x.unordered(), y.unordered());
        adl_swap(x.tree(), y.tree());
      }
    }
    else {
      adl_swap(x.unordered(), y.unordered());
      adl_swap(x.tree(), y.tree());
    }
  }

  template <class T>
  static void move_construct_impl(T &t, T &x,
                                  const typename T::allocator_type &al) {
    if constexpr (!T::traits::hashtable_traits
                  ::store_node_allocator::value) {
      t.tree() = move(x.tree());
    }
    else {
      if (x.get_allocator() != al) {
        x.tree().unlink();
        t.tree() = static_cast<typename T::tree_type>(x.tree().key_comp());
        t.try_link_to_tree();
      }
      else {
        t.tree() = move(x.tree());
      }
    }
  }

  template <class T, class K, class GET_NODE, class DO_WHEN_EQ = empty_function>
  static pair<typename T::iterator, bool>
  set_try_link(T &t, const K &key,
               GET_NODE get_node,
               DO_WHEN_EQ do_when_eq = DO_WHEN_EQ{}) {
    const auto x = t.unordered().try_link
      (key,
       [&]() {
         return T::no_ed_unordered_iter(t.tree().try_link(key, get_node).first);
       },
       [&](auto it) {do_when_eq(T::no_ed_tree_iter(it));});
    return {T::no_ed_tree_iter(x.first), x.second};
  }
  template <class T, class K, class GET_NODE, class DO_WHEN_EQ = empty_function>
  static typename T::iterator
  set_try_link_hint(T &t, typename T::const_iterator hint, const K &key,
                    GET_NODE get_node,
                    DO_WHEN_EQ do_when_eq = DO_WHEN_EQ{}) {
    return T::no_ed_tree_iter
      (t.unordered().try_link
       (key,
        [&]() {
          return T::no_ed_unordered_iter
            (t.tree().try_link_hint(hint, key, get_node));
        },
        [&](auto it) {do_when_eq(T::no_ed_tree_iter(it));}).first);
  }

  template <class T, class K, class GET_NODE>
  static typename T::iterator multiset_try_link(T &t, const K &key,
                                                GET_NODE get_node) {
    return T::no_ed_tree_iter
      (t.unordered().try_link
       (key,
        [&]() {
          return T::no_ed_unordered_iter(t.tree().try_link(key, get_node));
        }));
  }
  template <class T, class K, class GET_NODE>
  static typename T::iterator multiset_try_link_hint
    (T &t, typename T::const_iterator hint,
     const K &key, GET_NODE get_node) {
    return T::no_ed_tree_iter
      (t.unordered().try_link_hint
       (t.unordered_iter(hint),
        key,
        [&]() {
          return T::no_ed_unordered_iter
            (t.tree().try_link_hint(hint, key, get_node));
        }));
  }

  template <class T, class...S>
  static pair<typename T::iterator, bool> set_emplace(T &t, S &&...s) {
    const auto it = t.new_node(forward<S>(s)...);
#ifndef RE_NOEXCEPT
    try {
#endif
      return set_try_link(t, t.get_key()(*it),
                          [it]() {return it;},
                          [it, &t](auto) {t.delete_node(it);});
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      t.delete_node(it);
      throw;
    }
#endif
  }
  template <class T, class...S>
  static typename T::iterator
  set_emplace_hint(T &t, typename T::const_iterator hint, S &&...s) {
    const auto it = t.new_node(forward<S>(s)...);
#ifndef RE_NOEXCEPT
    try {
#endif
      return set_try_link_hint(t, hint, t.get_key()(*it),
                               [it]() {return it;},
                               [it, &t](auto) {t.delete_node(it);});
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      t.delete_node(it);
      throw;
    }
#endif
  }

  template <class T, class...S>
  static typename T::iterator multiset_emplace(T &t, S &&...s) {
    const auto it = t.new_node(forward<S>(s)...);
#ifndef RE_NOEXCEPT
    try {
#endif
      return multiset_try_link(t, t.get_key()(*it), [it]() {return it;});
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      t.delete_node(it);
      throw;
    }
#endif
  }
  template <class T, class...S>
  static typename T::iterator multiset_emplace_hint
    (T &t, typename T::const_iterator hint, S &&...s) {
    const auto it = t.new_node(forward<S>(s)...);
#ifndef RE_NOEXCEPT
    try {
#endif
      return multiset_try_link_hint(t, hint, t.get_key()(*it),
                                    [it]() {return it;});
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      t.delete_node(it);
      throw;
    }
#endif
  }

  template <class T, class X>
  static pair<typename T::iterator, bool> set_insert(T &t, X &&x) {
    return set_try_link(t, t.get_key()(x),
                        [&]() {return t.new_node(forward<X>(x));});
  }
  template <class T, class X>
  static typename T::iterator multiset_insert(T &t, X &&x) {
    return multiset_try_link(t, t.get_key()(x),
                             [&]() {return t.new_node(forward<X>(x));});
  }

  template <class T, class X>
  static typename T::iterator
  set_insert_hint(T &t, typename T::const_iterator hint, X &&x) {
    return set_try_link_hint(t, hint, t.get_key()(x),
                             [&]() {return t.new_node(forward<X>(x));});
  }
  template <class T, class X>
  static typename T::iterator
  multiset_insert_hint(T &t, typename T::const_iterator hint, X &&x) {
    return multiset_try_link_hint(t, hint, t.get_key()(x),
                                  [&]() {return t.new_node(forward<X>(x));});
  }

  template <class T, class X>
  static pair<typename T::iterator, bool>
  set_insert_transparent(T &t, typename T::const_iterator hint, X &&x) {
    return set_try_link(t, x, [&]() {return t.new_node(forward<X>(x));});
  }
  template <class T, class X>
  static typename T::iterator
  set_insert_hint_transparent(T &t, typename T::const_iterator hint,
                              X &&x) {
    return set_try_link_hint(t, hint, x,
                             [&]() {return t.new_node(forward<X>(x));});
  }

  template <class T, class K>
  static typename T::node_type extract_key(T &t, const K &key) {
    using tree_nh_t = typename T::tree_type::node_type;
    using unordered_nh_t = typename T::unordered_type::node_type;
    unordered_nh_t x = t.unordered().extract(key);
    if (!x.empty()) {
      tree_nh_t ret(static_cast<typename T::actual_node_pointer>(x.release()),
                    t.get_allocator());
      t.tree().unlink(static_cast<typename T::iterator>(ret.get()));
      return ret;
    }
    else
      return typename T::node_type{};
  }

  template <class T>
  static typename T::insert_return_type
  set_insert_node(T &t, typename T::node_type &&nh) {
    typename T::insert_return_type ret;
    if (nh.empty()) {
      ret.position = t.tree().end();
      ret.inserted = false;
    }
    else {
      tie(ret.position, ret.inserted)
        = set_try_link
        (t,
         t.get_key()(*static_cast<typename T::iterator>
                     (static_cast<typename T::actual_node_pointer>(nh.get()))),
         [&]() {
           return static_cast<typename T::iterator>
             (static_cast<typename T::actual_node_pointer>(nh.release()));
         });
      ret.node = move(nh);
    }
    return ret;
  }
  template <class T>
  static typename T::iterator
  set_insert_node_hint(T &t, typename T::const_iterator hint,
                       typename T::node_type &&nh) {
    return nh.empty()
      ? t.tree().end()
      : set_try_link_hint
      (t, hint,
       t.get_key()(*static_cast<typename T::iterator>
                   (static_cast<typename T::actual_node_pointer>(nh.get()))),
       [&]() {
         return static_cast<typename T::iterator>
           (static_cast<typename T::actual_node_pointer>(nh.release()));
       });
  }

  template <class T>
  static typename T::iterator
  multiset_insert_node(T &t, typename T::node_type &&nh) {
    return nh.empty()
      ? t.end()
      : multiset_try_link
      (t,
       t.get_key()
       (*static_cast<typename T::iterator>
        (static_cast<typename T::actual_node_pointer>(nh.get()))),
       [&]() {
         return static_cast<typename T::iterator>
           (static_cast<typename T::actual_node_pointer>
            (nh.release()));
       });
  }
  template <class T>
  static typename T::iterator
  multiset_insert_node_hint(T &t, typename T::const_iterator hint,
                            typename T::node_type &&nh) {
    return nh.empty()
      ? t.end()
      : multiset_try_link_hint
      (t, hint,
       t.get_key()(*static_cast<typename T::iterator>
                   (static_cast<typename T::actual_node_pointer>(nh.get()))),
       [&]() {
         return static_cast<typename T::iterator>
           (static_cast<typename T::actual_node_pointer>(nh.release()));
       });
  }

  template <class T, class K>
  static typename T::size_type set_erase_key(T &x, const K &key) {
    const auto it = x.unordered().find(key);
    if (it == x.unordered().end())
      return 0;
    x.tree().unlink(x.no_ed_tree_iter(it));
    x.unordered().erase(it);
    return 1;
  }
  template <class T, class K>
  static typename T::size_type multiset_erase_key(T &x, const K &key) {
    typename T::size_type ret = 0;
    for_each_node(x.unordered().equal_range(key), next, [&](auto it) {
      x.tree().unlink(x.no_ed_tree_iter(it));
      x.unordered().erase(it);
      ++ret;
    });
    return ret;
  }

  template <class T, class K>
  static typename T::size_type set_remove_key(T &x, const K &key) {
    const auto it = x.unordered().find(key);
    if (it == x.unordered().end())
      return 0;
    x.tree().unlink(x.no_ed_tree_iter(it));
    x.unordered().erase_or_unlink(it);
    return 1;
  }
  template <class T, class K>
  static typename T::size_type multiset_remove_key(T &x, const K &key) {
    typename T::size_type ret = 0;
    for_each_node(x.unordered().equal_range(key), next, [&](auto it) {
      x.tree().unlink(x.no_ed_tree_iter(it));
      x.unordered().erase_or_unlink(it);
      ++ret;
    });
    return ret;
  }

  template <class T, class UF>
  static typename T::size_type remove_if(T &x, UF eq) {
    typename T::size_type ret = 0;
    for (typename T::iterator it = x.begin(); it != x.end();) {
      if (eq(*it)) {
        it = x.erase_or_unlink(it);
        ++ret;
      }
      else
        ++it;
    }
    return ret;
  }

  template <class T, class K>
  static iter_pair<rng_itr<T>> equal_range(T &t, const K &key) {
    const auto x = t.unordered().equal_range(key);
    if (empty(x))
      return {t.end(), t.end()};
    else
      return {
        T::no_ed_tree_iter(x.first),
        next(T::no_ed_tree_iter(prev(x.second)))
      };
  }

  template <class T, class K>
  static typename T::size_type set_unlink_key(T &t, const K &key) {
    const auto it = t.unordered().find(key);
    if (it == t.unordered().end())
      return 0u;
    t.unordered().unlink(it);
    t.tree().unlink(T::no_ed_tree_iter(it));
    return 1u;
  }
  template <class T, class K>
  static typename T::size_type multiset_unlink_key(T &t, const K &key) {
    typename T::size_type ret = 0;
    for_each_node(t.unordered().equal_range(key), next, [&](auto it) {
      t.unordered().unlink(it);
      t.tree().unlink(T::no_ed_tree_iter(it));
      ++ret;
    });
    return ret;
  }
};

}

template <class TRAITS, class HASH, class EQ, class LESS>
class mixed_set_adaptor;
template <class TRAITS, class HASH, class EQ, class LESS>
class mixed_map_adaptor;
template <class TRAITS, class HASH, class EQ, class LESS>
class mixed_multiset_adaptor;
template <class TRAITS, class HASH, class EQ, class LESS>
class mixed_multimap_adaptor;

template <class TRAITS, class HASH, class EQ, class LESS>
class mixed_set_adaptor
  : unordered_set_adaptor<typename TRAITS::hashtable, HASH, EQ>
  , set_adaptor<typename TRAITS::tree, LESS> {
  friend struct inner::mixed_helper;

  template <class R>
  static auto begin(R &&r) requires is_rng<R> {return re::begin(r);}
  template <class R>
  static auto end(R &&r) requires is_rng<R> {return re::end(r);}
  template <class R>
  static auto rbegin(R &&r) {return re::rbegin(r);}
  template <class R>
  static auto rend(R &&r) {return re::rend(r);}
  template <class R>
  static auto size(R &&r) {return re::size(r);}
  template <class R>
  static auto empty(R &&r) {return re::empty(r);}

  using this_t = mixed_set_adaptor;
  using unordered_t
    = unordered_set_adaptor<typename TRAITS::hashtable, HASH, EQ>;
  using tree_t = set_adaptor<typename TRAITS::tree, LESS>;

  using alloc_t = typename unordered_t::allocator_type;
  static_assert(is_same_v
                <typename unordered_t::allocator_type,
                 typename tree_t::allocator_type>);

  static constexpr bool transparent
    = is_transparent_function_v<HASH> && is_transparent_function_v<EQ>
    && is_transparent_function_v<LESS>;

  using actual_node_pointer = typename tree_t::traits::node_pointer;

  using tree_t::get_key;
  using tree_t::key_less;
  using unordered_t::hash;
  using unordered_t::eq;

public:
  using tree_iterator = typename tree_t::iterator;
  using tree_const_iterator = typename tree_t::const_iterator;
  using unordered_iterator = typename unordered_t::iterator;
  using unordered_const_iterator = typename unordered_t::const_iterator;

  static auto no_ed_unordered_iter(tree_const_iterator it) noexcept {
    return unordered_iterator(static_cast<actual_node_pointer>(it.node()));
  }
  static auto no_ed_unordered_iter(unordered_const_iterator it) noexcept {
    return unordered_iterator(it.node());
  }
  static auto no_ed_tree_iter(unordered_const_iterator it) noexcept {
    return tree_iterator(static_cast<actual_node_pointer>(it.node()));
  }
  static auto no_ed_tree_iter(tree_const_iterator it) noexcept {
    return tree_iterator(it.node());
  }

  auto unordered_iter(tree_iterator it) const noexcept {
    return it == tree().end()
      ? unordered().end().to_mutable()
      : no_ed_unordered_iter(it);
  }
  auto unordered_iter(tree_const_iterator it) const noexcept {
    return it == tree().end()
      ? unordered().end()
      : unordered_const_iterator(no_ed_unordered_iter(it));
  }
  auto unordered_iter(unordered_iterator it) const noexcept {
    return it;
  }
  auto unordered_iter(unordered_const_iterator it) const noexcept {
    return it;
  }
  auto tree_iter(unordered_iterator it) const noexcept {
    return it == unordered().end()
      ? tree().end().to_mutable()
      : no_ed_tree_iter(it);
  }
  auto tree_iter(unordered_const_iterator it) const noexcept {
    return it == unordered().end()
      ? tree().end()
      : tree_const_iterator(no_ed_tree_iter(it));
  }
  auto tree_iter(tree_iterator it) const noexcept {
    return it;
  }
  auto tree_iter(tree_const_iterator it) const noexcept {
    return it;
  }

private:
  void link_to_tree() {
    for (auto &i : iters(unordered()))
      tree().link(no_ed_tree_iter(i));
  }
  void try_link_to_tree() {
#ifndef RE_NOEXCEPT
    try {
#endif
      for (auto &i : iters(unordered()))
        tree().link(no_ed_tree_iter(i));
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      unordered().clear();
      tree().unlink();
      throw;
    }
#endif
  }

public:
  using traits = TRAITS;
  using node_pointer = typename tree_t::node_pointer;
  using tree_type = tree_t;
  using unordered_type = unordered_t;
  tree_t &tree() noexcept {
    return *this;
  }
  const tree_t &tree() const noexcept {
    return *this;
  }
  unordered_t &unordered() noexcept {
    return *this;
  }
  const unordered_t &unordered() const noexcept {
    return *this;
  }

  using pointer = typename tree_t::pointer;
  using const_pointer = typename tree_t::const_pointer;

  // container

  using value_type = typename tree_t::value_type;
  using reference = typename tree_t::reference;
  using const_reference = typename tree_t::const_reference;

  using iterator = typename tree_t::iterator;
  using const_iterator = typename tree_t::const_iterator;
  using difference_type = typename tree_t::difference_type;
  using size_type = typename tree_t::size_type;

  iterator begin() noexcept {
    return tree().begin();
  }
  iterator end() noexcept {
    return tree().end();
  }
  const_iterator begin() const noexcept {
    return tree().begin();
  }
  const_iterator end() const noexcept {
    return tree().end();
  }
  const_iterator cbegin() const noexcept {
    return tree().begin();
  }
  const_iterator cend() const noexcept {
    return tree().end();
  }

  size_type max_size() const noexcept {
    return tree().max_size();
  }
  size_type size() const noexcept {
    return unordered().size();
  }
  bool empty() const noexcept {
    return tree().empty();
  }

  mixed_set_adaptor() = default;
  ~mixed_set_adaptor() = default;
  mixed_set_adaptor(const mixed_set_adaptor &) = delete;
  mixed_set_adaptor &operator =(const mixed_set_adaptor &) = delete;
  mixed_set_adaptor(const mixed_set_adaptor &x)
    requires is_copy_constructible_v<unordered_t>
    : unordered_t(x.unordered()) {
    link_to_tree();
  }
  mixed_set_adaptor &operator =(const mixed_set_adaptor &x)
    requires is_copy_assignable_v<unordered_t> {
    if (this != addressof(x)) {
      unordered() = x.unordered();
      tree() = tree_t(x.tree().key_comp());
      try_link_to_tree();
    }
    return *this;
  }
  mixed_set_adaptor(mixed_set_adaptor &&x) = default;
  mixed_set_adaptor &operator =(mixed_set_adaptor &&x)
    noexcept(is_nothrow_move_assignable_v<unordered_t>) {
    if constexpr (!TRAITS::hashtable_traits::store_node_allocator::value) {
      unordered() = move(x.unordered());
      tree() = move(x.tree());
      return *this;
    }
    else {
      const allocator_type x_al = x.unordered().get_allocator();
      unordered() = move(x.unordered());
      if (unordered().get_allocator() != x_al
          && !alloc_move_prpg<allocator_type>) {
        x.tree().unlink();
        tree() = tree_t(x.tree().key_comp());
        try_link_to_tree();
      }
      else
        tree() = move(x.tree());
      return *this;
    }
  }
  friend void swap(this_t &x, this_t &y)
    noexcept(is_nothrow_swappable_v<unordered_t>) {
    inner::mixed_helper::swap(x, y);
  }

  // optional container operations

  // reversible container

  using reverse_iterator = typename tree_t::reverse_iterator;
  using const_reverse_iterator = typename tree_t::const_reverse_iterator;

  reverse_iterator rbegin() {
    return tree().rbegin();
  }
  reverse_iterator rend() {
    return tree().rend();
  }
  const_reverse_iterator rbegin() const {
    return tree().rbegin();
  }
  const_reverse_iterator rend() const {
    return tree().rend();
  }
  const_reverse_iterator crbegin() const {
    return rbegin();
  }
  const_reverse_iterator crend() const {
    return rend();
  }

  // allocator-aware container

  using allocator_type = alloc_t;
  allocator_type get_allocator() const noexcept {
    return unordered().get_allocator();
  }

  explicit mixed_set_adaptor(const allocator_type &al) noexcept
    : unordered_t(al) {}
  mixed_set_adaptor(const this_t &x, const allocator_type &al)
    : unordered_t(x.unordered(), al) {
    link_to_tree();
  }
  mixed_set_adaptor(this_t &&x, const allocator_type &al)
#ifndef RE_NOEXCEPT
    try
#endif
    : unordered_t(move(x.unordered()), al) {
      inner::mixed_helper::move_construct_impl(*this, x, al);
    }
#ifndef RE_NOEXCEPT
    catch (...) {
      x.clear();
      throw;
    }
#endif

  // associative container

  using key_type = typename tree_t::key_type;
  using key_compare = typename tree_t::key_compare;
  using value_compare = typename tree_t::value_compare;

  using tree_t::key_comp;
  using tree_t::value_comp;

  mixed_set_adaptor(const HASH &hf, const EQ &eq, const LESS &cmp,
                    const allocator_type &al = allocator_type{})
    : unordered_t(hf, eq, al), tree_t(cmp) {}

  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  mixed_set_adaptor(IITR first, IITR last,
                    const HASH &hf, const EQ &eq, const LESS &cmp,
                    const allocator_type &al = allocator_type{})
    : unordered_t(hf, eq, al), tree_t(cmp) {
    insert_range(rng(first, last));
  }
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  mixed_set_adaptor(IITR first, IITR last,
                    const allocator_type &al = allocator_type{})
    : mixed_set_adaptor(first, last, HASH{}, EQ{}, LESS{}, al) {}
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  void assign(IITR first, IITR last) {
    assign_range(rng(first, last));
  }

  mixed_set_adaptor(initializer_list<value_type> il,
                    const HASH &hf, const EQ &eq, const LESS &cmp,
                    const allocator_type &al = allocator_type{})
    : unordered_t(hf, eq, al), tree_t(cmp) {
    insert_range(il);
  }
  mixed_set_adaptor(initializer_list<value_type> il,
                    const allocator_type &al = allocator_type{})
    : mixed_set_adaptor(il, HASH{}, EQ{}, LESS{}, al) {}
  this_t &operator =(initializer_list<value_type> il) {
    assign_range(il);
    return *this;
  }
  void assign(initializer_list<value_type> il) {
    assign_range(il);
  }

  template <class...S>
  pair<iterator, bool> emplace(S &&...s) {
    return inner::mixed_helper::set_emplace(*this, forward<S>(s)...);
  }
  template <class...S>
  iterator emplace_hint(const_iterator hint, S &&...s) {
    return inner::mixed_helper::set_emplace_hint(*this, hint, forward<S>(s)...);
  }
  pair<iterator, bool> insert(const value_type &x) {
    return inner::mixed_helper::set_insert(*this, x);
  }
  pair<iterator, bool> insert(value_type &&x) {
    return inner::mixed_helper::set_insert(*this, move(x));
  }
  template <class K>
  pair<iterator, bool> insert(K &&key)
    requires (transparent && is_constructible_v<value_type, K &&>) {
    return inner::mixed_helper::set_insert_transparent(*this, forward<K>(key));
  }
  iterator insert(const_iterator hint, const value_type &x) {
    return inner::mixed_helper::set_insert_hint(*this, hint, x);
  }
  iterator insert(const_iterator hint, value_type &&x) {
    return inner::mixed_helper::set_insert_hint(*this, hint, move(x));
  }
  template <class K>
  iterator insert(const_iterator hint, K &&key)
    requires (transparent && is_constructible_v<value_type, K &&>) {
    return inner::mixed_helper::set_insert_hint_transparent
      (*this, hint, forward<K>(key));
  }
  template <class IITR>
  void insert(IITR from, IITR to) {
    insert_range(rng(from, to));      
  }
  void insert(initializer_list<value_type> il) {
    insert_range(il);
  }

  using node_type = typename tree_t::node_type;
  struct insert_return_type {
    iterator position;
    bool inserted;
    node_type node;
  };
  node_type extract(const_iterator pos) {
    auto x = unordered().extract(no_ed_unordered_iter(pos));
    tree().unlink(pos);
    return node_type(static_cast<actual_node_pointer>(x.release()),
                     get_allocator());
  }
  node_type extract(const key_type &key) {
    return inner::mixed_helper::extract_key(*this, key);
  }
  template <class K>
  node_type extract(const K &key) requires transparent {
    return inner::mixed_helper::extract_key(*this, key);
  }
  insert_return_type insert(node_type &&nh) {
    return inner::mixed_helper::set_insert_node(*this, move(nh));
  }
  iterator insert(const_iterator hint, node_type &&nh) {
    return inner::mixed_helper::set_insert_node_hint(*this, hint, move(nh));
  }

  iterator erase(const_iterator pos) {
    const auto ret = tree().unlink(pos);
    unordered().erase(no_ed_unordered_iter(pos));
    return ret;
  }
  iterator erase(const_iterator from, const_iterator to) {
    while (from != to)
      from = erase(from);
    return to.to_mutable();
  }
  void clear() noexcept {
    tree().unlink();
    unordered().clear();
  }

  size_type erase(const key_type &key) {
    return inner::mixed_helper::set_erase_key(*this, key);
  }
  template <class K>
  size_type erase(const K &key)
    requires (transparent
              && !is_convertible_v<const K &, iterator>
              && !is_convertible_v<const K &, const_iterator>) {
    return inner::mixed_helper::set_erase_key(*this, key);
  }

  size_type remove(const key_type &key) {
    return inner::mixed_helper::set_remove_key(*this, key);
  }
  template <class K>
  size_type remove(const K &key) requires transparent {
    return inner::mixed_helper::set_remove_key(*this, key);
  }
  template <class UF>
  size_type remove_if(UF eq) {
    return inner::mixed_helper::remove_if(*this, eq);
  }

  template <class HASH2, class EQ2, class LESS2>
  void merge(mixed_set_adaptor<TRAITS, HASH2, EQ2, LESS2> &x) {
    for_each_node(x, next, [&x, this](auto i) {
      try_link(get_key()(*i), [&x, i]() {x.unlink(i); return i;});
    });
  }
  template <class HASH2, class EQ2, class LESS2>
  void merge(mixed_set_adaptor<TRAITS, HASH2, EQ2, LESS2> &&x) {
    merge(x);
  }
  template <class HASH2, class EQ2, class LESS2>
  void merge(mixed_multiset_adaptor<TRAITS, HASH2, EQ2, LESS2> &x) {
    for_each_node(x, next, [&x, this](auto i) {
      try_link(get_key()(*i), [&x, i]() {x.unlink(i); return i;});
    });
  }
  template <class HASH2, class EQ2, class LESS2>
  void merge(mixed_multiset_adaptor<TRAITS, HASH2, EQ2, LESS2> &&x) {
    merge(x);
  }

  template <class K, bool Y = transparent, class = enable_if_t<Y>>
  iterator find(const K &key) {
    return tree_iter(unordered().find(key));
  }
  iterator find(const key_type &key) {
    return tree_iter(unordered().find(key));
  }
  template <class K, bool Y = transparent, class = enable_if_t<Y>>
  const_iterator find(const K &key) const {
    return tree_iter(unordered().find(key));
  }
  const_iterator find(const key_type &key) const {
    return tree_iter(unordered().find(key));
  }

  template <class K, bool Y = transparent, class = enable_if_t<Y>>
  bool contains(const K &key) const {
    return unordered().contains(key);
  }
  bool contains(const key_type &key) const {
    return unordered().contains(key);
  }

  template <class K, bool Y = transparent, class = enable_if_t<Y>>
  size_type count(const K &key) const {
    return unordered().count(key);
  }
  size_type count(const key_type &key) const {
    return unordered().count(key);
  }

  using tree_t::lower_bound;
  using tree_t::upper_bound;

  template <class K, bool Y = transparent, class = enable_if_t<Y>>
  iter_pair<iterator> equal_range(const K &key) {
    return inner::mixed_helper::equal_range(*this, key);
  }
  iter_pair<iterator> equal_range(const key_type &key) {
    return inner::mixed_helper::equal_range(*this, key);
  }
  template <class K, bool Y = transparent, class = enable_if_t<Y>>
  iter_pair<const_iterator> equal_range(const K &key) const {
    return inner::mixed_helper::equal_range(*this, key);
  }
  iter_pair<const_iterator> equal_range(const key_type &key) const {
    return inner::mixed_helper::equal_range(*this, key);
  }

  // extensions

  using tree_t::partition_point;

  using tree_t::find_range;

  template <class...S>
  iterator new_node(S &&...s) {
    return no_ed_tree_iter(unordered().new_node(forward<S>(s)...));
  }
  void delete_node(const_iterator it) noexcept {
    return unordered().delete_node(no_ed_unordered_iter(it));
  }

  iterator unlink(const_iterator it) noexcept {
    unordered().unlink(no_ed_unordered_iter(it));
    return tree().unlink(it);
  }
  iterator unlink(const_iterator from, const_iterator to) noexcept {
    while (from != to)
      from = unlink(from);
    return to.to_mutable();
  }
  void unlink() noexcept {
    unordered().unlink();
    tree().unlink();
  }
  size_type unlink_key(const key_type &key) {
    return inner::mixed_helper::set_unlink_key(*this, key);
  }
  template <class K, bool Y = transparent, class = enable_if_t<Y>>
  size_type unlink_key(const K &key) {
    return inner::mixed_helper::set_unlink_key(*this, key);
  }
  pair<iterator, bool> link(const_iterator it) {
    return try_link(get_key()(*it), bind(copy, it.to_mutable()));
  }
  iterator link(const_iterator hint, const_iterator it) {
    return try_link_hint(hint, get_key()(*it), bind(copy, it.to_mutable()));
  }

  template <class K, class GET_NODE, class DO_WHEN_EQ = empty_function>
  pair<iterator, bool> try_link(const K &key, GET_NODE get_node,
                                DO_WHEN_EQ do_when_eq = DO_WHEN_EQ{}) {
    return inner::mixed_helper::set_try_link(*this, key, get_node, do_when_eq);
  }
  template <class K, class GET_NODE, class DO_WHEN_EQ = empty_function>
  iterator try_link_hint(const_iterator hint, const K &key, GET_NODE get_node,
                         DO_WHEN_EQ do_when_eq = DO_WHEN_EQ{}) {
    return inner::mixed_helper::set_try_link_hint(*this, hint, key,
                                                  get_node, do_when_eq);
  }

  using tree_t::front;
  using tree_t::back;

  using tree_t::root;
  using tree_t::leftmost;
  using tree_t::rightmost;

  using tree_t::nth;

  iterator erase_or_unlink(const_iterator it) noexcept {
    const auto ret = tree().unlink(it);
    unordered().erase_or_unlink(no_ed_unordered_iter(it));
    return ret;
  }

  template <class EQL>
  void unique(EQL eql) {
    list_unique(*this, eql, [this](auto it) {return erase_or_unlink(it);});
  }
  void unique() {}

  using hasher = typename unordered_t::hasher;
  using key_equal = typename unordered_t::key_equal;
  using unordered_t::hash_function;
  using unordered_t::key_eq;
  using unordered_t::bucket_count;
  using unordered_t::max_bucket_count;
  using unordered_t::active_bucket_count;
  using unordered_t::bucket_size;
  using unordered_t::bucket_range;
  using unordered_t::bucket;
  using unordered_t::load_factor;
  using unordered_t::max_load_factor;
  using unordered_t::rehash;
  using unordered_t::reserve;
  using local_iterator = typename unordered_t::local_iterator;
  using const_local_iterator = typename unordered_t::const_local_iterator;
  local_iterator begin(size_type n) noexcept {
    return unordered().begin(n);
  }
  local_iterator end(size_type n) noexcept {
    return unordered().end(n);
  }
  const_local_iterator begin(size_type n) const noexcept {
    return unordered().begin(n);
  }
  const_local_iterator end(size_type n) const noexcept {
    return unordered().end(n);
  }
  const_local_iterator cbegin(size_type n) const noexcept {
    return unordered().cbegin(n);
  }
  const_local_iterator cend(size_type n) const noexcept {
    return unordered().cend(n);
  }

  template <class R, class = enable_if_t
            <is_rng<R> && is_constructible_v<value_type, rng_ref<R>>>>
  mixed_set_adaptor(from_range_t, R &&r,
                    const allocator_type &al = allocator_type{})
    : unordered_t(al) {
    insert_range(r);
  }
  template <class R, class = enable_if_t
            <is_rng<R> && is_constructible_v<value_type, rng_ref<R>>>>
  mixed_set_adaptor(from_range_t, R &&r,
                    const HASH &hf, const EQ &eq, const LESS &cmp,
                    const allocator_type &al = allocator_type{})
    : unordered_t(hf, eq, al), tree_t(cmp) {
    insert_range(r);
  }
  template <class R, class = enable_if_t
            <!is_convertible_v<R &&, const allocator_type &>
             && !is_same_v<decay_t<R>, this_t>
             && is_rng<R> && is_constructible_v<value_type, rng_ref<R>>>>
  explicit mixed_set_adaptor(R &&r) {
    insert_range(r);
  }
  template <class R, class = enable_if_t
            <is_rng<R> && is_constructible_v<value_type, rng_ref<R>>>>
  mixed_set_adaptor(R &&r, const HASH &hf, const EQ &eq, const LESS &cmp,
                    const allocator_type &al = allocator_type{})
    : unordered_t(hf, eq, al), tree_t(cmp) {
    insert_range(r);
  }
  template <class R, class = enable_if_t
            <!is_same_v<decay_t<R>, this_t>
             && is_rng<R> && is_constructible_v<value_type, rng_ref<R>>>>
  mixed_set_adaptor(R &&r, const allocator_type &al)
    : unordered_t(al), tree_t() {
    insert_range(r);
  }

  template <class R>
  enable_if_t<!is_same_v<decay_t<R>, this_t>
              && is_rng<R> && is_constructible_v<value_type, rng_ref<R>>
              && is_assignable_v<value_type &, rng_ref<R>>, this_t &>
  operator =(R &&r) {
    assign_range(r);
    return *this;
  }
  template <class R>
  void assign_range(R &&r) {
    const auto guard = exit_fn([&]() {
      tree().unlink();
      try_link_to_tree();
    });
    unordered() = r;
  }
  template <class R>
  void assign(R &&r) {
    assign_range(r);
  }

  template <class IITR_RANGE>
  enable_if_t<(!transparent
               && !is_convertible_v<IITR_RANGE &&, value_type &&>
               && !is_convertible_v<IITR_RANGE &&, const value_type &>
               && !is_convertible_v<IITR_RANGE &&, node_type &&>)
              || !is_constructible_v<value_type, IITR_RANGE &&>>
  insert(IITR_RANGE &&r) {
    insert_range(r);
  }
  template <class IITR_RANGE>
  void insert_range(IITR_RANGE &&r) {
    for (auto &i : iters(r))
      emplace(*i);
  }

  this_t &append() {
    return *this;
  }
  template <class X, class...S>
  this_t &append(X &&x, S &&...s) {
    insert(forward<X>(x));
    return append(forward<S>(s)...);
  }
};
template <class TRAITS, class HASH, class EQ, class LESS>
bool operator ==(const mixed_set_adaptor<TRAITS, HASH, EQ, LESS> &x,
                 const mixed_set_adaptor<TRAITS, HASH, EQ, LESS> &y) {
  return x.tree() == y.tree();
}
template <class TRAITS, class HASH, class EQ, class LESS>
auto operator <=>(const mixed_set_adaptor<TRAITS, HASH, EQ, LESS> &x,
                  const mixed_set_adaptor<TRAITS, HASH, EQ, LESS> &y)
  ->decltype(x.tree() <=> y.tree()) {
  return x.tree() <=> y.tree();
}

template <class TRAITS, class HASH, class EQ, class LESS>
class mixed_map_adaptor
  : unordered_map_adaptor<typename TRAITS::hashtable, HASH, EQ>
  , map_adaptor<typename TRAITS::tree, LESS> {
  friend struct inner::mixed_helper;

  template <class R>
  static auto begin(R &&r) requires is_rng<R> {return re::begin(r);}
  template <class R>
  static auto end(R &&r) requires is_rng<R> {return re::end(r);}
  template <class R>
  static auto rbegin(R &&r) {return re::rbegin(r);}
  template <class R>
  static auto rend(R &&r) {return re::rend(r);}
  template <class R>
  static auto size(R &&r) {return re::size(r);}
  template <class R>
  static auto empty(R &&r) {return re::empty(r);}

  using this_t = mixed_map_adaptor;
  using unordered_t
    = unordered_map_adaptor<typename TRAITS::hashtable, HASH, EQ>;
  using tree_t = map_adaptor<typename TRAITS::tree, LESS>;

  using alloc_t = typename unordered_t::allocator_type;
  static_assert(is_same_v
                <typename unordered_t::allocator_type,
                 typename tree_t::allocator_type>);

  static constexpr bool transparent
    = is_transparent_function_v<HASH> && is_transparent_function_v<EQ>
    && is_transparent_function_v<LESS>;

  using actual_node_pointer = typename tree_t::traits::node_pointer;

  using tree_t::get_key;
  using tree_t::get_mapped;
  using tree_t::key_less;
  using unordered_t::hash;
  using unordered_t::eq;

public:
  using tree_iterator = typename tree_t::iterator;
  using tree_const_iterator = typename tree_t::const_iterator;
  using unordered_iterator = typename unordered_t::iterator;
  using unordered_const_iterator = typename unordered_t::const_iterator;

  static auto no_ed_unordered_iter(tree_const_iterator it) noexcept {
    return unordered_iterator(static_cast<actual_node_pointer>(it.node()));
  }
  static auto no_ed_tree_iter(unordered_const_iterator it) noexcept {
    return tree_iterator(static_cast<actual_node_pointer>(it.node()));
  }
  static auto no_ed_unordered_iter(unordered_const_iterator it) noexcept {
    return unordered_iterator(it.node());
  }
  static auto no_ed_tree_iter(tree_const_iterator it) noexcept {
    return tree_iterator(it.node());
  }

  auto unordered_iter(tree_iterator it) const noexcept {
    return it == tree().end()
      ? unordered().end().to_mutable()
      : no_ed_unordered_iter(it);
  }
  auto unordered_iter(tree_const_iterator it) const noexcept {
    return it == tree().end()
      ? unordered().end()
      : unordered_const_iterator(no_ed_unordered_iter(it));
  }
  auto unordered_iter(unordered_iterator it) const noexcept {
    return it;
  }
  auto unordered_iter(unordered_const_iterator it) const noexcept {
    return it;
  }
  auto tree_iter(unordered_iterator it) const noexcept {
    return it == unordered().end()
      ? tree().end().to_mutable()
      : no_ed_tree_iter(it);
  }
  auto tree_iter(unordered_const_iterator it) const noexcept {
    return it == unordered().end()
      ? tree().end()
      : tree_const_iterator(no_ed_tree_iter(it));
  }
  auto tree_iter(tree_iterator it) const noexcept {
    return it;
  }
  auto tree_iter(tree_const_iterator it) const noexcept {
    return it;
  }

private:
  void link_to_tree() {
    for (auto &i : iters(unordered()))
      tree().link(no_ed_tree_iter(i));
  }
  void try_link_to_tree() {
#ifndef RE_NOEXCEPT
    try {
#endif
      for (auto &i : iters(unordered()))
        tree().link(no_ed_tree_iter(i));
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      unordered().clear();
      tree().unlink();
      throw;
    }
#endif
  }

public:
  using traits = TRAITS;
  using node_pointer = typename tree_t::node_pointer;
  using tree_type = tree_t;
  using unordered_type = unordered_t;
  tree_t &tree() noexcept {
    return *this;
  }
  const tree_t &tree() const noexcept {
    return *this;
  }
  unordered_t &unordered() noexcept {
    return *this;
  }
  const unordered_t &unordered() const noexcept {
    return *this;
  }

  using pointer = typename tree_t::pointer;
  using const_pointer = typename tree_t::const_pointer;

  // container

  using value_type = typename tree_t::value_type;
  using reference = typename tree_t::reference;
  using const_reference = typename tree_t::const_reference;

  using iterator = typename tree_t::iterator;
  using const_iterator = typename tree_t::const_iterator;
  using difference_type = typename tree_t::difference_type;
  using size_type = typename tree_t::size_type;

  iterator begin() noexcept {
    return tree().begin();
  }
  iterator end() noexcept {
    return tree().end();
  }
  const_iterator begin() const noexcept {
    return tree().begin();
  }
  const_iterator end() const noexcept {
    return tree().end();
  }
  const_iterator cbegin() const noexcept {
    return tree().begin();
  }
  const_iterator cend() const noexcept {
    return tree().end();
  }

  using tree_t::max_size;
  size_type size() const noexcept {
    return unordered().size();
  }
  using tree_t::empty;

  mixed_map_adaptor() = default;
  ~mixed_map_adaptor() = default;
  mixed_map_adaptor(const mixed_map_adaptor &) = delete;
  mixed_map_adaptor &operator =(const mixed_map_adaptor &) = delete;
  mixed_map_adaptor(const mixed_map_adaptor &x)
    requires is_copy_constructible_v<unordered_t>
    : unordered_t(x.unordered()) {
    link_to_tree();
  }
  mixed_map_adaptor &operator =(const mixed_map_adaptor &x)
    requires is_copy_assignable_v<unordered_t> {
    if (this != addressof(x)) {
      unordered() = x.unordered();
      tree() = tree_t(x.tree().key_comp());
      try_link_to_tree();
    }
    return *this;
  }
  mixed_map_adaptor(mixed_map_adaptor &&) = default;
  mixed_map_adaptor &operator =(mixed_map_adaptor &&x)
    noexcept(is_nothrow_move_assignable_v<unordered_t>) {
    if constexpr (!TRAITS::hashtable_traits::store_node_allocator::value) {
      unordered() = move(x.unordered());
      tree() = move(x.tree());
      return *this;
    }
    else {
      const allocator_type x_al = x.unordered().get_allocator();
      unordered() = move(x.unordered());
      if (unordered().get_allocator() != x_al
          && !alloc_move_prpg<allocator_type>) {
        x.tree().unlink();
        tree() = tree_t(x.tree().key_comp());
        try_link_to_tree();
      }
      else
        tree() = move(x.tree());
      return *this;
    }
  }
  friend void swap(this_t &x, this_t &y)
    noexcept(is_nothrow_swappable_v<unordered_t>) {
    inner::mixed_helper::swap(x, y);
  }

  // optional container operations

  // reversible container

  using reverse_iterator = typename tree_t::reverse_iterator;
  using const_reverse_iterator = typename tree_t::const_reverse_iterator;

  reverse_iterator rbegin() {
    return tree().rbegin();
  }
  reverse_iterator rend() {
    return tree().rend();
  }
  const_reverse_iterator rbegin() const {
    return tree().rbegin();
  }
  const_reverse_iterator rend() const {
    return tree().rend();
  }
  const_reverse_iterator crbegin() const {
    return rbegin();
  }
  const_reverse_iterator crend() const {
    return rend();
  }

  // allocator-aware container

  using allocator_type = alloc_t;
  allocator_type get_allocator() const noexcept {
    return unordered().get_allocator();
  }

  explicit mixed_map_adaptor(const allocator_type &al) noexcept
    : unordered_t(al) {}
  mixed_map_adaptor(const this_t &x, const allocator_type &al)
    : unordered_t(x.unordered(), al) {
    link_to_tree();
  }
  mixed_map_adaptor(this_t &&x, const allocator_type &al)
#ifndef RE_NOEXCEPT
    try
#endif
    : unordered_t(move(x.unordered()), al) {
      inner::mixed_helper::move_construct_impl(*this, x, al);
    }
#ifndef RE_NOEXCEPT
    catch (...) {
      x.clear();
      throw;
    }
#endif

  // associative container

  using key_type = typename tree_t::key_type;
  using mapped_type = typename tree_t::mapped_type;
  using key_compare = typename tree_t::key_compare;
  using value_compare = typename tree_t::value_compare;

  using tree_t::key_comp;
  using tree_t::value_comp;

  mixed_map_adaptor(const HASH &hf, const EQ &eq, const LESS &cmp,
                    const allocator_type &al = allocator_type{})
    : unordered_t(hf, eq, al), tree_t(cmp) {}

  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  mixed_map_adaptor(IITR first, IITR last,
                    const HASH &hf, const EQ &eq, const LESS &cmp,
                    const allocator_type &al = allocator_type{})
    : unordered_t(hf, eq, al), tree_t(cmp) {
    insert_range(rng(first, last));
  }
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  mixed_map_adaptor(IITR first, IITR last,
                    const allocator_type &al = allocator_type{})
    : mixed_map_adaptor(first, last, HASH{}, EQ{}, LESS{}, al) {}
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  void assign(IITR first, IITR last) {
    assign_range(rng(first, last));
  }

  mixed_map_adaptor(initializer_list<value_type> il,
                    const HASH &hf, const EQ &eq, const LESS &cmp,
                    const allocator_type &al = allocator_type{})
    : unordered_t(hf, eq, al), tree_t(cmp) {
    insert_range(il);
  }
  mixed_map_adaptor(initializer_list<value_type> il,
                    const allocator_type &al = allocator_type{})
    : mixed_map_adaptor(il, HASH{}, EQ{}, LESS{}, al) {}
  this_t &operator =(initializer_list<value_type> il) {
    assign_range(il);
    return *this;
  }
  void assign(initializer_list<value_type> il) {
    assign_range(il);
  }

  template <class...S>
  pair<iterator, bool> emplace(S &&...s) {
    return inner::mixed_helper::set_emplace(*this, forward<S>(s)...);
  }
  template <class...S>
  iterator emplace_hint(const_iterator hint, S &&...s) {
    return inner::mixed_helper::set_emplace_hint(*this, hint, forward<S>(s)...);
  }
  pair<iterator, bool> insert(const value_type &x) {
    return inner::mixed_helper::set_insert(*this, x);
  }
  pair<iterator, bool> insert(value_type &&x) {
    return inner::mixed_helper::set_insert(*this, move(x));
  }
  iterator insert(const_iterator hint, const value_type &x) {
    return inner::mixed_helper::set_insert_hint(*this, hint, x);
  }
  iterator insert(const_iterator hint, value_type &&x) {
    return inner::mixed_helper::set_insert_hint(*this, hint, move(x));
  }
  template <class IITR>
  void insert(IITR from, IITR to) {
    insert_range(rng(from, to));      
  }
  void insert(initializer_list<value_type> il) {
    insert_range(il);
  }

  using node_type = typename tree_t::node_type;
  struct insert_return_type {
    iterator position;
    bool inserted;
    node_type node;
  };
  node_type extract(const_iterator pos) {
    auto x = unordered().extract(no_ed_unordered_iter(pos));
    tree().unlink(pos);
    return node_type(static_cast<actual_node_pointer>(x.release()),
                     get_allocator());
  }
  node_type extract(const key_type &key) {
    return inner::mixed_helper::extract_key(*this, key);
  }
  template <class K>
  enable_if_t<is_constructible_v<key_type, const K &>, node_type>
  extract(const K &key) {
    return inner::mixed_helper::extract_key(*this, key);
  }
  insert_return_type insert(node_type &&nh) {
    return inner::mixed_helper::set_insert_node(*this, move(nh));
  }
  iterator insert(const_iterator hint, node_type &&nh) {
    return inner::mixed_helper::set_insert_node_hint(*this, hint, move(nh));
  }

  template <class...S>
  pair<iterator, bool> try_emplace(const key_type &key, S &&...s) {
    return inner::mixed_helper::set_try_link
      (*this, key, [&]() {
        return new_node(piecewise_construct,
                        forward_as_tuple(key),
                        forward_as_tuple(forward<S>(s)...));
      });
  }
  template <class...S>
  pair<iterator, bool> try_emplace(key_type &&key, S &&...s) {
    return inner::mixed_helper::set_try_link
      (*this, key, [&]() {
        return new_node(piecewise_construct,
                        forward_as_tuple(move(key)),
                        forward_as_tuple(forward<S>(s)...));
      });
  }
  template <class K, class...S>
  pair<iterator, bool> try_emplace(K &&key, S &&...s)
    requires (transparent
              && !is_convertible_v<K &&, iterator>
              && !is_convertible_v<K &&, const_iterator>) {
    return inner::mixed_helper::set_try_link
      (*this, key, [&]() {
        return new_node(piecewise_construct,
                        forward_as_tuple(forward<K>(key)),
                        forward_as_tuple(forward<S>(s)...));
      });
  }
  template <class...S>
  iterator try_emplace(const_iterator hint, const key_type &key, S &&...s) {
    return inner::mixed_helper::set_try_link_hint
      (*this, hint, key, [&]() {
        return new_node(piecewise_construct,
                        forward_as_tuple(key),
                        forward_as_tuple(forward<S>(s)...));
      });
  }
  template <class...S>
  iterator try_emplace(const_iterator hint, key_type &&key, S &&...s) {
    return inner::mixed_helper::set_try_link_hint
      (*this, hint, key, [&]() {
        return new_node(piecewise_construct,
                        forward_as_tuple(move(key)),
                        forward_as_tuple(forward<S>(s)...));
      });
  }
  template <class K, class...S>
  iterator try_emplace(const_iterator hint, K &&key, S &&...s)
    requires transparent {
    return inner::mixed_helper::set_try_link_hint
      (*this, hint, key, [&]() {
        return new_node(piecewise_construct,
                        forward_as_tuple(forward<K>(key)),
                        forward_as_tuple(forward<S>(s)...));
      });
  }

  template <class X>
  pair<iterator, bool> insert_or_assign(const key_type &key, X &&x) {
    return inner::mixed_helper
      ::set_try_link(*this, key,
                     [&]() {return new_node(key, forward<X>(x));},
                     [&](iterator it) {get_mapped()(*it) = forward<X>(x);});
  }
  template <class X>
  pair<iterator, bool> insert_or_assign(key_type &&key, X &&x) {
    return inner::mixed_helper
      ::set_try_link(*this, key,
                     [&]() {return new_node(move(key), forward<X>(x));},
                     [&](iterator it) {get_mapped()(*it) = forward<X>(x);});
  }
  template <class K, class X, bool Y = transparent, class = enable_if_t<Y>>
  pair<iterator, bool> insert_or_assign(K &&key, X &&x) {
    return inner::mixed_helper
      ::set_try_link(*this, key,
                     [&]() {return new_node(forward<K>(key), forward<X>(x));},
                     [&](iterator it) {get_mapped()(*it) = forward<X>(x);});
  }
  template <class X>
  iterator insert_or_assign(const_iterator hint,
                            const key_type &key, X &&x) {
    return inner::mixed_helper::set_try_link_hint
      (*this, hint, key,
       [&]() {return new_node(key, forward<X>(x));},
       [&](iterator it) {get_mapped()(*it) = forward<X>(x);});
  }
  template <class X>
  iterator insert_or_assign(const_iterator hint, key_type &&key, X &&x) {
    return inner::mixed_helper::set_try_link_hint
      (*this, hint, key,
       [&]() {return new_node(move(key), forward<X>(x));},
       [&](iterator it) {get_mapped()(*it) = forward<X>(x);});
  }
  template <class K, class X, bool Y = transparent, class = enable_if_t<Y>>
  iterator insert_or_assign(const_iterator hint, K &&key, X &&x) {
    return inner::mixed_helper::set_try_link_hint
      (*this, hint, key,
       [&]() {return new_node(forward<K>(key), forward<X>(x));},
       [&](iterator it) {get_mapped()(*it) = forward<X>(x);});
  }

  mapped_type &operator [](const key_type &key) {
    return get_mapped()(*try_emplace(key).first);
  }
  mapped_type &operator [](key_type &&key) {
    return get_mapped()(*try_emplace(move(key)).first);
  }
  template <class K, bool Y = transparent, class = enable_if_t<Y>>
  mapped_type &operator [](K &&key) {
    return get_mapped()(*try_emplace(forward<K>(key)).first);
  }
  const mapped_type &operator [](const key_type &key) const {
    return get_mapped()(*find(key));
  }
  template <class K, bool Y = transparent, class = enable_if_t<Y>>
  const mapped_type &operator [](const K &key) const {
    return get_mapped()(*find(key));
  }
  mapped_type &at(const key_type &key) {
    const iterator it = find(key);
    if (it == end())
      throw_or_terminate<out_of_range>("re::mixed_map_adaptor: at(key) failed");
    return get_mapped()(*it);
  }
  template <class K, bool Y = transparent, class = enable_if_t<Y>>
  mapped_type &at(const K &key) {
    const iterator it = find(key);
    if (it == end())
      throw_or_terminate<out_of_range>("re::mixed_map_adaptor: at(key) failed");
    return get_mapped()(*it);
  }
  const mapped_type &at(const key_type &key) const {
    const const_iterator it = find(key);
    if (it == end())
      throw_or_terminate<out_of_range>("re::mixed_map_adaptor: at(key) failed");
    return get_mapped()(*it);
  }
  template <class K, bool Y = transparent, class = enable_if_t<Y>>
  const mapped_type &at(const K &key) const {
    const const_iterator it = find(key);
    if (it == end())
      throw_or_terminate<out_of_range>("re::mixed_map_adaptor: at(key) failed");
    return get_mapped()(*it);
  }

  iterator erase(const_iterator pos) {
    const auto ret = tree().unlink(pos);
    unordered().erase(no_ed_unordered_iter(pos));
    return ret;
  }
  iterator erase(const_iterator from, const_iterator to) {
    while (from != to)
      from = erase(from);
    return to.to_mutable();
  }
  void clear() noexcept {
    tree().unlink();
    unordered().clear();
  }

  size_type erase(const key_type &key) {
    return inner::mixed_helper::set_erase_key(*this, key);
  }
  template <class K>
  size_type erase(const K &key)
    requires (transparent
              && !is_convertible_v<const K &, iterator>
              && !is_convertible_v<const K &, const_iterator>) {
    return inner::mixed_helper::set_erase_key(*this, key);
  }

  size_type remove(const key_type &key) {
    return inner::mixed_helper::set_remove_key(*this, key);
  }
  template <class K>
  size_type remove(const K &key) requires transparent {
    return inner::mixed_helper::set_remove_key(*this, key);
  }
  template <class UF>
  size_type remove_if(UF eq) {
    return inner::mixed_helper::remove_if(*this, eq);
  }

  template <class HASH2, class EQ2, class LESS2>
  void merge(mixed_map_adaptor<TRAITS, HASH2, EQ2, LESS2> &x) {
    for_each_node(x, next, [&x, this](auto i) {
      try_link(get_key()(*i), [&x, i]() {x.unlink(i); return i;});
    });
  }
  template <class HASH2, class EQ2, class LESS2>
  void merge(mixed_map_adaptor<TRAITS, HASH2, EQ2, LESS2> &&x) {
    merge(x);
  }
  template <class HASH2, class EQ2, class LESS2>
  void merge(mixed_multimap_adaptor<TRAITS, HASH2, EQ2, LESS2> &x) {
    for_each_node(x, next, [&x, this](auto i) {
      try_link(get_key()(*i), [&x, i]() {x.unlink(i); return i;});
    });
  }
  template <class HASH2, class EQ2, class LESS2>
  void merge(mixed_multimap_adaptor<TRAITS, HASH2, EQ2, LESS2> &&x) {
    merge(x);
  }

  template <class K, bool Y = transparent, class = enable_if_t<Y>>
  iterator find(const K &key) {
    return tree_iter(unordered().find(key));
  }
  iterator find(const key_type &key) {
    return tree_iter(unordered().find(key));
  }
  template <class K, bool Y = transparent, class = enable_if_t<Y>>
  const_iterator find(const K &key) const {
    return tree_iter(unordered().find(key));
  }
  const_iterator find(const key_type &key) const {
    return tree_iter(unordered().find(key));
  }

  template <class K, bool Y = transparent, class = enable_if_t<Y>>
  bool contains(const K &key) const {
    return unordered().contains(key);
  }
  bool contains(const key_type &key) const {
    return unordered().contains(key);
  }

  template <class K, bool Y = transparent, class = enable_if_t<Y>>
  size_type count(const K &key) const {
    return unordered().count(key);
  }
  size_type count(const key_type &key) const {
    return unordered().count(key);
  }

  using tree_t::lower_bound;
  using tree_t::upper_bound;

  template <class K, bool Y = transparent, class = enable_if_t<Y>>
  iter_pair<iterator> equal_range(const K &key) {
    return inner::mixed_helper::equal_range(*this, key);
  }
  iter_pair<iterator> equal_range(const key_type &key) {
    return inner::mixed_helper::equal_range(*this, key);
  }
  template <class K, bool Y = transparent, class = enable_if_t<Y>>
  iter_pair<const_iterator> equal_range(const K &key) const {
    return inner::mixed_helper::equal_range(*this, key);
  }
  iter_pair<const_iterator> equal_range(const key_type &key) const {
    return inner::mixed_helper::equal_range(*this, key);
  }

  // extensions

  using tree_t::partition_point;

  using tree_t::find_range;

  template <class...S>
  iterator new_node(S &&...s) {
    return no_ed_tree_iter(unordered().new_node(forward<S>(s)...));
  }
  void delete_node(const_iterator it) noexcept {
    return unordered().delete_node(no_ed_unordered_iter(it));
  }

  iterator unlink(const_iterator it) noexcept {
    unordered().unlink(no_ed_unordered_iter(it));
    return tree().unlink(it);
  }
  iterator unlink(const_iterator from, const_iterator to) noexcept {
    while (from != to)
      from = unlink(from);
    return to.to_mutable();
  }
  void unlink() noexcept {
    unordered().unlink();
    tree().unlink();
  }
  size_type unlink_key(const key_type &key) {
    return inner::mixed_helper::set_unlink_key(*this, key);
  }
  template <class K, bool Y = transparent, class = enable_if_t<Y>>
  size_type unlink_key(const K &key) {
    return inner::mixed_helper::set_unlink_key(*this, key);
  }
  pair<iterator, bool> link(const_iterator it) {
    return try_link(get_key()(*it), bind(copy, it.to_mutable()));
  }
  iterator link(const_iterator hint, const_iterator it) {
    return try_link_hint(hint, get_key()(*it), bind(copy, it.to_mutable()));
  }

  template <class K, class GET_NODE, class DO_WHEN_EQ = empty_function>
  pair<iterator, bool> try_link(const K &key, GET_NODE get_node,
                                DO_WHEN_EQ do_when_eq = DO_WHEN_EQ{}) {
    return inner::mixed_helper::set_try_link(*this, key, get_node, do_when_eq);
  }
  template <class K, class GET_NODE, class DO_WHEN_EQ = empty_function>
  iterator try_link_hint(const_iterator hint, const K &key, GET_NODE get_node,
                         DO_WHEN_EQ do_when_eq = DO_WHEN_EQ{}) {
    return inner::mixed_helper::set_try_link_hint(*this, hint, key,
                                                  get_node, do_when_eq);
  }

  using tree_t::front;
  using tree_t::back;

  using tree_t::root;
  using tree_t::leftmost;
  using tree_t::rightmost;

  using tree_t::nth;

  iterator erase_or_unlink(const_iterator it) noexcept {
    const auto ret = tree().unlink(it);
    unordered().erase_or_unlink(no_ed_unordered_iter(it));
    return ret;
  }

  void unique() {}
  template <class EQL>
  void unique(EQL eql) {
    list_unique(*this, eql, [this](auto it) {return erase_or_unlink(it);});
  }

  using hasher = typename unordered_t::hasher;
  using key_equal = typename unordered_t::key_equal;
  using unordered_t::hash_function;
  using unordered_t::key_eq;
  using unordered_t::bucket_count;
  using unordered_t::max_bucket_count;
  using unordered_t::active_bucket_count;
  using unordered_t::bucket_size;
  using unordered_t::bucket_range;
  using unordered_t::bucket;
  using unordered_t::load_factor;
  using unordered_t::max_load_factor;
  using unordered_t::rehash;
  using unordered_t::reserve;
  using local_iterator = typename unordered_t::local_iterator;
  using const_local_iterator = typename unordered_t::const_local_iterator;
  local_iterator begin(size_type n) noexcept {
    return unordered().begin(n);
  }
  local_iterator end(size_type n) noexcept {
    return unordered().end(n);
  }
  const_local_iterator begin(size_type n) const noexcept {
    return unordered().begin(n);
  }
  const_local_iterator end(size_type n) const noexcept {
    return unordered().end(n);
  }
  const_local_iterator cbegin(size_type n) const noexcept {
    return unordered().cbegin(n);
  }
  const_local_iterator cend(size_type n) const noexcept {
    return unordered().cend(n);
  }

  template <class R, class = enable_if_t
            <is_rng<R> && is_constructible_v<value_type, rng_ref<R>>>>
  mixed_map_adaptor(from_range_t, R &&r,
                    const allocator_type &al = allocator_type{})
    : unordered_t(al) {
    insert_range(r);
  }
  template <class R, class = enable_if_t
            <is_rng<R> && is_constructible_v<value_type, rng_ref<R>>>>
  mixed_map_adaptor(from_range_t, R &&r,
                    const HASH &hf, const EQ &eq, const LESS &cmp,
                    const allocator_type &al = allocator_type{})
    : unordered_t(hf, eq, al), tree_t(cmp) {
    insert_range(r);
  }
  template <class R, class = enable_if_t
            <!is_convertible_v<R &&, const allocator_type &>
             && !is_same_v<decay_t<R>, this_t>
             && is_rng<R> && is_constructible_v<value_type, rng_ref<R>>>>
  explicit mixed_map_adaptor(R &&r) {
    insert_range(r);
  }
  template <class R, class = enable_if_t
            <is_rng<R> && is_constructible_v<value_type, rng_ref<R>>>>
  mixed_map_adaptor(R &&r, const HASH &hf, const EQ &eq, const LESS &cmp,
                    const allocator_type &al = allocator_type{})
    : unordered_t(hf, eq, al), tree_t(cmp) {
    insert_range(r);
  }
  template <class R, class = enable_if_t
            <!is_same_v<decay_t<R>, this_t>
             && is_rng<R> && is_constructible_v<value_type, rng_ref<R>>>>
  mixed_map_adaptor(R &&r, const allocator_type &al)
    : unordered_t(al), tree_t() {
    insert_range(r);
  }

  template <class R>
  enable_if_t<!is_same_v<decay_t<R>, this_t>
              && is_rng<R> && is_constructible_v<value_type, rng_ref<R>>
              && is_assignable_v<value_type &, rng_ref<R>>, this_t &>
  operator =(R &&r) {
    assign_range(r);
    return *this;
  }
  template <class R>
  void assign_range(R &&r) {
    auto guard = exit_fn([&]() {
      tree().unlink();
      try_link_to_tree();
    });
    unordered() = r;
  }
  template <class R>
  void assign(R &&r) {
    assign_range(r);
  }

  template <class IITR_RANGE>
  void insert_range(IITR_RANGE &&r) {
    for (auto &i : iters(r))
      emplace(*i);
  }
  template <class IITR_RANGE>
  enable_if_t<!is_convertible_v<IITR_RANGE &&, value_type &&>
              && !is_convertible_v<IITR_RANGE &&, const value_type &>
              && !is_convertible_v<IITR_RANGE &&, node_type &&>>
  insert(IITR_RANGE &&r) {
    insert_range(r);
  }

  this_t &append() {
    return *this;
  }
  template <class X, class...S>
  this_t &append(X &&x, S &&...s) {
    insert(forward<X>(x));
    return append(forward<S>(s)...);
  }
};
template <class TRAITS, class HASH, class EQ, class LESS>
bool operator ==(const mixed_map_adaptor<TRAITS, HASH, EQ, LESS> &x,
                 const mixed_map_adaptor<TRAITS, HASH, EQ, LESS> &y) {
  return x.tree() == y.tree();
}
template <class TRAITS, class HASH, class EQ, class LESS>
auto operator <=>(const mixed_map_adaptor<TRAITS, HASH, EQ, LESS> &x,
                  const mixed_map_adaptor<TRAITS, HASH, EQ, LESS> &y)
  ->decltype(x.tree() <=> y.tree()) {
  return x.tree() <=> y.tree();
}

template <class TRAITS, class HASH, class EQ, class LESS>
class mixed_multiset_adaptor
  : unordered_multiset_adaptor<typename TRAITS::hashtable, HASH, EQ>
  , multiset_adaptor<typename TRAITS::tree, LESS> {
  friend struct inner::mixed_helper;

  template <class R>
  static auto begin(R &&r) requires is_rng<R> {return re::begin(r);}
  template <class R>
  static auto end(R &&r) requires is_rng<R> {return re::end(r);}
  template <class R>
  static auto rbegin(R &&r) {return re::rbegin(r);}
  template <class R>
  static auto rend(R &&r) {return re::rend(r);}
  template <class R>
  static auto size(R &&r) {return re::size(r);}
  template <class R>
  static auto empty(R &&r) {return re::empty(r);}

  using this_t = mixed_multiset_adaptor;
  using unordered_t
    = unordered_multiset_adaptor<typename TRAITS::hashtable, HASH, EQ>;
  using tree_t = multiset_adaptor<typename TRAITS::tree, LESS>;

  using alloc_t = typename unordered_t::allocator_type;
  static_assert(is_same_v
                <typename unordered_t::allocator_type,
                 typename tree_t::allocator_type>);

  static constexpr bool transparent
    = is_transparent_function_v<HASH> && is_transparent_function_v<EQ>
    && is_transparent_function_v<LESS>;

  using actual_node_pointer = typename tree_t::traits::node_pointer;

  using tree_t::get_key;
  using tree_t::key_less;
  using unordered_t::hash;
  using unordered_t::eq;

public:
  using tree_iterator = typename tree_t::iterator;
  using tree_const_iterator = typename tree_t::const_iterator;
  using unordered_iterator = typename unordered_t::iterator;
  using unordered_const_iterator = typename unordered_t::const_iterator;

  static auto no_ed_unordered_iter(tree_const_iterator it) noexcept {
    return unordered_iterator(static_cast<actual_node_pointer>(it.node()));
  }
  static auto no_ed_tree_iter(unordered_const_iterator it) noexcept {
    return tree_iterator(static_cast<actual_node_pointer>(it.node()));
  }
  static auto no_ed_unordered_iter(unordered_const_iterator it) noexcept {
    return unordered_iterator(it.node());
  }
  static auto no_ed_tree_iter(tree_const_iterator it) noexcept {
    return tree_iterator(it.node());
  }

  auto unordered_iter(tree_iterator it) const noexcept {
    return it == tree().end()
      ? unordered().end().to_mutable()
      : no_ed_unordered_iter(it);
  }
  auto unordered_iter(tree_const_iterator it) const noexcept {
    return it == tree().end()
      ? unordered().end()
      : unordered_const_iterator(no_ed_unordered_iter(it));
  }
  auto unordered_iter(unordered_iterator it) const noexcept {
    return it;
  }
  auto unordered_iter(unordered_const_iterator it) const noexcept {
    return it;
  }
  auto tree_iter(unordered_iterator it) const noexcept {
    return it == unordered().end()
      ? tree().end().to_mutable()
      : no_ed_tree_iter(it);
  }
  auto tree_iter(unordered_const_iterator it) const noexcept {
    return it == unordered().end()
      ? tree().end()
      : tree_const_iterator(no_ed_tree_iter(it));
  }
  auto tree_iter(tree_iterator it) const noexcept {
    return it;
  }
  auto tree_iter(tree_const_iterator it) const noexcept {
    return it;
  }

private:
  void link_to_tree() {
    for (auto &i : iters(unordered()))
      tree().link(no_ed_tree_iter(i));
  }
  void try_link_to_tree() {
#ifndef RE_NOEXCEPT
    try {
#endif
      for (auto &i : iters(unordered()))
        tree().link(no_ed_tree_iter(i));
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      unordered().clear();
      tree().unlink();
      throw;
    }
#endif
  }

public:
  using traits = TRAITS;
  using node_pointer = typename tree_t::node_pointer;
  using tree_type = tree_t;
  using unordered_type = unordered_t;
  tree_t &tree() noexcept {
    return *this;
  }
  const tree_t &tree() const noexcept {
    return *this;
  }
  unordered_t &unordered() noexcept {
    return *this;
  }
  const unordered_t &unordered() const noexcept {
    return *this;
  }

  using pointer = typename tree_t::pointer;
  using const_pointer = typename tree_t::const_pointer;

  // container

  using value_type = typename tree_t::value_type;
  using reference = typename tree_t::reference;
  using const_reference = typename tree_t::const_reference;

  using iterator = typename tree_t::iterator;
  using const_iterator = typename tree_t::const_iterator;
  using difference_type = typename tree_t::difference_type;
  using size_type = typename tree_t::size_type;

  iterator begin() noexcept {
    return tree().begin();
  }
  iterator end() noexcept {
    return tree().end();
  }
  const_iterator begin() const noexcept {
    return tree().begin();
  }
  const_iterator end() const noexcept {
    return tree().end();
  }
  const_iterator cbegin() const noexcept {
    return tree().begin();
  }
  const_iterator cend() const noexcept {
    return tree().end();
  }

  using tree_t::max_size;
  size_type size() const noexcept {
    return unordered().size();
  }
  using tree_t::empty;

  mixed_multiset_adaptor() = default;
  ~mixed_multiset_adaptor() = default;
  mixed_multiset_adaptor(const mixed_multiset_adaptor &) = delete;
  mixed_multiset_adaptor &operator =(const mixed_multiset_adaptor &) = delete;
  mixed_multiset_adaptor(const mixed_multiset_adaptor &x)
    requires is_copy_constructible_v<unordered_t>
    : unordered_t(x.unordered()) {
    link_to_tree();
  }
  mixed_multiset_adaptor &operator =(const mixed_multiset_adaptor &x)
    requires is_copy_assignable_v<unordered_t> {
    if (this != addressof(x)) {
      unordered() = x.unordered();
      tree() = tree_t(x.tree().key_comp());
      try_link_to_tree();
    }
    return *this;
  }
  mixed_multiset_adaptor(mixed_multiset_adaptor &&) = default;
  mixed_multiset_adaptor &operator =(mixed_multiset_adaptor &&x)
    noexcept(is_nothrow_move_assignable_v<unordered_t>) {
    if constexpr (!TRAITS::hashtable_traits::store_node_allocator::value) {
      unordered() = move(x.unordered());
      tree() = move(x.tree());
      return *this;
    }
    else {
      const allocator_type x_al = x.unordered().get_allocator();
      unordered() = move(x.unordered());
      if (unordered().get_allocator() != x_al) {
        x.tree().unlink();
        tree() = tree_t(x.tree().key_comp());
        try_link_to_tree();
      }
      else
        tree() = move(x.tree());
      return *this;
    }
  }
  friend void swap(this_t &x, this_t &y)
    noexcept(is_nothrow_swappable_v<unordered_t>) {
    inner::mixed_helper::swap(x, y);
  }

  // optional container operations

  // reversible container

  using reverse_iterator = typename tree_t::reverse_iterator;
  using const_reverse_iterator = typename tree_t::const_reverse_iterator;

  reverse_iterator rbegin() {
    return tree().rbegin();
  }
  reverse_iterator rend() {
    return tree().rend();
  }
  const_reverse_iterator rbegin() const {
    return tree().rbegin();
  }
  const_reverse_iterator rend() const {
    return tree().rend();
  }
  const_reverse_iterator crbegin() const {
    return rbegin();
  }
  const_reverse_iterator crend() const {
    return rend();
  }

  // allocator-aware container

  using allocator_type = alloc_t;
  allocator_type get_allocator() const noexcept {
    return unordered().get_allocator();
  }

  explicit mixed_multiset_adaptor(const allocator_type &al) noexcept
    : unordered_t(al) {}
  mixed_multiset_adaptor(const this_t &x, const allocator_type &al)
    : unordered_t(x.unordered(), al) {
    link_to_tree();
  }
  mixed_multiset_adaptor(this_t &&x, const allocator_type &al)
#ifndef RE_NOEXCEPT
    try
#endif
    : unordered_t(move(x.unordered()), al) {
      inner::mixed_helper::move_construct_impl(*this, x, al);
    }
#ifndef RE_NOEXCEPT
    catch (...) {
      x.clear();
      throw;
    }
#endif

  // associative container

  using key_type = typename tree_t::key_type;
  using key_compare = typename tree_t::key_compare;
  using value_compare = typename tree_t::value_compare;

  using tree_t::key_comp;
  using tree_t::value_comp;

  mixed_multiset_adaptor(const HASH &hf, const EQ &eq, const LESS &cmp,
                         const allocator_type &al = allocator_type{})
    : unordered_t(hf, eq, al), tree_t(cmp) {}

  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  mixed_multiset_adaptor(IITR first, IITR last,
                         const HASH &hf, const EQ &eq, const LESS &cmp,
                         const allocator_type &al = allocator_type{})
    : unordered_t(hf, eq, al), tree_t(cmp) {
    insert_range(rng(first, last));
  }
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  mixed_multiset_adaptor(IITR first, IITR last,
                         const allocator_type &al = allocator_type{})
    : mixed_multiset_adaptor(first, last, HASH{}, EQ{}, LESS{}, al) {}
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  void assign(IITR first, IITR last) {
    assign_range(rng(first, last));
  }

  mixed_multiset_adaptor(initializer_list<value_type> il,
                         const HASH &hf, const EQ &eq, const LESS &cmp,
                         const allocator_type &al = allocator_type{})
    : unordered_t(hf, eq, al), tree_t(cmp) {
    insert_range(il);
  }
  mixed_multiset_adaptor(initializer_list<value_type> il,
                         const allocator_type &al = allocator_type{})
    : mixed_multiset_adaptor(il, HASH{}, EQ{}, LESS{}, al) {}
  this_t &operator =(initializer_list<value_type> il) {
    assign_range(il);
    return *this;
  }
  void assign(initializer_list<value_type> il) {
    assign_range(il);
  }

  template <class...S>
  iterator emplace(S &&...s) {
    return inner::mixed_helper::multiset_emplace(*this, forward<S>(s)...);
  }
  template <class...S>
  iterator emplace_hint(const_iterator hint, S &&...s) {
    return inner::mixed_helper::multiset_emplace_hint(*this, hint,
                                                      forward<S>(s)...);
  }
  iterator insert(const value_type &x) {
    return inner::mixed_helper::multiset_insert(*this, x);
  }
  iterator insert(value_type &&x) {
    return inner::mixed_helper::multiset_insert(*this, move(x));
  }
  iterator insert(const_iterator hint, const value_type &x) {
    return inner::mixed_helper::multiset_insert_hint(*this, hint, x);
  }
  iterator insert(const_iterator hint, value_type &&x) {
    return inner::mixed_helper::multiset_insert_hint(*this, hint, move(x));
  }
  template <class IITR>
  void insert(IITR from, IITR to) {
    insert_range(rng(from, to));      
  }
  void insert(initializer_list<value_type> il) {
    insert_range(il);
  }

  using node_type = typename tree_t::node_type;
  node_type extract(const_iterator pos) {
    auto x = unordered().extract(no_ed_unordered_iter(pos));
    tree().unlink(pos);
    return node_type(static_cast<actual_node_pointer>(x.release()),
                     get_allocator());
  }
  node_type extract(const key_type &key) {
    return inner::mixed_helper::extract_key(*this, key);
  }
  template <class K>
  enable_if_t<is_constructible_v<key_type, const K &>, node_type>
  extract(const K &key) {
    return inner::mixed_helper::extract_key(*this, key);
  }
  iterator insert(node_type &&nh) {
    return inner::mixed_helper::multiset_insert_node(*this, move(nh));
  }
  iterator insert(const_iterator hint, node_type &&nh) {
    return inner::mixed_helper::multiset_insert_node_hint
      (*this, hint, move(nh));
  }

  iterator erase(const_iterator pos) {
    const auto ret = tree().unlink(pos);
    unordered().erase(no_ed_unordered_iter(pos));
    return ret;
  }
  iterator erase(const_iterator from, const_iterator to) {
    while (from != to)
      from = erase(from);
    return to.to_mutable();
  }
  void clear() noexcept {
    tree().unlink();
    unordered().clear();
  }

  size_type erase(const key_type &key) {
    return inner::mixed_helper::multiset_erase_key(*this, key);
  }
  template <class K>
  size_type erase(const K &key)
    requires (transparent
              && !is_convertible_v<const K &, iterator>
              && !is_convertible_v<const K &, const_iterator>) {
    return inner::mixed_helper::multiset_erase_key(*this, key);
  }

  size_type remove(const key_type &key) {
    return inner::mixed_helper::multiset_remove_key(*this, key);
  }
  template <class K>
  size_type remove(const K &key) requires transparent {
    return inner::mixed_helper::multiset_remove_key(*this, key);
  }
  template <class UF>
  size_type remove_if(UF eq) {
    return inner::mixed_helper::remove_if(*this, eq);
  }

  template <class HASH2, class EQ2, class LESS2>
  void merge(mixed_set_adaptor<TRAITS, HASH2, EQ2, LESS2> &x) {
    for_each_node(x, next, [&x, this](auto i) {
      try_link(get_key()(*i), [&x, i]() {x.unlink(i); return i;});
    });
  }
  template <class HASH2, class EQ2, class LESS2>
  void merge(mixed_set_adaptor<TRAITS, HASH2, EQ2, LESS2> &&x) {
    merge(x);
  }
  template <class HASH2, class EQ2, class LESS2>
  void merge(mixed_multiset_adaptor<TRAITS, HASH2, EQ2, LESS2> &x) {
    for_each_node(x, next, [&x, this](auto i) {
      try_link(get_key()(*i), [&x, i]() {x.unlink(i); return i;});
    });
  }
  template <class HASH2, class EQ2, class LESS2>
  void merge(mixed_multiset_adaptor<TRAITS, HASH2, EQ2, LESS2> &&x) {
    merge(x);
  }

  template <class K, bool Y = transparent, class = enable_if_t<Y>>
  iterator find(const K &key) {
    return tree_iter(unordered().find(key));
  }
  iterator find(const key_type &key) {
    return tree_iter(unordered().find(key));
  }
  template <class K, bool Y = transparent, class = enable_if_t<Y>>
  const_iterator find(const K &key) const {
    return tree_iter(unordered().find(key));
  }
  const_iterator find(const key_type &key) const {
    return tree_iter(unordered().find(key));
  }

  template <class K, bool Y = transparent, class = enable_if_t<Y>>
  bool contains(const K &key) const {
    return unordered().contains(key);
  }
  bool contains(const key_type &key) const {
    return unordered().contains(key);
  }

  template <class K, bool Y = transparent, class = enable_if_t<Y>>
  size_type count(const K &key) const {
    return unordered().count(key);
  }
  size_type count(const key_type &key) const {
    return unordered().count(key);
  }

  using tree_t::lower_bound;
  using tree_t::upper_bound;

  template <class K, bool Y = transparent, class = enable_if_t<Y>>
  iter_pair<iterator> equal_range(const K &key) {
    return inner::mixed_helper::equal_range(*this, key);
  }
  iter_pair<iterator> equal_range(const key_type &key) {
    return inner::mixed_helper::equal_range(*this, key);
  }
  template <class K, bool Y = transparent, class = enable_if_t<Y>>
  iter_pair<const_iterator> equal_range(const K &key) const {
    return inner::mixed_helper::equal_range(*this, key);
  }
  iter_pair<const_iterator> equal_range(const key_type &key) const {
    return inner::mixed_helper::equal_range(*this, key);
  }

  // extensions

  using tree_t::partition_point;

  using tree_t::find_range;

  template <class...S>
  iterator new_node(S &&...s) {
    return no_ed_tree_iter(unordered().new_node(forward<S>(s)...));
  }
  void delete_node(const_iterator it) noexcept {
    return unordered().delete_node(no_ed_unordered_iter(it));
  }

  iterator unlink(const_iterator it) noexcept {
    unordered().unlink(no_ed_unordered_iter(it));
    return tree().unlink(it);
  }
  iterator unlink(const_iterator from, const_iterator to) noexcept {
    while (from != to)
      from = unlink(from);
    return to.to_mutable();
  }
  void unlink() noexcept {
    unordered().unlink();
    tree().unlink();
  }
  size_type unlink_key(const key_type &key) {
    return inner::mixed_helper::multiset_unlink_key(*this, key);
  }
  template <class K, bool Y = transparent, class = enable_if_t<Y>>
  size_type unlink_key(const K &key) {
    return inner::mixed_helper::multiset_unlink_key(*this, key);
  }
  iterator link(const_iterator it) {
    return try_link(get_key()(*it), bind(copy, it.to_mutable()));
  }
  iterator link(const_iterator hint, const_iterator it) {
    return try_link_hint(hint, get_key()(*it), bind(copy, it.to_mutable()));
  }

  template <class K, class GET_NODE>
  iterator try_link(const K &key, GET_NODE get_node) {
    return inner::mixed_helper::multiset_try_link(*this, key, get_node);
  }
  template <class K, class GET_NODE>
  iterator try_link_hint(const_iterator hint, const K &key,
                         GET_NODE get_node) {
    return inner::mixed_helper::multiset_try_link_hint
      (*this, hint, key, get_node);
  }

  using tree_t::front;
  using tree_t::back;

  using tree_t::root;
  using tree_t::leftmost;
  using tree_t::rightmost;

  using tree_t::nth;

  iterator erase_or_unlink(const_iterator it) noexcept {
    const auto ret = tree().unlink(it);
    unordered().erase_or_unlink(no_ed_unordered_iter(it));
    return ret;
  }

  void unique() {
    list_unique(*this,
                [&](const value_type &x, const value_type &y) {
                  return eq()(get_key()(x), get_key()(y));
                },
                [this](auto it) {return erase_or_unlink(it);});
  }
  template <class EQL>
  void unique(EQL eql) {
    list_unique(*this, eql, [this](auto it) {return erase_or_unlink(it);});
  }

  using hasher = typename unordered_t::hasher;
  using key_equal = typename unordered_t::key_equal;
  using unordered_t::hash_function;
  using unordered_t::key_eq;
  using unordered_t::bucket_count;
  using unordered_t::max_bucket_count;
  using unordered_t::active_bucket_count;
  using unordered_t::bucket_size;
  using unordered_t::bucket_range;
  using unordered_t::bucket;
  using unordered_t::load_factor;
  using unordered_t::max_load_factor;
  using unordered_t::rehash;
  using unordered_t::reserve;
  using local_iterator = typename unordered_t::local_iterator;
  using const_local_iterator = typename unordered_t::const_local_iterator;
  local_iterator begin(size_type n) noexcept {
    return unordered().begin(n);
  }
  local_iterator end(size_type n) noexcept {
    return unordered().end(n);
  }
  const_local_iterator begin(size_type n) const noexcept {
    return unordered().begin(n);
  }
  const_local_iterator end(size_type n) const noexcept {
    return unordered().end(n);
  }
  const_local_iterator cbegin(size_type n) const noexcept {
    return unordered().cbegin(n);
  }
  const_local_iterator cend(size_type n) const noexcept {
    return unordered().cend(n);
  }

  template <class R, class = enable_if_t
            <is_rng<R> && is_constructible_v<value_type, rng_ref<R>>>>
  mixed_multiset_adaptor(from_range_t, R &&r,
                         const allocator_type &al = allocator_type{})
    : unordered_t(al) {
    insert_range(r);
  }
  template <class R, class = enable_if_t
            <is_rng<R> && is_constructible_v<value_type, rng_ref<R>>>>
  mixed_multiset_adaptor(from_range_t, R &&r,
                         const HASH &hf, const EQ &eq, const LESS &cmp,
                         const allocator_type &al = allocator_type{})
    : unordered_t(hf, eq, al), tree_t(cmp) {
    insert_range(r);
  }
  template <class R, class = enable_if_t
            <!is_convertible_v<R &&, const allocator_type &>
             && !is_same_v<decay_t<R>, this_t>
             && is_rng<R> && is_constructible_v<value_type, rng_ref<R>>>>
  explicit mixed_multiset_adaptor(R &&r) {
    insert_range(r);
  }
  template <class R, class = enable_if_t
            <is_rng<R> && is_constructible_v<value_type, rng_ref<R>>>>
  mixed_multiset_adaptor(R &&r, const HASH &hf, const EQ &eq, const LESS &cmp,
                         const allocator_type &al = allocator_type{})
    : unordered_t(hf, eq, al), tree_t(cmp) {
    insert_range(r);
  }
  template <class R, class = enable_if_t
            <!is_same_v<decay_t<R>, this_t>
             && is_rng<R> && is_constructible_v<value_type, rng_ref<R>>>>
  mixed_multiset_adaptor(R &&r, const allocator_type &al)
    : unordered_t(al), tree_t() {
    insert_range(r);
  }

  template <class R>
  enable_if_t<!is_same_v<decay_t<R>, this_t>
              && is_rng<R> && is_constructible_v<value_type, rng_ref<R>>
              && is_assignable_v<value_type &, rng_ref<R>>, this_t &>
  operator =(R &&r) {
    assign_range(r);
    return *this;
  }
  template <class R>
  void assign_range(R &&r) {
    auto guard = exit_fn([&]() {
      tree().unlink();
      try_link_to_tree();
    });
    unordered() = r;
  }
  template <class R>
  void assign(R &&r) {
    assign_range(r);
  }

  template <class IITR_RANGE>
  void insert_range(IITR_RANGE &&r) {
    for (auto &i : iters(r))
      emplace(*i);
  }
  template <class IITR_RANGE>
  enable_if_t<!is_convertible_v<IITR_RANGE &&, value_type &&>
              && !is_convertible_v<IITR_RANGE &&, const value_type &>
              && !is_convertible_v<IITR_RANGE &&, node_type &&>>
  insert(IITR_RANGE &&r) {
    insert_range(r);
  }

  this_t &append() {
    return *this;
  }
  template <class X, class...S>
  this_t &append(X &&x, S &&...s) {
    insert(forward<X>(x));
    return append(forward<S>(s)...);
  }
};
template <class TRAITS, class HASH, class EQ, class LESS>
bool operator ==(const mixed_multiset_adaptor<TRAITS, HASH, EQ, LESS> &x,
                 const mixed_multiset_adaptor<TRAITS, HASH, EQ, LESS> &y) {
  return x.tree() == y.tree();
}
template <class TRAITS, class HASH, class EQ, class LESS>
auto operator <=>(const mixed_multiset_adaptor<TRAITS, HASH, EQ, LESS> &x,
                  const mixed_multiset_adaptor<TRAITS, HASH, EQ, LESS> &y)
  ->decltype(x.tree() <=> y.tree()) {
  return x.tree() <=> y.tree();
}

template <class TRAITS, class HASH, class EQ, class LESS>
class mixed_multimap_adaptor
  : unordered_multimap_adaptor<typename TRAITS::hashtable, HASH, EQ>
  , multimap_adaptor<typename TRAITS::tree, LESS> {
  friend struct inner::mixed_helper;

  template <class R>
  static auto begin(R &&r) requires is_rng<R> {return re::begin(r);}
  template <class R>
  static auto end(R &&r) requires is_rng<R> {return re::end(r);}
  template <class R>
  static auto rbegin(R &&r) {return re::rbegin(r);}
  template <class R>
  static auto rend(R &&r) {return re::rend(r);}
  template <class R>
  static auto size(R &&r) {return re::size(r);}
  template <class R>
  static auto empty(R &&r) {return re::empty(r);}

  using this_t = mixed_multimap_adaptor;
  using unordered_t
    = unordered_multimap_adaptor<typename TRAITS::hashtable, HASH, EQ>;
  using tree_t = multimap_adaptor<typename TRAITS::tree, LESS>;

  using alloc_t = typename unordered_t::allocator_type;
  static_assert(is_same_v
                <typename unordered_t::allocator_type,
                 typename tree_t::allocator_type>);

  static constexpr bool transparent
    = is_transparent_function_v<HASH> && is_transparent_function_v<EQ>
    && is_transparent_function_v<LESS>;

  using actual_node_pointer = typename tree_t::traits::node_pointer;

  using tree_t::get_key;
  using tree_t::get_mapped;
  using tree_t::key_less;
  using unordered_t::hash;
  using unordered_t::eq;

public:
  using tree_iterator = typename tree_t::iterator;
  using tree_const_iterator = typename tree_t::const_iterator;
  using unordered_iterator = typename unordered_t::iterator;
  using unordered_const_iterator = typename unordered_t::const_iterator;

  static auto no_ed_unordered_iter(tree_const_iterator it) noexcept {
    return unordered_iterator(static_cast<actual_node_pointer>(it.node()));
  }
  static auto no_ed_tree_iter(unordered_const_iterator it) noexcept {
    return tree_iterator(static_cast<actual_node_pointer>(it.node()));
  }
  static auto no_ed_unordered_iter(unordered_const_iterator it) noexcept {
    return unordered_iterator(it.node());
  }
  static auto no_ed_tree_iter(tree_const_iterator it) noexcept {
    return tree_iterator(it.node());
  }

  auto unordered_iter(tree_iterator it) const noexcept {
    return it == tree().end()
      ? unordered().end().to_mutable()
      : no_ed_unordered_iter(it);
  }
  auto unordered_iter(tree_const_iterator it) const noexcept {
    return it == tree().end()
      ? unordered().end()
      : unordered_const_iterator(no_ed_unordered_iter(it));
  }
  auto unordered_iter(unordered_iterator it) const noexcept {
    return it;
  }
  auto unordered_iter(unordered_const_iterator it) const noexcept {
    return it;
  }
  auto tree_iter(unordered_iterator it) const noexcept {
    return it == unordered().end()
      ? tree().end().to_mutable()
      : no_ed_tree_iter(it);
  }
  auto tree_iter(unordered_const_iterator it) const noexcept {
    return it == unordered().end()
      ? tree().end()
      : tree_const_iterator(no_ed_tree_iter(it));
  }
  auto tree_iter(tree_iterator it) const noexcept {
    return it;
  }
  auto tree_iter(tree_const_iterator it) const noexcept {
    return it;
  }

private:
  void link_to_tree() {
    for (auto &i : iters(unordered()))
      tree().link(no_ed_tree_iter(i));
  }
  void try_link_to_tree() {
#ifndef RE_NOEXCEPT
    try {
#endif
      for (auto &i : iters(unordered()))
        tree().link(no_ed_tree_iter(i));
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      unordered().clear();
      tree().unlink();
      throw;
    }
#endif
  }

public:
  using traits = TRAITS;
  using node_pointer = typename tree_t::node_pointer;
  using tree_type = tree_t;
  using unordered_type = unordered_t;
  tree_t &tree() noexcept {
    return *this;
  }
  const tree_t &tree() const noexcept {
    return *this;
  }
  unordered_t &unordered() noexcept {
    return *this;
  }
  const unordered_t &unordered() const noexcept {
    return *this;
  }

  using pointer = typename tree_t::pointer;
  using const_pointer = typename tree_t::const_pointer;

  // container

  using value_type = typename tree_t::value_type;
  using reference = typename tree_t::reference;
  using const_reference = typename tree_t::const_reference;

  using iterator = typename tree_t::iterator;
  using const_iterator = typename tree_t::const_iterator;
  using difference_type = typename tree_t::difference_type;
  using size_type = typename tree_t::size_type;

  iterator begin() noexcept {
    return tree().begin();
  }
  iterator end() noexcept {
    return tree().end();
  }
  const_iterator begin() const noexcept {
    return tree().begin();
  }
  const_iterator end() const noexcept {
    return tree().end();
  }
  const_iterator cbegin() const noexcept {
    return tree().begin();
  }
  const_iterator cend() const noexcept {
    return tree().end();
  }

  using tree_t::max_size;
  size_type size() const noexcept {
    return unordered().size();
  }
  using tree_t::empty;

  mixed_multimap_adaptor() = default;
  ~mixed_multimap_adaptor() = default;
  mixed_multimap_adaptor(const mixed_multimap_adaptor &) = delete;
  mixed_multimap_adaptor &operator =(const mixed_multimap_adaptor &) = delete;
  mixed_multimap_adaptor(const mixed_multimap_adaptor &x)
    requires is_copy_constructible_v<unordered_t>
    : unordered_t(x.unordered()) {
    link_to_tree();
  }
  mixed_multimap_adaptor &operator =(const mixed_multimap_adaptor &x)
    requires is_copy_assignable_v<unordered_t> {
    if (this != addressof(x)) {
      unordered() = x.unordered();
      tree() = tree_t(x.tree().key_comp());
      try_link_to_tree();
    }
    return *this;
  }
  mixed_multimap_adaptor(mixed_multimap_adaptor &&) = default;
  mixed_multimap_adaptor &operator =(mixed_multimap_adaptor &&x)
    noexcept(is_nothrow_move_assignable_v<unordered_t>) {
    if constexpr (!TRAITS::hashtable_traits::store_node_allocator::value) {
      unordered() = move(x.unordered());
      tree() = move(x.tree());
      return *this;
    }
    else {
      const allocator_type x_al = x.unordered().get_allocator();
      unordered() = move(x.unordered());
      if (unordered().get_allocator() != x_al) {
        x.tree().unlink();
        tree() = tree_t(x.tree().key_comp());
        try_link_to_tree();
      }
      else
        tree() = move(x.tree());
      return *this;
    }
  }
  friend void swap(this_t &x, this_t &y)
    noexcept(is_nothrow_swappable_v<unordered_t>) {
    inner::mixed_helper::swap(x, y);
  }

  // optional container operations

  // reversible container

  using reverse_iterator = typename tree_t::reverse_iterator;
  using const_reverse_iterator = typename tree_t::const_reverse_iterator;

  reverse_iterator rbegin() {
    return tree().rbegin();
  }
  reverse_iterator rend() {
    return tree().rend();
  }
  const_reverse_iterator rbegin() const {
    return tree().rbegin();
  }
  const_reverse_iterator rend() const {
    return tree().rend();
  }
  const_reverse_iterator crbegin() const {
    return rbegin();
  }
  const_reverse_iterator crend() const {
    return rend();
  }

  // allocator-aware container

  using allocator_type = alloc_t;
  allocator_type get_allocator() const noexcept {
    return unordered().get_allocator();
  }

  explicit mixed_multimap_adaptor(const allocator_type &al) noexcept
    : unordered_t(al) {}
  mixed_multimap_adaptor(const this_t &x, const allocator_type &al)
    : unordered_t(x.unordered(), al) {
    link_to_tree();
  }
  mixed_multimap_adaptor(this_t &&x, const allocator_type &al)
#ifndef RE_NOEXCEPT
    try
#endif
    : unordered_t(move(x.unordered()), al) {
      inner::mixed_helper::move_construct_impl(*this, x, al);
    }
#ifndef RE_NOEXCEPT
    catch (...) {
      x.clear();
      throw;
    }
#endif

  // associative container

  using key_type = typename tree_t::key_type;
  using mapped_type = typename tree_t::mapped_type;
  using key_compare = typename tree_t::key_compare;
  using value_compare = typename tree_t::value_compare;

  using tree_t::key_comp;
  using tree_t::value_comp;

  mixed_multimap_adaptor(const HASH &hf, const EQ &eq, const LESS &cmp,
                         const allocator_type &al = allocator_type{})
    : unordered_t(hf, eq, al), tree_t(cmp) {}

  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  mixed_multimap_adaptor(IITR first, IITR last,
                         const HASH &hf, const EQ &eq, const LESS &cmp,
                         const allocator_type &al = allocator_type{})
    : unordered_t(hf, eq, al), tree_t(cmp) {
    insert_range(rng(first, last));
  }
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  mixed_multimap_adaptor(IITR first, IITR last,
                         const allocator_type &al = allocator_type{})
    : mixed_multimap_adaptor(first, last, HASH{}, EQ{}, LESS{}, al) {}
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  void assign(IITR first, IITR last) {
    assign_range(rng(first, last));
  }

  mixed_multimap_adaptor(initializer_list<value_type> il,
                         const HASH &hf, const EQ &eq, const LESS &cmp,
                         const allocator_type &al = allocator_type{})
    : unordered_t(hf, eq, al), tree_t(cmp) {
    insert_range(il);
  }
  mixed_multimap_adaptor(initializer_list<value_type> il,
                         const allocator_type &al = allocator_type{})
    : mixed_multimap_adaptor(il, HASH{}, EQ{}, LESS{}, al) {}
  this_t &operator =(initializer_list<value_type> il) {
    assign_range(il);
    return *this;
  }
  void assign(initializer_list<value_type> il) {
    assign_range(il);
  }

  template <class...S>
  iterator emplace(S &&...s) {
    return inner::mixed_helper::multiset_emplace(*this, forward<S>(s)...);
  }
  template <class...S>
  iterator emplace_hint(const_iterator hint, S &&...s) {
    return inner::mixed_helper::multiset_emplace_hint(*this, hint,
                                                      forward<S>(s)...);
  }
  iterator insert(const value_type &x) {
    return inner::mixed_helper::multiset_insert(*this, x);
  }
  iterator insert(value_type &&x) {
    return inner::mixed_helper::multiset_insert(*this, move(x));
  }
  iterator insert(const_iterator hint, const value_type &x) {
    return inner::mixed_helper::multiset_insert_hint(*this, hint, x);
  }
  iterator insert(const_iterator hint, value_type &&x) {
    return inner::mixed_helper::multiset_insert_hint(*this, hint, move(x));
  }
  template <class IITR>
  void insert(IITR from, IITR to) {
    insert_range(rng(from, to));      
  }
  void insert(initializer_list<value_type> il) {
    insert_range(il);
  }

  using node_type = typename tree_t::node_type;
  node_type extract(const_iterator pos) {
    auto x = unordered().extract(no_ed_unordered_iter(pos));
    tree().unlink(pos);
    return node_type(static_cast<actual_node_pointer>(x.release()),
                     get_allocator());
  }
  node_type extract(const key_type &key) {
    return inner::mixed_helper::extract_key(*this, key);
  }
  template <class K>
  enable_if_t<is_constructible_v<key_type, const K &>, node_type>
  extract(const K &key) {
    return inner::mixed_helper::extract_key(*this, key);
  }
  iterator insert(node_type &&nh) {
    return inner::mixed_helper::multiset_insert_node(*this, move(nh));
  }
  iterator insert(const_iterator hint, node_type &&nh) {
    return inner::mixed_helper::multiset_insert_node_hint
      (*this, hint, move(nh));
  }

  iterator erase(const_iterator pos) {
    const auto ret = tree().unlink(pos);
    unordered().erase(no_ed_unordered_iter(pos));
    return ret;
  }
  iterator erase(const_iterator from, const_iterator to) {
    while (from != to)
      from = erase(from);
    return to.to_mutable();
  }
  void clear() noexcept {
    tree().unlink();
    unordered().clear();
  }

  size_type erase(const key_type &key) {
    return inner::mixed_helper::multiset_erase_key(*this, key);
  }
  template <class K>
  size_type erase(const K &key)
    requires (transparent
              && !is_convertible_v<const K &, iterator>
              && !is_convertible_v<const K &, const_iterator>) {
    return inner::mixed_helper::multiset_erase_key(*this, key);
  }

  size_type remove(const key_type &key) {
    return inner::mixed_helper::multiset_remove_key(*this, key);
  }
  template <class K>
  size_type remove(const K &key) requires transparent {
    return inner::mixed_helper::multiset_remove_key(*this, key);
  }
  template <class UF>
  size_type remove_if(UF eq) {
    return inner::mixed_helper::remove_if(*this, eq);
  }

  template <class HASH2, class EQ2, class LESS2>
  void merge(mixed_map_adaptor<TRAITS, HASH2, EQ2, LESS2> &x) {
    for_each_node(x, next, [&x, this](auto i) {
      try_link(get_key()(*i), [&x, i]() {x.unlink(i); return i;});
    });
  }
  template <class HASH2, class EQ2, class LESS2>
  void merge(mixed_map_adaptor<TRAITS, HASH2, EQ2, LESS2> &&x) {
    merge(x);
  }
  template <class HASH2, class EQ2, class LESS2>
  void merge(mixed_multimap_adaptor<TRAITS, HASH2, EQ2, LESS2> &x) {
    for_each_node(x, next, [&x, this](auto i) {
      try_link(get_key()(*i), [&x, i]() {x.unlink(i); return i;});
    });
  }
  template <class HASH2, class EQ2, class LESS2>
  void merge(mixed_multimap_adaptor<TRAITS, HASH2, EQ2, LESS2> &&x) {
    merge(x);
  }

  template <class K, bool Y = transparent, class = enable_if_t<Y>>
  iterator find(const K &key) {
    return tree_iter(unordered().find(key));
  }
  iterator find(const key_type &key) {
    return tree_iter(unordered().find(key));
  }
  template <class K, bool Y = transparent, class = enable_if_t<Y>>
  const_iterator find(const K &key) const {
    return tree_iter(unordered().find(key));
  }
  const_iterator find(const key_type &key) const {
    return tree_iter(unordered().find(key));
  }

  template <class K, bool Y = transparent, class = enable_if_t<Y>>
  bool contains(const K &key) const {
    return unordered().contains(key);
  }
  bool contains(const key_type &key) const {
    return unordered().contains(key);
  }

  template <class K, bool Y = transparent, class = enable_if_t<Y>>
  size_type count(const K &key) const {
    return unordered().count(key);
  }
  size_type count(const key_type &key) const {
    return unordered().count(key);
  }

  using tree_t::lower_bound;
  using tree_t::upper_bound;

  template <class K, bool Y = transparent, class = enable_if_t<Y>>
  iter_pair<iterator> equal_range(const K &key) {
    return inner::mixed_helper::equal_range(*this, key);
  }
  iter_pair<iterator> equal_range(const key_type &key) {
    return inner::mixed_helper::equal_range(*this, key);
  }
  template <class K, bool Y = transparent, class = enable_if_t<Y>>
  iter_pair<const_iterator> equal_range(const K &key) const {
    return inner::mixed_helper::equal_range(*this, key);
  }
  iter_pair<const_iterator> equal_range(const key_type &key) const {
    return inner::mixed_helper::equal_range(*this, key);
  }

  // extensions

  using tree_t::partition_point;

  using tree_t::find_range;

  template <class...S>
  iterator new_node(S &&...s) {
    return no_ed_tree_iter(unordered().new_node(forward<S>(s)...));
  }
  void delete_node(const_iterator it) noexcept {
    return unordered().delete_node(no_ed_unordered_iter(it));
  }

  iterator unlink(const_iterator it) noexcept {
    unordered().unlink(no_ed_unordered_iter(it));
    return tree().unlink(it);
  }
  iterator unlink(const_iterator from, const_iterator to) noexcept {
    while (from != to)
      from = unlink(from);
    return to.to_mutable();
  }
  void unlink() noexcept {
    unordered().unlink();
    tree().unlink();
  }
  size_type unlink_key(const key_type &key) {
    return inner::mixed_helper::multiset_unlink_key(*this, key);
  }
  template <class K, bool Y = transparent, class = enable_if_t<Y>>
  size_type unlink_key(const K &key) {
    return inner::mixed_helper::multiset_unlink_key(*this, key);
  }
  iterator link(const_iterator it) {
    return try_link(get_key()(*it), bind(copy, it.to_mutable()));
  }
  iterator link(const_iterator hint, const_iterator it) {
    return try_link_hint(hint, get_key()(*it), bind(copy, it.to_mutable()));
  }

  template <class K, class GET_NODE>
  iterator try_link(const K &key, GET_NODE get_node) {
    return inner::mixed_helper::multiset_try_link(*this, key, get_node);
  }
  template <class K, class GET_NODE>
  iterator try_link_hint(const_iterator hint,
                         const K &key, GET_NODE get_node) {
    return inner::mixed_helper::multiset_try_link_hint
      (*this, hint, key, get_node);
  }

  using tree_t::front;
  using tree_t::back;

  using tree_t::root;
  using tree_t::leftmost;
  using tree_t::rightmost;

  using tree_t::nth;

  iterator erase_or_unlink(const_iterator it) noexcept {
    const auto ret = tree().unlink(it);
    unordered().erase_or_unlink(no_ed_unordered_iter(it));
    return ret;
  }

  void unique() {
    list_unique(*this,
                [&](const value_type &x, const value_type &y) {
                  return eq()(get_key()(x), get_key()(y));
                },
                [this](auto it) {return erase_or_unlink(it);});
  }
  template <class EQL>
  void unique(EQL eql) {
    list_unique(*this, eql, [this](auto it) {return erase_or_unlink(it);});
  }

  using hasher = typename unordered_t::hasher;
  using key_equal = typename unordered_t::key_equal;
  using unordered_t::hash_function;
  using unordered_t::key_eq;
  using unordered_t::bucket_count;
  using unordered_t::max_bucket_count;
  using unordered_t::active_bucket_count;
  using unordered_t::bucket_size;
  using unordered_t::bucket_range;
  using unordered_t::bucket;
  using unordered_t::load_factor;
  using unordered_t::max_load_factor;
  using unordered_t::rehash;
  using unordered_t::reserve;
  using local_iterator = typename unordered_t::local_iterator;
  using const_local_iterator = typename unordered_t::const_local_iterator;
  local_iterator begin(size_type n) noexcept {
    return unordered().begin(n);
  }
  local_iterator end(size_type n) noexcept {
    return unordered().end(n);
  }
  const_local_iterator begin(size_type n) const noexcept {
    return unordered().begin(n);
  }
  const_local_iterator end(size_type n) const noexcept {
    return unordered().end(n);
  }
  const_local_iterator cbegin(size_type n) const noexcept {
    return unordered().cbegin(n);
  }
  const_local_iterator cend(size_type n) const noexcept {
    return unordered().cend(n);
  }

  template <class R, class = enable_if_t
            <is_rng<R> && is_constructible_v<value_type, rng_ref<R>>>>
  mixed_multimap_adaptor(from_range_t, R &&r,
                         const allocator_type &al = allocator_type{})
    : unordered_t(al) {
    insert_range(r);
  }
  template <class R, class = enable_if_t
            <is_rng<R> && is_constructible_v<value_type, rng_ref<R>>>>
  mixed_multimap_adaptor(from_range_t, R &&r,
                         const HASH &hf, const EQ &eq, const LESS &cmp,
                         const allocator_type &al = allocator_type{})
    : unordered_t(hf, eq, al), tree_t(cmp) {
    insert_range(r);
  }
  template <class R, class = enable_if_t
            <!is_convertible_v<R &&, const allocator_type &>
             && !is_same_v<decay_t<R>, this_t>
             && is_rng<R> && is_constructible_v<value_type, rng_ref<R>>>>
  explicit mixed_multimap_adaptor(R &&r) {
    insert_range(r);
  }
  template <class R, class = enable_if_t
            <is_rng<R> && is_constructible_v<value_type, rng_ref<R>>>>
  mixed_multimap_adaptor(R &&r, const HASH &hf, const EQ &eq, const LESS &cmp,
                         const allocator_type &al = allocator_type{})
    : unordered_t(hf, eq, al), tree_t(cmp) {
    insert_range(r);
  }
  template <class R, class = enable_if_t
            <!is_same_v<decay_t<R>, this_t>
             && is_rng<R> && is_constructible_v<value_type, rng_ref<R>>>>
  mixed_multimap_adaptor(R &&r, const allocator_type &al)
    : unordered_t(al), tree_t() {
    insert_range(r);
  }
  template <class R>
  enable_if_t<!is_same_v<decay_t<R>, this_t>
              && is_rng<R> && is_constructible_v<value_type, rng_ref<R>>
              && is_assignable_v<value_type &, rng_ref<R>>, this_t &>
  operator =(R &&r) {
    assign_range(r);
    return *this;
  }
  template <class R>
  void assign_range(R &&r) {
    auto guard = exit_fn([&]() {
      tree().unlink();
      try_link_to_tree();
    });
    unordered() = r;
  }
  template <class R>
  void assign(R &&r) {
    assign_range(r);
  }

  template <class IITR_RANGE>
  void insert_range(IITR_RANGE &&r) {
    for (auto &i : iters(r))
      emplace(*i);
  }
  template <class IITR_RANGE>
  enable_if_t<!is_convertible_v<IITR_RANGE &&, value_type &&>
              && !is_convertible_v<IITR_RANGE &&, const value_type &>
              && !is_convertible_v<IITR_RANGE &&, node_type &&>>
  insert(IITR_RANGE &&r) {
    insert_range(r);
  }

  this_t &append() {
    return *this;
  }
  template <class X, class...S>
  this_t &append(X &&x, S &&...s) {
    insert(forward<X>(x));
    return append(forward<S>(s)...);
  }
};
template <class TRAITS, class HASH, class EQ, class LESS>
bool operator ==(const mixed_multimap_adaptor<TRAITS, HASH, EQ, LESS> &x,
                 const mixed_multimap_adaptor<TRAITS, HASH, EQ, LESS> &y) {
  return x.tree() == y.tree();
}
template <class TRAITS, class HASH, class EQ, class LESS>
auto operator <=>(const mixed_multimap_adaptor<TRAITS, HASH, EQ, LESS> &x,
                  const mixed_multimap_adaptor<TRAITS, HASH, EQ, LESS> &y)
  ->decltype(x.tree() <=> y.tree()) {
  return x.tree() <=> y.tree();
}

}
// mixed_(set/map/multiset/multimap)
namespace re {

template <class KEY,
          class HASH = hash<KEY>, class EQ = equal_to<KEY>,
          class LESS = less<KEY>,
          class AL = default_allocator<KEY>>
using mixed_set = mixed_set_adaptor<mxdsett<KEY, AL>, HASH, EQ, LESS>;
template <class KEY,
          class HASH = hash<KEY>, class EQ = equal_to<KEY>,
          class LESS = less<KEY>,
          class AL = default_allocator<KEY>>
using mixed_multiset = mixed_multiset_adaptor<mxdsett<KEY, AL>, HASH, EQ, LESS>;
template <class KEY, class MAPPED,
          class HASH = hash<KEY>, class EQ = equal_to<KEY>,
          class LESS = less<KEY>,
          class AL = default_allocator<pair<KEY, MAPPED>>>
using mixed_map = mixed_map_adaptor<mxdmapt<pair<KEY, MAPPED>, AL>,
                                    HASH, EQ, LESS>;
template <class KEY, class MAPPED,
          class HASH = hash<KEY>, class EQ = equal_to<KEY>,
          class LESS = less<KEY>,
          class AL = default_allocator<pair<KEY, MAPPED>>>
using mixed_multimap = mixed_multimap_adaptor<mxdmapt<pair<KEY, MAPPED>, AL>,
                                              HASH, EQ, LESS>;
template <class KEY,
          class HASH = hash<KEY>, class EQ = equal_to<KEY>,
          class LESS = less<KEY>,
          class AL = default_allocator<KEY>>
using mixed_ranked_set = mixed_set_adaptor<mxdrkdsett<KEY, AL>, HASH, EQ, LESS>;
template <class KEY,
          class HASH = hash<KEY>, class EQ = equal_to<KEY>,
          class LESS = less<KEY>,
          class AL = default_allocator<KEY>>
using mixed_ranked_multiset = mixed_multiset_adaptor<mxdrkdsett<KEY, AL>,
                                                     HASH, EQ, LESS>;
template <class KEY, class MAPPED,
          class HASH = hash<KEY>, class EQ = equal_to<KEY>,
          class LESS = less<KEY>,
          class AL = default_allocator<pair<KEY, MAPPED>>>
using mixed_ranked_map = mixed_map_adaptor<mxdrkdmapt<pair<KEY, MAPPED>, AL>,
                                           HASH, EQ, LESS>;
template <class KEY, class MAPPED,
          class HASH = hash<KEY>, class EQ = equal_to<KEY>,
          class LESS = less<KEY>,
          class AL = default_allocator<pair<KEY, MAPPED>>>
using mixed_ranked_multimap = mixed_multimap_adaptor
  <mxdrkdmapt<pair<KEY, MAPPED>, AL>, HASH, EQ, LESS>;

}

// stable_vector
// limited_stable_vector
namespace re {

template <class, size_t>
class stable_vector_adaptor;

template <size_t ID = 0, class VOID_PTR = void *>
struct join_stable_vector {
  pointer_rebind_t<VOID_PTR,
                   pointer_rebind_t<VOID_PTR, join_stable_vector>> iter;
};
template <class T, class AL = default_allocator<T>>
struct stable_vector_node : join_stable_vector<0, alloc_void_ptr<AL>> {
  alignas(T) byte data[sizeof(T)];

  T &operator *() const {
    return *reinterpret_cast<T *>(addressof(data));
  }
  T *operator ->() const {
    return reinterpret_cast<T *>(addressof(data));
  }
};

template <class NODE_T, size_t ID = 0, bool STORE_NODE_ALLOCATOR = false,
          class AL = default_allocator<NODE_T>>
struct stable_vector_traits {
  using value_type = alloc_vt<AL>;
  using allocator_type = AL;
  using node_type = NODE_T;
  using node_pointer = alloc_rebind_ptr<AL, node_type>;
  using node_base_type = join_stable_vector<ID, alloc_void_ptr<AL>>;
  using node_base_pointer = alloc_rebind_ptr<AL, node_base_type>;
  using difference_type = alloc_dft<AL>;
  using size_type = alloc_szt<AL>;

  using id = size_constant<ID>;
  using store_node_allocator = bool_constant<STORE_NODE_ALLOCATOR>;
  using store_allocator = true_type;

  using node_base_pointer_pointer = alloc_rebind_ptr<AL, node_base_pointer>;

  static node_base_pointer_pointer index_iter(node_base_pointer p) {
    return p->iter;
  }
  static void index_iter(node_base_pointer p, node_base_pointer_pointer x) {
    p->iter = x;
  }

  template <class VT = value_type>
  static enable_if_t<!is_same_v<VT, node_type>, value_type *>
  data(node_base_pointer p) {
    return reinterpret_cast<value_type *>
      (addressof(static_cast<node_pointer>(p)->data));
  }
  template <class VT = value_type>
  static enable_if_t<is_same_v<VT, node_type>, value_type *>
  data(node_base_pointer p) {
    return to_address(static_cast<node_pointer>(p));
  }

  template <class...S, class VT = value_type>
  static enable_if_t<!is_same_v<VT, node_type>, node_base_pointer>
  new_node(AL &al, S &&...s) {
    return allocator_wrapper<AL>(al)
      .template new_node<node_type>(forward<S>(s)...);
  }
  template <class VT = value_type>
  static enable_if_t<!is_same_v<VT, node_type>>
  delete_node(AL &al, node_base_pointer p) noexcept {
    allocator_wrapper<AL>(al).delete_node(static_cast<node_pointer>(p));
  }

  template <class...S, class VT = value_type>
  static enable_if_t<is_same_v<VT, node_type>, node_base_pointer>
  new_node(AL &al, S &&...s) {
    return static_cast<node_base_pointer>
      (allocator_wrapper<AL>(al).new_1(forward<S>(s)...));
  }
  template <class VT = value_type>
  static enable_if_t<is_same_v<VT, node_type>>
  delete_node(AL &al, node_base_pointer p) noexcept {
    allocator_wrapper<AL>(al).delete_1(static_cast<node_pointer>(p));
  }
};

template <class TRAITS, size_t N = 0>
class stable_vector_adaptor;
namespace inner {

template <class TRAITS, size_t N = 0u>
struct stable_vector_data {
  static constexpr int p{};
  static constexpr int n{};
  static constexpr int placeholder0{};

  mutable typename TRAITS::node_base_pointer buf[N + 1u];
  mutable typename TRAITS::node_base_type placeholder;
};
template <class TRAITS>
struct stable_vector_data<TRAITS, 0u> {
  static constexpr int buf{};

  typename TRAITS::node_base_pointer_pointer p;
  typename TRAITS::size_type n;
  typename TRAITS::node_base_pointer placeholder0;
  mutable typename TRAITS::node_base_type placeholder;
};

template <class TRAITS>
class stable_vector_node_handle : node_handle<TRAITS> {
  using base_t = node_handle<TRAITS>;
  using this_t = stable_vector_node_handle;

public:
  using base_t::allocator_type;

  stable_vector_node_handle() noexcept = default;
  stable_vector_node_handle(const this_t &) = delete;
  stable_vector_node_handle &operator =(const this_t &) = delete;
  stable_vector_node_handle(this_t &&) noexcept = default;
  stable_vector_node_handle &operator =(this_t &&) = default;
  friend void swap(this_t &x, this_t &y)
    noexcept(is_nothrow_swappable_v<base_t>) {
    adl_swap(static_cast<base_t &>(x), static_cast<base_t &>(y));
  }

  explicit stable_vector_node_handle(typename base_t::node_pointer p,
                                     const typename base_t::alloc_t &al)
    : base_t(p, al) {}

  using base_t::get_allocator;
  using base_t::empty;
  using base_t::operator bool;
  using base_t::get;
  using base_t::release;
  using base_t::operator *;
};

template <class T, class TRAITS>
class stable_vector_iterator {
  template <class, size_t N>
  friend class re::stable_vector_adaptor;
  template <class, class>
  friend class stable_vector_iterator;

  using this_t = stable_vector_iterator;

  using node_base_pointer = typename TRAITS::node_base_pointer;
  using node_base_pointer_pointer = typename TRAITS::node_base_pointer_pointer;
  node_base_pointer p{};

public:
  using value_type = remove_const_t<T>;
  using reference = T &;
  using pointer = T *;
  using difference_type = typename TRAITS::difference_type;
  using iterator_category = random_access_iterator_tag;

  stable_vector_iterator() = default;
  ~stable_vector_iterator() = default;
  stable_vector_iterator(const stable_vector_iterator &) = default;
  stable_vector_iterator &operator =(const stable_vector_iterator &) = default;
  stable_vector_iterator(stable_vector_iterator &&) = default;
  stable_vector_iterator &operator =(stable_vector_iterator &&) = default;
  friend void swap(stable_vector_iterator &x,
                   stable_vector_iterator &y) noexcept {
    adl_swap(x.p, y.p);
  }

  template <class TT = T, class = enable_if_t<is_const_v<TT>>>
  stable_vector_iterator(stable_vector_iterator<remove_const_t<TT>, TRAITS> x)
    : p(x.p) {}
  template <class TT = T, class = enable_if_t<is_const_v<TT>>>
  this_t &operator =(stable_vector_iterator<remove_const_t<TT>, TRAITS> x) {
    p = x.p;
    return *this;
  }

  explicit stable_vector_iterator(node_base_pointer p) : p(p) {}
  node_base_pointer node() const {
    return p;
  }
  auto to_mutable() const requires is_const_v<T> {
    return stable_vector_iterator<remove_const_t<T>, TRAITS>(p);
  }

private:
  node_base_pointer_pointer index_iter() const {
    return TRAITS::index_iter(p);
  }
  void index_iter(node_base_pointer_pointer x) const {
    return TRAITS::index_iter(p, x);
  }

public:
  reference operator *() const {
    return *TRAITS::data(p);
  }
  pointer operator ->() const {
    return TRAITS::data(p);
  }

  this_t &operator ++() {
    p = *next(index_iter());
    return *this;
  }
  this_t operator ++(int) {
    return iter_post_increment(*this);
  }

  this_t &operator --() {
    p = *prev(index_iter());
    return *this;
  }
  this_t operator --(int) {
    return iter_post_decrement(*this);
  }

  this_t &operator +=(difference_type i) {
    p = *(index_iter() + i);
    return *this;
  }
  this_t &operator -=(difference_type i) {
    p = *(index_iter() - i);
    return *this;
  }
  reference operator [](difference_type i) const {
    return *(copy(*this) += i);
  }

  template <class X, class Y, class Z>
  friend auto operator <=>(stable_vector_iterator<X, Z> x,
                           stable_vector_iterator<Y, Z> y)
    ->decltype(x.index_iter() <=> y.index_iter())
    requires is_same_v<remove_const_t<X>, remove_const_t<Y>>;
  template <class X, class Y, class Z>
  friend enable_if_t<is_same_v<remove_const_t<X>, remove_const_t<Y>>,
                     itr_dft<stable_vector_iterator<X, Z>>>
  operator -(stable_vector_iterator<X, Z>,
             stable_vector_iterator<Y, Z>);
};
template <class T, class U, class TRAITS>
enable_if_t<is_same_v<remove_const_t<T>, remove_const_t<U>>, bool>
operator ==(stable_vector_iterator<T, TRAITS> x,
            stable_vector_iterator<U, TRAITS> y) {
  return x.node() == y.node();
}
template <class X, class Y, class Z>
auto operator <=>(stable_vector_iterator<X, Z> x,
                  stable_vector_iterator<Y, Z> y)
  ->decltype(x.index_iter() <=> y.index_iter())
  requires is_same_v<remove_const_t<X>, remove_const_t<Y>> {
  return x.index_iter() <=> y.index_iter();
}
template <class X, class Y, class Z>
enable_if_t<is_same_v<remove_const_t<X>, remove_const_t<Y>>,
            itr_dft<stable_vector_iterator<X, Z>>>
operator -(stable_vector_iterator<X, Z> x,
           stable_vector_iterator<Y, Z> y) {
  return x.index_iter() - y.index_iter();
}
template <class T, class TRAITS>
stable_vector_iterator<T, TRAITS>
operator -(stable_vector_iterator<T, TRAITS> x,
           itr_dft<stable_vector_iterator<T, TRAITS>> i) {
  return copy(x) -= i;
}
template <class T, class TRAITS>
stable_vector_iterator<T, TRAITS>
operator +(stable_vector_iterator<T, TRAITS> x,
           itr_dft<stable_vector_iterator<T, TRAITS>> i) {
  return copy(x) += i;
}
template <class T, class TRAITS>
stable_vector_iterator<T, TRAITS>
operator +(itr_dft<stable_vector_iterator<T, TRAITS>> i,
           stable_vector_iterator<T, TRAITS> x) {
  return copy(x) += i;
}
template <class T, class TRAITS>
bool operator ==(stable_vector_iterator<T, TRAITS> x, nullptr_t) {
  return x.node() == nullptr;
}

}
template <class TRAITS, size_t N>
class stable_vector_adaptor
  : inner::stable_vector_data<TRAITS, N>
  , allocator_wrapper<typename TRAITS::allocator_type> {
  template <class, size_t>
  friend class stable_vector_adaptor;

  using this_t = stable_vector_adaptor;

  using node_base_t = typename TRAITS::node_base_type;
  using node_t = typename TRAITS::node_type;
  using node_base_ptr = typename TRAITS::node_base_pointer;
  using node_ptr = typename TRAITS::node_pointer;
  using node_base_ptr_ptr = typename TRAITS::node_base_pointer_pointer;
  using alloc_t = typename TRAITS::allocator_type;

  using data_t = inner::stable_vector_data<TRAITS, N>;
  using data_t::p;
  using data_t::n;
  using data_t::buf;
  using data_t::placeholder0;
  using data_t::placeholder;

  using alw_t = allocator_wrapper<alloc_t>;
  using alw_t::allocate;
  using alw_t::construct;
  using alw_t::destroy;
  using alw_t::deallocate;
  using alw_t::destroy_fn;
  using alw_t::new_1;
  using alw_t::new_n;
  using alw_t::delete_1;
  using alw_t::delete_n;
  using alw_t::make_temporary;
  using alw_t::uninitialized_fill;
  using alw_t::uninitialized_copy;
  using alw_t::uninitialized_move;
  using alw_t::uninitialized_fully_move;
  using alw_t::fully_move;

  template <class R>
  static auto begin(R &&r) {return re::begin(r);}
  template <class R>
  static auto end(R &&r) {return re::end(r);}
  template <class R>
  static auto rbegin(R &&r) {return re::rbegin(r);}
  template <class R>
  static auto rend(R &&r) {return re::rend(r);}
  template <class R>
  static auto size(R &&r) {return re::size(r);}
  template <class R>
  static auto empty(R &&r) {return re::empty(r);}

public:
  using pointer = alloc_ptr<typename TRAITS::allocator_type>;
  using const_pointer = alloc_cptr<typename TRAITS::allocator_type>;

  // container

  using value_type = typename TRAITS::value_type;
  using reference = value_type &;
  using const_reference = const value_type &;

  using iterator = inner::stable_vector_iterator<value_type, TRAITS>;
  using const_iterator
    = inner::stable_vector_iterator<const value_type, TRAITS>;
  using difference_type = typename TRAITS::difference_type;
  using size_type = typename TRAITS::size_type;

  iterator begin() noexcept {
    return iterator(*p);
  }
  iterator end() noexcept {
    return iterator(addr(placeholder));
  }
  const_iterator begin() const noexcept {
    return const_iterator(*p);
  }
  const_iterator end() const noexcept {
    return const_iterator(addr(placeholder));
  }

  iterator begin() noexcept requires (N != 0u) {
    return iterator(buf[0]);
  }
  iterator end() noexcept requires (N != 0u) {
    return iterator(addr(placeholder));
  }
  const_iterator begin() const noexcept requires (N != 0u) {
    return const_iterator(buf[0]);
  }
  const_iterator end() const noexcept requires (N != 0u) {
    return const_iterator(addr(placeholder));
  }

  const_iterator cbegin() const noexcept {
    return begin();
  }
  const_iterator cend() const noexcept {
    return end();
  }

  size_type max_size() const noexcept {
    return container_regular_max_size<this_t>();
  }
  size_type max_size() const noexcept requires (N != 0u) {
    return N;
  }
  size_type size() const noexcept {
    return end() - begin();
  }
  bool empty() const noexcept {
    return begin() == end();
  }

private:
  // inner implements

  auto ptr_alw() const noexcept {
    return alw_t::template rebind<node_base_ptr>();
  }

  friend class allocator_aware_container_ownership<this_t>;
  const alloc_t &alloc_ref() const noexcept {
    return alw_t::get();
  }
  alloc_t &alloc_ref() noexcept {
    return alw_t::get();
  }
  void new_data() noexcept {
    p = addr(placeholder0);
    n = 0;
    placeholder0 = addr(placeholder);
    placeholder.iter = p;
  }
  void new_data() noexcept requires (N != 0u) {
    node_sync(end(), buf[0]);
  }

  void delete_data() noexcept
    requires (N == 0u && TRAITS::store_node_allocator::value) {
    if (n != 0) {
      for (auto &i : iters(p, p + size()))
        delete_node(iterator(*i));
      ptr_alw().delete_n(p, n + 1u);
    }
  }
  void delete_data() noexcept
    requires (N == 0u && !TRAITS::store_node_allocator::value) {
    if (n != 0)
      ptr_alw().delete_n(p, n + 1u);
  }
  void delete_data() noexcept
    requires (N != 0u && TRAITS::store_node_allocator::value) {
    for (auto i : rng(addr(buf[0]), placeholder.iter))
      delete_node(iterator(i));
  }
  void delete_data() noexcept
    requires (N != 0u && !TRAITS::store_node_allocator::value) {}

  void new_data(const this_t &v) {
    construct_from_range_impl(v);
  }

  void assign_data(const this_t &v) {
    assign_range_impl(v);
  }

  void new_data(this_t &&v) noexcept {
    if (v.n == 0u)
      new_data();
    else {
      const auto v_sz = v.size();
      p = v.p;
      n = v.n;
      node_sync(end(), p + v_sz);
      v.new_data();
    }
  }
  void new_data(this_t &&v) noexcept requires (N != 0u) {
    const auto v_sz = v.size();
    copy(rng(addr(v.buf[0]), v.placeholder.iter), begin(buf));
    for (auto &i : iters(addr(buf[0]), addr(buf[0]) + v_sz))
      iterator(*i).index_iter(i);
    node_sync(end(), buf[v_sz]);
    v.new_data();
  }

  void new_data_individually(this_t &&v)
    requires TRAITS::store_node_allocator::value {
    construct_from_range_impl(move_rng(v));
    v.delete_data();
    v.new_data();
  }
  void new_data_individually(this_t &&v)
    requires (!TRAITS::store_node_allocator::value && N == 0u) {
    if (v.n == 0u)
      new_data();
    else {
      p = ptr_alw().new_n((n = v.n) + 1u);
      auto it = p;
      for (auto &i : iters(v)) {
        node_sync(i, it);
        ++it;
      }
      node_sync(end(), it);
      v.ptr_alw().delete_n(v.p, v.n + 1u);
      v.new_data();
    }
  }
  void new_data_individually(this_t &&v)
    requires (!TRAITS::store_node_allocator::value && N != 0u) {
    new_data(move(v));
  }

  void assign_data_individually(this_t &&v)
    requires TRAITS::store_node_allocator::value {
    assign_range_impl(move_rng(v));
    v.delete_data();
    v.new_data();
  }
  void assign_data_individually(this_t &&v)
    requires (!TRAITS::store_node_allocator::value && N == 0u) {
    if (v.n == 0u) {
      delete_data();
      new_data();
    }
    else {
      if (n < v.n) {
        const auto pp = ptr_alw().new_n(v.n + 1u);
        delete_data();
        p = pp;
        n = v.n;
      }
      auto it = p;
      for (auto &i : iters(v)) {
        node_sync(i, it);
        ++it;
      }
      node_sync(end(), it);
      v.ptr_alw().delete_n(v.p, v.n + 1u);
      v.new_data();
    }
  }
  void assign_data_individually(this_t &&v)
    requires (!TRAITS::store_node_allocator::value && N != 0u) {
    new_data(move(v));
  }

  void swap_data(this_t &v) noexcept {
    if (this == addressof(v))
      return;
    const auto sz = size();
    const auto v_sz = v.size();
    if (n == 0u) {
      if (v.n == 0u)
        return;
      else {
        p = v.p;
        n = v.n;
        node_sync(end(), p + v_sz);
        v.new_data();
      }
    }
    else {
      if (v.n == 0u) {
        v.p = p;
        v.n = n;
        node_sync(v.end(), v.p + sz);
        new_data();
      }
      else {
        adl_swap(p, v.p);
        adl_swap(n, v.n);
        node_sync(end(), p + v_sz);
        node_sync(v.end(), v.p + sz);
      }
    }
  }
  void swap_data(this_t &v) noexcept requires (N != 0u) {
    const auto sz = size();
    const auto v_sz = v.size();
    swap_ranges(buf, begin(v.buf));
    placeholder.iter = addr(buf[v_sz] = addr(placeholder));
    v.placeholder.iter = addr(v.buf[sz] = addr(v.placeholder));
    for (auto &i : iters(addr(buf[0]), placeholder.iter))
      (*i)->iter = i;
    for (auto &i : iters(addr(v.buf[0]), v.placeholder.iter))
      (*i)->iter = i;
  }

  template <class REF>
  static auto addr(REF &ref) noexcept {
    return pointer_to<pointer>(ref);
  }

  auto index_array_begin() const noexcept {
    return addr(buf[0]);
  }
  auto index_array_begin() const noexcept requires (N == 0u) {
    return p;
  }

  static void node_sync(const_iterator x, node_base_ptr_ptr pp) noexcept {
    x.index_iter(pp);
    *pp = x.node();
  }
  static void node_sync(const_iterator x, node_base_ptr &pp) noexcept {
    x.index_iter(addr(pp));
    pp = x.node();
  }

  // reallocate_impl(n) requires: nn >= size() && nn > 0
  void reallocate_impl(size_type nn) {
    auto new_p = ptr_alw().new_n(nn + 1u);
    const auto sz = size();
    for_each(rng(p, sz), new_p, [](auto &x, auto &y) {
      y = x;
      iterator(y).index_iter(addr(y));
    });
    if (n != 0)
      ptr_alw().delete_n(p, n + 1u);
    p = new_p;
    n = nn;
    node_sync(end(), p + sz);
  }

  template <class UINT>
  void reserve_raw_space_at_least(UINT nn) {
    static_assert(is_integral_v<UINT> && is_unsigned_v<UINT>);

    const size_type &cp = n;
    const size_type rest_space = cp - size();
    if (nn > rest_space) {
      nn -= rest_space;
      const size_type cp_rest = max_size() - cp;
      if (cp_rest >= nn)
        reallocate_impl(cp + ((nn < cp && cp_rest >= cp) ? cp : nn));
      else
        throw_or_terminate<length_error>
          ("re::stable_vector_adaptor: size overflow in "
           "reserve_raw_space_at_least(n)\n");
    }
  }
  template <class UINT>
  void reserve_raw_space_at_least(UINT) requires (N != 0u) {
    static_assert(is_integral_v<UINT> && is_unsigned_v<UINT>);
  }

  void increase_capacity_at_least_1() {
    size_type nn;
    if (empty())
      nn = 1;
    else {
      const size_type cp = n;
      const size_type cp_rest = max_size() - cp;
      if (cp_rest >= cp)
        nn = cp + cp;
      else {
        if (cp_rest == 0u)
          throw_or_terminate<length_error>
            ("re::stable_vector_adaptor: size overflow in "
             "increase_capacity_at_least_1()\n");
        nn = max_size();
      }
    }
    reallocate_impl(nn);
  }
  void reserve_raw_space_at_least_1() {
    if (full())
      increase_capacity_at_least_1();
  }
  void reserve_raw_space_at_least_1() requires (N != 0u) {}

  template <class...S>
  reference emplace_back_impl(S &&...s) {
    reserve_raw_space_at_least_1();
    const auto it = end().index_iter();
    node_sync(new_node(forward<S>(s)...), it);
    node_sync(end(), next(it));
    return *iterator(*it);
  }
  void pop_back_impl() noexcept {
    const auto it = prev(end().index_iter());
    delete_node(iterator(*it));
    node_sync(end(), it);
  }
  void pop_back_n_impl(size_type nn) noexcept {
    for (auto &i : r_iters(end().index_iter() - nn, end().index_iter()))
      delete_node(iterator(*i));
    node_sync(end(), end().index_iter() - nn);
  }

  template <class...S>
  iterator emplace_impl(const_iterator cpos, S &&...s) {
    reserve_raw_space_at_least_1();
    const auto node = new_node(forward<S>(s)...);
    const auto i = cpos.index_iter();
    for (auto &it : r_iters(i, end().index_iter() + 1))
      node_sync(iterator(*it), it + 1);
    node_sync(node, i);
    return node;
  }

  iterator erase_impl(const_iterator cpos) noexcept {
    const auto i = cpos.index_iter();
    delete_node(cpos);
    for (auto &it : iters(i + 1, end().index_iter() + 1))
      node_sync(iterator(*it), it - 1);
    return iterator(*i);
  }
  iterator erase_range_impl(const_iterator cfrom,
                            const_iterator cto) noexcept {
    const auto dif = cto - cfrom;
    if (dif != 0) {
      auto it = cfrom.index_iter();
      const auto it2 = cto.index_iter();
      do {
        delete_node(iterator(*it));
        ++it;
      } while (it != it2);
      for (auto &i : iters(cto.index_iter(), end().index_iter() + 1))
        node_sync(iterator(*i), i - dif);
    }
    return cto.to_mutable();
  }

  template <class R>
  enable_if_t<rng_is_sized<R>> append_range_impl(R &&r) {
    reserve_raw_space_at_least(size(r));
    auto it = end().index_iter();
#ifndef RE_NOEXCEPT
    const auto old_sz = size();
    try {
#endif
      for (auto &i : iters(r)) {
        node_sync(new_node(*i), it);
        ++it;
      }
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      node_sync(end(), it);
      erase(prev(end(), size() - old_sz), end());
      throw;
    }
#endif
    node_sync(end(), it);
  }
  template <class R>
  enable_if_t<!rng_is_sized<R>> append_range_impl(R &&r) {
    for (auto &p : iters(r))
      emplace_back_impl(*p);
  }

  template <class R, class TT = value_type>
  enable_if_t<rng_is_sized<R> || is_fitr<rng_itr<R>>, iterator>
  insert_range_impl(const_iterator cpos, R &&r) {
    const auto r_sz = size(r);
    reserve_raw_space_at_least(r_sz);
    const auto j = cpos.index_iter();
    for (auto &i : r_iters(j, end().index_iter() + 1))
      node_sync(iterator(*i), i + r_sz);
#ifndef RE_NOEXCEPT
    try {
      re::securely_initialize
        (r, j,
         [&](auto l_p, auto r_p) {node_sync(new_node(*l_p), *r_p);},
         [&](auto r_p) {delete_node(iterator(*r_p));});
    }
    catch (...) {
      for (auto &i : iters(j, end().index_iter() + 1))
        node_sync(iterator(*(i + r_sz)), i);
      throw;
    }
#else
    re::initialize
      (r, j, [&](auto l_p, auto r_p) {node_sync(new_node(*l_p), *r_p);});
#endif
    return iterator(*j);
  }
  template <class R, class TT = value_type>
  enable_if_t<!(rng_is_sized<R> || is_fitr<rng_itr<R>>), iterator>
  insert_range_impl(const_iterator cpos, R &&r) {
    const auto ed_dif = end() - begin();
    const auto pos_dif = cpos - begin();
    append_range_impl(r);
    const auto x = p + pos_dif;
    rotate(rng(x, end().index_iter()), p + ed_dif);
    for (auto &i : iters(x, end().index_iter()))
      iterator(*i).index_iter(i);
    return *x;
  }

  template <class SZT>
  void size_check(SZT n) const {
    static_assert(is_integral_v<SZT> && is_unsigned_v<SZT>);
    if (n > max_size())
      throw_or_terminate<length_error>("re::stable_vector_adaptor: "
                                       "size overflow in size_check(n)\n");
  }

  template <class R>
  void construct_from_range_impl(R &&r)
    requires (rng_is_sized<R> && N == 0u) {
    const auto r_sz = size(r);
    if (r_sz == 0u) {
      new_data();
      return;
    }
    size_check(r_sz);

    p = ptr_alw().new_n((n = r_sz) + 1u);
#ifndef RE_NOEXCEPT
    try {
#endif
      securely_initialize
        (r, p,
         [=, this](auto l_p, auto r_p) {node_sync(new_node(*l_p), *r_p);},
         [this](auto r_p) {delete_node(iterator(*r_p));});
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      ptr_alw().delete_n(p, n + 1u);
      throw;
    }
#endif
    node_sync(end(), p + n);
  }
  template <class R>
  void construct_from_range_impl(R &&r)
    requires (rng_is_sized<R> && N != 0u) {
    const auto r_sz = size(r);
    securely_initialize
      (r, addr(buf[0]),
       [&](auto l_p, auto r_p) {node_sync(new_node(*l_p), *r_p);},
       [&](auto r_p) {delete_node(iterator(*r_p));});
    node_sync(end(), buf[r_sz]);
  }
  template <class R>
  void construct_from_range_impl(R &&r)
    requires (!rng_is_sized<R>) {
    new_data();
    for (auto &i : iters(r))
      emplace_back_impl(*i);
  }

  void construct_n_impl(size_type nn) {
    new_data();
    if (nn == 0)
      return;
    size_check(nn);
    reallocate_impl(nn);

    auto it = p;
#ifndef RE_NOEXCEPT
    try {
#endif
      for (; nn != 0; --nn) {
        node_sync(new_node(), it);
        ++it;
      }
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      node_sync(end(), it);
      delete_data();
      throw;
    }
#endif
    node_sync(end(), it);
  }
  void construct_n_impl(size_type nn) requires (N != 0u) {
    new_data();

    auto it = addr(buf[0]);
#ifndef RE_NOEXCEPT
    try {
#endif
      for (; nn != 0; --nn) {
        node_sync(new_node(), it);
        ++it;
      }
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      node_sync(end(), it);
      delete_data();
      throw;
    }
#endif
    node_sync(end(), it);
  }

  template <class R>
  void assign_range_impl(R &&r) requires (rng_is_sized<R> && N == 0u) {
    const auto r_sz = size(r);
    size_check(r_sz);

    if (r_sz == 0) {
      delete_data();
      new_data();
      return;
    }
    if (n < r_sz)
      reallocate_impl(r_sz);
    if (size() > r_sz)
      erase(copy(r, begin()), end());
    else {
      auto it = end().index_iter();
      const auto guard = exit_fn([&]() {node_sync(end(), it);});
      for (auto &x : iters(copy_from(*this, begin(r)), end(r))) {
        node_sync(new_node(*x), it);
        ++it;
      }
    }
  }
  template <class R>
  void assign_range_impl(R &&r) requires (rng_is_sized<R> && N != 0u) {
    const auto r_sz = size(r);
    const auto sz = size();
    if (sz > r_sz)
      erase(copy(r, begin()), end());
    else {
      auto it = end().index_iter();
      const auto guard = exit_fn([&]() {node_sync(end(), it);});
      for (auto &x : iters(copy_from(*this, begin(r)), end(r))) {
        node_sync(new_node(*x), it);
        ++it;
      }
    }
  }
  template <class R>
  void assign_range_impl(R &&r) requires (!rng_is_sized<R>) {
    auto r1 = rng(*this);
    auto r2 = rng(r);
    for (;; ++r1.first, (void)++r2.first) {
      if (empty(r1)) {
        append_range_impl(r2);
        return;
      }
      if (empty(r2)) {
        erase_range_impl(r1.first, r1.second);
        return;
      }
      *r1.first = *r2.first;
    }
  }

  void resize_impl(size_type nn) {
    if (size() > nn)
      erase_range_impl(begin() + nn, end());
    else {
      nn -= size();
      reserve_raw_space_at_least(nn);
      auto it = end().index_iter();
      const auto guard = exit_fn([&]() {node_sync(end(), it);});
      for (; nn != 0; --nn) {
        node_sync(new_node(), it);
        ++it;
      }
    }
  }
  void resize_impl(size_type nn, const value_type &x) {
    if (size() > nn)
      erase_range_impl(begin() + nn, end());
    else
      append_range_impl(rng(nn - size(), x));
  }
  void reserve_impl(size_type nn) {
    if (nn > capacity()) {
      if (nn > max_size())
        throw_or_terminate<length_error>
          ("re::stable_vector_adaptor: size overflow in "
           "reserve_impl(n)\n");
      reallocate_impl(nn);
    }
  }
  void shrink_to_fit_impl() {
    if (empty()) {
      delete_data();
      new_data();
    }
    else if (size() != capacity())
      reallocate_impl(size());
  }

public:
  // node operations

  using traits = TRAITS;
  using node_pointer = node_base_ptr;
  template <class...S>
  iterator new_node(S &&...s) {
    return iterator(traits::new_node(alloc_ref(), forward<S>(s)...));
  }
  void delete_node(const_iterator i) noexcept {
    traits::delete_node(alloc_ref(), i.node());
  }
  iterator exchange_node(const_iterator old, const_iterator i) {
    node_sync(i, old.index_iter());
    return old.to_mutable();
  }

  iterator link(const_iterator cpos, const_iterator x) {
    reserve_raw_space_at_least_1();
    const auto i = cpos.index_iter();
    for (auto &it : r_iters(i, end().index_iter() + 1))
      node_sync(iterator(*it), it + 1);
    node_sync(x, i);
    return x.to_mutable();
  }
  iterator link_back(const_iterator x) {
    reserve_raw_space_at_least_1();
    const auto it = end().index_iter();
    node_sync(x, it);
    node_sync(end(), next(it));
    return iterator(*it);
  }
  iterator unlink(const_iterator cpos) {
    const auto i = cpos.index_iter();
    for (auto &it : iters(i + 1, end().index_iter() + 1))
      node_sync(iterator(*it), it - 1);
    return iterator(*i);
  }
  iterator unlink(const_iterator cfrom, const_iterator cto) {
    const auto dif = cto - cfrom;
    if (dif != 0)
      for (auto &it : iters(cto.index_iter(), end().index_iter() + 1))
        node_sync(iterator(*it), it - dif);
    return cto.to_mutable();
  }
  void unlink() noexcept {
    if (n != 0)
      node_sync(end(), p);
  }
  void unlink() noexcept requires (N != 0u) {
    new_data();
  }
  iterator unlink_back() {
    const auto it = prev(end().index_iter());
    node_sync(end(), it);
    return end();
  }

  // container (continued)

  stable_vector_adaptor() noexcept(noexcept(alloc_t{}))
    : stable_vector_adaptor(alloc_t{}) {}
  ~stable_vector_adaptor() {
    delete_data();
  }
  stable_vector_adaptor(const stable_vector_adaptor &) = delete;
  stable_vector_adaptor &operator =(const stable_vector_adaptor &) = delete;
  stable_vector_adaptor(const stable_vector_adaptor &v)
    requires TRAITS::store_node_allocator::value
    : alw_t(alw_t::traits
            ::select_on_container_copy_construction(v.alloc_ref())) {
    new_data(v);
  }
  stable_vector_adaptor &operator =(const stable_vector_adaptor &v)
    requires TRAITS::store_node_allocator::value {
    allocator_aware_container_ownership<this_t>::copy_assign(*this, v);
    return *this;
  }
  stable_vector_adaptor(stable_vector_adaptor &&v) noexcept
    : alw_t(move(v.alloc_ref())) {
    new_data(move(v));
  }
  stable_vector_adaptor &operator =(stable_vector_adaptor &&v)
    noexcept(alloc_move_prpg<alloc_t> || alloc_always_equal<alloc_t>) {
    allocator_aware_container_ownership<this_t>::move_assign(*this, v);
    return *this;
  }
  friend void swap(stable_vector_adaptor &x,
                   stable_vector_adaptor &y)
    noexcept(alloc_swap_prpg<alloc_t> || alloc_always_equal<alloc_t>) {
    allocator_aware_container_ownership<this_t>::swap(x, y);
  }

  // optional container operations

  // reversible container

  using reverse_iterator = re::reverse_iterator<iterator>;
  using const_reverse_iterator = re::reverse_iterator<const_iterator>;

  reverse_iterator rbegin() noexcept {
    return reverse_iterator(end());
  }
  reverse_iterator rend() noexcept {
    return reverse_iterator(begin());
  }
  const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator(begin());
  }
  const_reverse_iterator crbegin() const noexcept {
    return rbegin();
  }
  const_reverse_iterator crend() const noexcept {
    return rend();
  }

  // allocator-aware container

  using allocator_type = alloc_t;
  allocator_type get_allocator() const noexcept {
    return alw_t::get();
  }

  explicit stable_vector_adaptor(const alloc_t &al) noexcept : alw_t(al) {
    new_data();
  }
  stable_vector_adaptor(const stable_vector_adaptor &v, const alloc_t &al)
    : alw_t(al) {
    new_data(v);
  }
  stable_vector_adaptor(stable_vector_adaptor &&v, const alloc_t &al)
    : alw_t(al) {
    allocator_aware_container_ownership<this_t>::move_construct(*this, v);
  }

  // sequence container

  explicit stable_vector_adaptor(size_type nn, const alloc_t &al = alloc_t{})
    : alw_t(al) {
    construct_n_impl(nn);
  }
  stable_vector_adaptor(size_type nn, const value_type &x,
                        const alloc_t &al = alloc_t{}) : alw_t(al) {
    construct_from_range_impl(rng(nn, ref(x)));
  }
  void assign(size_type nn, const value_type &x) {
    assign_range_impl(rng(nn, x));
  }

  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  stable_vector_adaptor(IITR from, IITR to, const alloc_t &al = alloc_t{})
    : alw_t(al) {
    construct_from_range_impl(rng(from, to));;
  }
  template <class IITR>
  enable_if_t<is_itr<IITR>> assign(IITR from, IITR to) {
    assign_range_impl(rng(from, to));
  }

  stable_vector_adaptor(initializer_list<value_type> l,
                        const alloc_t &al = alloc_t{}) : alw_t(al) {
    construct_from_range_impl(l);
  }
  stable_vector_adaptor &operator =(initializer_list<value_type> l) {
    assign_range_impl(l);
    return *this;
  }
  void assign(initializer_list<value_type> l) {
    assign_range_impl(l);
  }

  template <class...S>
  iterator emplace(const_iterator pos, S &&...s) {
    return emplace_impl(pos, forward<S>(s)...);
  }
  iterator insert(const_iterator pos, const value_type &x) {
    return emplace(pos, x);
  }
  iterator insert(const_iterator pos, value_type &&x) {
    return emplace(pos, move(x));
  }

  iterator insert(const_iterator pos, size_type nn, const value_type &x) {
    return insert_range_impl(pos, rng(nn, x));
  }
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  iterator insert(const_iterator pos, IITR from, IITR to) {
    return insert_range_impl(pos, rng(from, to));
  }
  iterator insert(const_iterator pos, initializer_list<value_type> l) {
    return insert_range_impl(pos, l);
  }

  iterator erase(const_iterator pos) {
    return erase_impl(pos);
  }
  iterator erase(const_iterator from, const_iterator to) {
    return erase_range_impl(from, to);
  }

  void clear() noexcept {
    erase_range_impl(begin(), end());
  }

  // optional sequence container operations

  reference front() {
    return *begin();
  }
  reference back() {
    return *(end() - 1);
  }
  const_reference front() const {
    return *begin();
  }
  const_reference back() const {
    return *(end() - 1);
  }

  template <class...S>
  reference emplace_back(S &&...s) {
    return emplace_back_impl(forward<S>(s)...);
  }
  void push_back(const value_type &x) {
    emplace_back(x);
  }
  void push_back(value_type &&x) {
    emplace_back(move(x));
  }
  void pop_back() noexcept {
    pop_back_impl();
  }

  reference operator [](size_type nn) {
    return begin()[nn];
  }
  const_reference operator [](size_type nn) const {
    return begin()[nn];
  }
  reference at(size_type nn) {
    if (nn >= size())
      throw_or_terminate<out_of_range>
        ("re::stable_vector_adaptor: at(n) failed\n");
    return begin()[nn];
  }
  const_reference at(size_type nn) const {
    if (nn >= size())
      throw_or_terminate<out_of_range>
        ("re::stable_vector_adaptor: at(n) failed\n");
    return begin()[nn];
  }

  // specialized operations

  size_type capacity() const noexcept {
    return n;
  }
  size_type capacity() const noexcept requires (N != 0u) {
    return N;
  }
  void resize(size_type nn) {
    resize_impl(nn);
  }
  void resize(size_type nn, const value_type &x) {
    resize_impl(nn, x);
  }
  void reserve(size_type nn) requires (N == 0u) {
    reserve_impl(nn);
  }
  void shrink_to_fit() requires (N == 0u) {
    shrink_to_fit_impl();
  }

  // list operations

  void splice(const_iterator next, this_t &l) {
    const auto l_sz = l.size();
    reserve_raw_space_at_least(l_sz);
    const auto j = next.index_iter();
    for (auto &i : r_iters(j, end().index_iter() + 1))
      node_sync(iterator(*i), i + l_sz);
    for_each(rng(l.index_array_begin(), l_sz), j,
             [&](auto &x, auto &y) {node_sync(iterator(x), y);});
    l.unlink();
  }
  void splice(const_iterator next, this_t &&l) {
    splice(next, l);
  }
  void splice(const_iterator next, this_t &l, const_iterator i) {
    if (this == addressof(l)) {
      if (next != i) {
        unlink(i);
        link(next, i);
      }
    }
    else {
      reserve_raw_space_at_least(l.size());
      l.unlink(i);
      link(next, i);
    }
  }
  void splice(const_iterator next, this_t &&l, const_iterator i) {
    splice(next, l, i);
  }
  void splice(const_iterator next, this_t &l,
              const_iterator from, const_iterator to) {
    const size_type sz = to - from;
    reserve_raw_space_at_least(sz);
    const auto to_iter = to.index_iter();

    if (addressof(l) != this) {
      if (sz != 0) {
        const auto j = next.index_iter();
        for (auto &i : r_iters(j, end().index_iter() + 1))
          node_sync(iterator(*i), i + sz);
        for_each(rng(from.index_iter(), sz), j,
                 [&](auto &x, auto &y) {node_sync(iterator(x), y);});
        for (auto &it : iters(to_iter, l.end().index_iter() + 1))
          node_sync(iterator(*it), it - sz);
      }
    }
    else {
      iter_pair<node_base_ptr_ptr> r;
      node_base_ptr_ptr i;
      if (next < from) {
        r = {next.index_iter(), to_iter};
        i = from.index_iter();
      }
      else {
        r = {from.index_iter(), next.index_iter()};
        i = to_iter;
      }
      rotate(r, i, [](auto &x, auto &y) {
        iterator(x).index_iter(addr(y));
        iterator(y).index_iter(addr(x));
        adl_swap(x, y);
      });
    }
  }
  void splice(const_iterator next, this_t &&l,
              const_iterator from, const_iterator to) {
    splice(next, l, from, to);
  }

  void swap(const_iterator x, const_iterator y) noexcept {
    const auto x_iter = x.index_iter();
    const auto y_iter = y.index_iter();
    x.index_iter(y_iter);
    y.index_iter(x_iter);
    adl_swap(*x_iter, *y_iter);
  }
  void swap(const_iterator x, this_t &l, const_iterator y) noexcept {
    swap(x, y);
  }

  template <bool Y = traits::store_node_allocator::value>
  enable_if_t<Y, iterator> erase_or_unlink(const_iterator it) noexcept {
    return erase(it);
  }
  template <bool Y = traits::store_node_allocator::value>
  enable_if_t<!Y, iterator> erase_or_unlink(const_iterator it) noexcept {
    return unlink(it);
  }

private:
  void delete_node_if_stored_alloc(const_iterator it) {
    if constexpr (traits::store_node_allocator::value) {
      delete_node(it);
    }
  }
public:
  template <class UPRED>
  size_type remove_if(UPRED eq) {
    size_type ret = 0;
    const auto r = rng(index_array_begin(), size());
    auto it = find_if(r, [&](auto pp) {return eq(*iterator(pp));});
    if (it != end(r)) {
      ++ret;
      delete_node_if_stored_alloc(iterator(*it));
      for (auto &it2 : iters(next(it), end(r))) {
#ifndef RE_NOEXCEPT
        try {
#endif
          if (!eq(*iterator(*it2))) {
            node_sync(iterator(*it2), it);
            ++it;
          }
          else {
            ++ret;
            delete_node_if_stored_alloc(iterator(*it2));
          }
#ifndef RE_NOEXCEPT
        }
        catch (...) {
          for_each(rng(it2, end(r)), [&](auto p) {
            delete_node_if_stored_alloc(iterator(p));
          });
          node_sync(end(), it);
          throw;
        }
#endif
      }
      node_sync(end(), it);
    }
    return ret;
  }
  template <class X>
  size_type remove(const X &x) {
    return remove_if([&x](const value_type &y) {return x == y;});
  }

  template <class BPRED>
  void unique(BPRED eq) {
    const auto r = rng(index_array_begin(), end().index_iter());
    const auto ptr_eq = [&](auto x, auto y)->bool {
      return eq(*iterator(x), *iterator(y));
    };
    auto it = adjacent_find(r, ptr_eq);
    if (it != end(r)) {
      delete_node_if_stored_alloc(iterator(*next(it)));
      for (auto &it2 : iters(next(it, 2), end(r))) {
#ifndef RE_NOEXCEPT
        try {
#endif
          if (!ptr_eq(*it, *it2)) {
            ++it;
            node_sync(iterator(*it2), it);
          }
          else
            delete_node_if_stored_alloc(iterator(*it2));
#ifndef RE_NOEXCEPT
        }
        catch (...) {
          for_each(rng(it2, end(r)), [&](auto p) {
            delete_node_if_stored_alloc(iterator(p));
          });
          node_sync(end(), next(it));
          throw;
        }
#endif
      }
      node_sync(end(), next(it));
    }
  }
  void unique() {
    unique(equal_to<value_type>());
  }

  template <size_t NN, class BPRED>
  void merge(stable_vector_adaptor<TRAITS, NN> &l, BPRED less) {
    if (static_cast<void *>(addressof(l))
        == static_cast<void *>(this))
      return;
    reserve(size() + l.size());

    this_t tmp(get_allocator());
    const auto tmp_n = max_value(size(), 1u);
    tmp.p = tmp.ptr_alw().new_n(tmp_n + 1u);
    tmp.n = tmp_n;
    const auto pp = copy(rng(p, end().index_iter()), tmp.p);
    for (auto &x : iters(tmp.p, pp))
      iterator(*x).index_iter(x);
    tmp.node_sync(tmp.end(), pp);
    node_sync(end(), p);

    auto guard = exit_fn([&]() {*p = end().node();}, true);
    auto it = p;
    re::merge(rng(tmp.p, tmp.end().index_iter()),
              rng(l.index_array_begin(), l.end().index_iter()),
              output_itr([&](auto x) {
                *it = x;
                ++it;
              }),
              [less](node_base_ptr p1, node_base_ptr p2) {
                return less(*iterator(p1), *iterator(p2));
              });
    guard.unset();

    for (auto &x : iters(p, it))
      node_sync(iterator(*x), x);
    node_sync(end(), it);
    tmp.unlink();
    l.unlink();
  }
  template <size_t NN, class BPRED>
  void merge(stable_vector_adaptor<TRAITS, NN> &l, BPRED less)
    requires (N != 0u) {
    if (static_cast<void *>(addressof(l))
        == static_cast<void *>(this))
      return;

    this_t tmp(get_allocator());
    const auto pp = copy(rng(index_array_begin(), end().index_iter()),
                         tmp.index_array_begin());
    for (auto &x : iters(tmp.index_array_begin(), pp))
      iterator(*x).index_iter(x);
    tmp.node_sync(tmp.end(), pp);
    node_sync(end(), index_array_begin());

    auto guard = exit_fn([&]() {*index_array_begin() = end().node();}, true);
    auto it = index_array_begin();
    re::merge(rng(tmp.index_array_begin(), tmp.end().index_iter()),
              rng(l.index_array_begin(), l.end().index_iter()),
              output_itr([&](auto x) {
                *it = x;
                ++it;
              }),
              [less](auto p1, auto p2) {
                return less(*iterator(p1), *iterator(p2));
              });
    guard.unset();

    for (auto &x : iters(index_array_begin(), it))
      node_sync(iterator(*x), x);
    node_sync(end(), it);
    tmp.unlink();
    l.unlink();
  }
  template <size_t NN, class BPRED>
  void merge(stable_vector_adaptor<TRAITS, NN> &&l, BPRED less) {
    merge(l, less);
  }
  template <size_t NN>
  void merge(stable_vector_adaptor<TRAITS, NN> &l) {
    merge(l, re::less<value_type>{});
  }
  template <size_t NN>
  void merge(stable_vector_adaptor<TRAITS, NN> &&l) {
    merge(l, re::less<value_type>{});
  }

  void reverse() noexcept {
    for (auto it = index_array_begin(), it2 = end().index_iter();
         it < it2;) {
      --it2;
      swap(iterator(*it), iterator(*it2));
      ++it;
    }
  }

  template <class BPRED>
  void sort(BPRED less) {
    const auto guard = exit_fn([&]() {
      for (auto &i : iters(index_array_begin(), end().index_iter()))
        iterator(*i).index_iter(i);
    });
    re::sort(rng(index_array_begin(), end().index_iter()),
             [&](auto x, auto y) {return less(*iterator(x), *iterator(y));});
  }
  void sort() {
    sort(less<>());
  }

  // extensions

  bool full() const noexcept {
    return capacity() == size();
  }

  void reallocate(size_type nn) requires (N == 0u) {
    if (nn == 0) {
      delete_data();
      new_data();
    }
    else if (nn >= size())
      reallocate_impl(nn);
  }
  void reallocate() requires (N == 0u) {
    reallocate(size());
  }

  void reserve_more(size_type nn) {
    reserve_raw_space_at_least(nn);
  }

  template <class R>
  iterator replace(const_iterator i1, const_iterator i2, R &&r)
    requires (!is_convertible_v<R &&, this_t &&>) {
    return inner::fns::seq_container_replace_impl
      (*this, i1.to_mutable(), i2.to_mutable(), r);
  }

  using node_type = inner::stable_vector_node_handle<TRAITS>;
  template <class...S>
  node_type make_node(S &&...s) {
    return node_type(new_node(forward<S>(s)...).node(), get_allocator());
  }

  node_type extract(const_iterator ci) noexcept {
    unlink(ci);
    return node_type(ci.node(), get_allocator());
  }
  iterator insert(const_iterator ci, node_type &&x) {
    return (!x.empty()) ? link(ci, iterator(x.release())) : ci.to_mutable();
  }
  void push_back(node_type &&x) {
    if (!x.empty())
      link_back(const_iterator(x.release()));
  }
  node_type exchange(const_iterator ci, node_type &x) noexcept {
    (!x.empty()) ? exchange_node(ci, iterator(x.release())) : unlink(ci);
    return node_type(ci.node(), get_allocator());
  }
  node_type exchange(const_iterator ci, node_type &&x) noexcept {
    return exchange(ci, x);
  }
  iterator replace(const_iterator ci, node_type &&x) noexcept {
    if (!x.empty()) {
      const iterator it(x.release());
      delete_node(exchange_node(ci, it));
      return it;
    }
    else
      return erase(ci);
  }

  this_t extract(const_iterator ci, const_iterator ci2) {
    this_t l(get_allocator());
    l.splice(l.end(), *this, ci, ci2);
    return l;
  }
  iterator insert(const_iterator ci, this_t &&l) {
    const auto ret = (!l.empty()) ? l.begin() : ci.to_mutable();
    splice(ci, l);
    return ret;
  }
  void push_back(this_t &&l) {
    splice(end(), l);
  }
  this_t exchange(const_iterator ci, const_iterator ci2, this_t &x) {
    this_t ret = extract(ci, ci2);
    insert(ci2, move(x));
    return ret;
  }
  this_t exchange(const_iterator ci, const_iterator ci2, this_t &&x) {
    return exchange(ci, ci2, x);
  }
  iterator replace(const_iterator ci, const_iterator ci2, this_t &&x) {
    erase(ci, ci2);
    return insert(ci2, move(x));
  }

private:
  friend struct inner::fo_good;
  bool good() const noexcept {
    return all_of(irng(index_array_begin(), end().index_iter()),
                  [&](auto i) {return iterator(*i).index_iter() == i;});
  }

public:
  template <class R, class = enable_if_t
            <is_rng<R> && is_constructible_v<value_type, rng_ref<R>>>>
  stable_vector_adaptor(from_range_t, R &&r,
                        const allocator_type &al = allocator_type{})
    : alw_t(al) {
    construct_from_range_impl(r);
  }
  template <class R, class = enable_if_t
            <!is_same_v<decay_t<R>, this_t>
             && !is_convertible_v<R &&, const allocator_type &>
             && is_rng<R> && is_constructible_v<value_type, rng_ref<R>>>>
  explicit stable_vector_adaptor(R &&r) {
    construct_from_range_impl(r);
  }
  template <class R, class = enable_if_t
            <!is_same_v<decay_t<R>, this_t>
             && is_rng<R> && is_constructible_v<value_type, rng_ref<R>>>>
  stable_vector_adaptor(R &&r, const allocator_type &al) : alw_t(al) {
    construct_from_range_impl(r);
  }
  template <class IITR_RANGE>
  enable_if_t<!is_same_v<decay_t<IITR_RANGE>, this_t>
              && is_rng<IITR_RANGE>
              && is_constructible_v<value_type, rng_ref<IITR_RANGE>>
              && is_assignable_v<value_type &, rng_ref<IITR_RANGE>>, this_t &>
  operator =(IITR_RANGE &&r) {
    assign_range_impl(r);
    return *this;
  }
  template <class IITR_RANGE>
  void assign(IITR_RANGE &&r) {
    assign_range_impl(r);
  }
  template <class IITR_RANGE>
  void assign_range(IITR_RANGE &&r) {
    assign_range_impl(r);
  }

  template <class IITR_RANGE>
  enable_if_t<!is_convertible_v<IITR_RANGE &&, value_type &&>
              && !is_convertible_v<IITR_RANGE &&, const value_type &>
              && !is_convertible_v<IITR_RANGE &&, node_type &&>
              && !is_convertible_v<IITR_RANGE &&, this_t &&>,
              iterator>
  insert(const_iterator pos, IITR_RANGE &&r) {
    return insert_range_impl(pos, r);
  }
  template <class IITR_RANGE>
  iterator insert_range(const_iterator pos, IITR_RANGE &&r) {
    return insert_range_impl(pos, r);
  }

  template <class IITR_RANGE>
  enable_if_t<!is_convertible_v<IITR_RANGE &&, value_type &&>
              && !is_convertible_v<IITR_RANGE &&, const value_type &>
              && !is_convertible_v<IITR_RANGE &&, node_type &&>
              && !is_convertible_v<IITR_RANGE &&, this_t &&>>
  push_back(IITR_RANGE &&r) {
    append_range_impl(r);
  }
  template <class IITR_RANGE>
  void append_range(IITR_RANGE &&r) {
    append_range_impl(r);
  }
  void pop_back(size_type nn) {
    pop_back_n_impl(nn);
  }

  this_t &append() {
    return *this;
  }
  template <class X, class...S>
  this_t &append(X &&x, S &&...s) {
    push_back(forward<X>(x));
    return append(forward<S>(s)...);
  }
};
template <class TRAITS, size_t N>
bool operator ==(const stable_vector_adaptor<TRAITS, N> &x,
                 const stable_vector_adaptor<TRAITS, N> &y) {
  return equal(x, y);
}
template <class TRAITS, size_t N>
synth_3way_result<typename TRAITS::value_type>
operator <=>(const stable_vector_adaptor<TRAITS, N> &x,
             const stable_vector_adaptor<TRAITS, N> &y) {
  return lexicographical_synth_3way(x, y);
}

template <class T, class AL>
struct stbvt : stable_vector_traits<stable_vector_node<T, AL>, 0, 1, AL> {};
template <class T, class AL = default_allocator<T>>
using stable_vector = stable_vector_adaptor<stbvt<T, AL>>;
template <class T, size_t N, class AL = default_allocator<T>>
using limited_stable_vector = stable_vector_adaptor<stbvt<T, AL>, N>;

}

// tree
namespace re {

template <class>
class tree_adaptor;
template <class>
class tree_vector_adaptor;
namespace inner {

template <class, class, size_t = 0u>
struct gtt;
template <class, class>
struct ltt;
template <class, class>
struct lgtt;

template <class>
struct tree_base;
template <class>
class tree_node;
template <class>
class tree_node_impl;

template <class T>
struct get_tree_traits_from_iter {};
template <template <class, class> class TMP, class T, class TRAITS>
struct get_tree_traits_from_iter<TMP<T, TRAITS>> {
  using type = TRAITS;
};
template <template <class, class, bool> class TMP,
          class T, class TRAITS, bool Y>
struct get_tree_traits_from_iter<TMP<T, TRAITS, Y>> {
  using type = TRAITS;
};
template <class T>
using get_tree_traits_from_iter_t = typename get_tree_traits_from_iter<T>::type;

template <class IT>
class tree_first_order_iterator {
  template <class>
  friend class tree_first_order_iterator;

  using this_t = tree_first_order_iterator;

  IT root_it{};
  IT it{};

public:
  using value_type = itr_vt<IT>;
  using reference = itr_ref<IT>;
  using pointer = itr_ptr<IT>;
  using difference_type = itr_dft<IT>;
  using iterator_category = bidirectional_iterator_tag;

  tree_first_order_iterator() = default;
  ~tree_first_order_iterator() = default;
  tree_first_order_iterator(const this_t &) = default;
  this_t &operator =(const this_t &) = default;
  tree_first_order_iterator(this_t &&) = default;
  this_t &operator =(this_t &&) = default;
  friend void swap(this_t &x, this_t &y) noexcept {
    adl_swap(x.root_it, y.root_it);
    adl_swap(x.it, y.it);
  }

  explicit tree_first_order_iterator(IT i1, IT i2) : root_it(i1), it(i2) {}
  IT root() const {
    return root_it;
  }
  IT base() const {
    return it;
  }

  template <class IT2>
  tree_first_order_iterator(const tree_first_order_iterator<IT2> x)
    requires is_convertible_v<IT, const IT2 &> : root_it(x.root_it), it(x.it) {}

  bool operator ==(nullptr_t) const {
    return it == nullptr;
  }

  reference operator *() const {
    return static_cast<reference>(*it);
  }
  pointer operator ->() const {
    return static_cast<pointer>(it.operator ->());
  }
  template <class IT2>
  bool operator ==(const tree_first_order_iterator<IT2> &x) const
    requires can_apply_equal_to<const IT &, const IT2 &> {
    return it == x.it;
  }

  this_t &operator ++() {
    if (it == nullptr) {
      it = root_it;
      return *this;
    }
    else {
      if (it->empty()) {
        for (IT parent;;) {
          if (it == root_it) {
            it = IT{};
            return *this;
          }
          parent = it.parent();
          ++it;
          if (it == parent->end())
            it = parent;
          else
            return *this;
        }
      }
      else {
        it = it->begin();
        return *this;
      }
    }
  }
  this_t operator ++(int) {
    return iter_post_increment(*this);
  }

  this_t &operator --() {
    if (it == nullptr) {
      it = root_it;
      while (!it->empty())
        it = before_end(*it);
    }
    else {
      const auto parent = it.parent();
      if (parent == nullptr || it == root_it) {
        it = IT{};
        return *this;
      }
      if (it == parent->begin())
        it = parent;
      else {
        --it;
        while (!it->empty())
          it = before_end(*it);
      }
    }
    return *this;
  }
  this_t operator --(int) {
    return iter_post_decrement(*this);
  }

  this_t removed_next() const {
    this_t ret = *this;
    IT parent;
    for (;;) {
      if (ret.it == root_it) {
        ret.it = IT{};
        break;
      }
      parent = ret.it.parent();
      ++ret.it;
      if (ret.it != parent->end())
        break;
      ret.it = parent;
    }
    return ret;
  }
  difference_type advance() {
    if (it == nullptr) {
      it = root_it;
      return 1;
    }
    else {
      difference_type ret = 0;
      if (it->empty())
        for (IT parent;;) {
          if (it == root_it) {
            it = IT{};
            --ret;
            return ret;
          }
          parent = it.parent();
          ++it;
          if (it == parent->end()) {
            it = parent;
            --ret;
          }
          else
            return ret;
        }
      else {
        it = it->begin();
        ++ret;
        return ret;
      }
    }
  }
};
template <class IT>
class tree_last_order_iterator {
  template <class>
  friend class tree_last_order_iterator;

  using this_t = tree_last_order_iterator;

  IT root_it{};
  IT it{};

public:
  using value_type = itr_vt<IT>;
  using reference = itr_ref<IT>;
  using pointer = itr_ptr<IT>;
  using difference_type = itr_dft<IT>;
  using iterator_category = bidirectional_iterator_tag;

  tree_last_order_iterator() = default;
  ~tree_last_order_iterator() = default;
  tree_last_order_iterator(const this_t &) = default;
  this_t &operator =(const this_t &) = default;
  tree_last_order_iterator(this_t &&) = default;
  this_t &operator =(this_t &&) = default;
  friend void swap(this_t &x, this_t &y) noexcept {
    adl_swap(x.root_it, y.root_it);
    adl_swap(x.it, y.it);
  }

  explicit tree_last_order_iterator(IT i1, IT i2) : root_it(i1), it(i2) {}
  IT root() const {
    return root_it;
  }
  IT base() const {
    return it;
  }

  template <class IT2>
  tree_last_order_iterator(const tree_last_order_iterator<IT2> x)
    requires is_convertible_v<IT, const IT2 &> : root_it(x.root_it), it(x.it) {}

  bool operator ==(nullptr_t) const {
    return it == nullptr;
  }

  reference operator *() const {
    return static_cast<reference>(*it);
  }
  pointer operator ->() const {
    return static_cast<pointer>(it.operator ->());
  }
  template <class IT2>
  bool operator ==(const tree_last_order_iterator<IT2> &x) const
    requires can_apply_equal_to<const IT &, const IT2 &> {
    return it == x.it;
  }

  this_t &operator ++() {
    if (it == nullptr) {
      it = root_it;
      if (it != nullptr)
        while (!it->empty())
          it = it->begin();
      return *this;
    }
    const auto parent = it.parent();
    if (parent == nullptr || it == root_it)
      it = IT{};
    else {
      ++it;
      if (it == parent->end())
        it = parent;
      else
        while (!it->empty())
          it = it->begin();
    }
    return *this;
  }
  this_t operator ++(int) {
    return iter_post_increment(*this);
  }

  this_t &operator --() {
    if (it == nullptr)
      it = root_it;
    else {
      if (it->empty())
        for (IT parent;;) {
          if (it == root_it) {
            it = IT{};
            return *this;
          }
          parent = it.parent();
          if (it == parent->begin())
            it = parent;
          else {
            --it;
            return *this;
          }
        }
      else {
        it = before_end(*it);
        return *this;
      }
    }
    return *this;
  }
  this_t operator --(int) {
    return iter_post_decrement(*this);
  }
};
template <class IT>
class tree_nth_order_iterator {
  template <class>
  friend class tree_nth_order_iterator;

  using this_t = tree_nth_order_iterator;

  IT root_it{};
  IT it{};
  itr_dft<IT> d{};

public:
  using value_type = itr_vt<IT>;
  using reference = itr_ref<IT>;
  using pointer = itr_ptr<IT>;
  using difference_type = itr_dft<IT>;
  using iterator_category = bidirectional_iterator_tag;

  tree_nth_order_iterator() = default;
  ~tree_nth_order_iterator() = default;
  tree_nth_order_iterator(const this_t &) = default;
  this_t &operator =(const this_t &) = default;
  tree_nth_order_iterator(this_t &&) = default;
  this_t &operator =(this_t &&) = default;
  friend void swap(this_t &x, this_t &y) noexcept {
    adl_swap(x.root_it, y.root_it);
    adl_swap(x.it, y.it);
  }

  explicit tree_nth_order_iterator(IT it, IT it2, itr_dft<IT> dd)
    : root_it(it), it(it2), d(dd) {}
  IT root() const {
    return root_it;
  }
  IT base() const {
    return it;
  }
  itr_dft<IT> nth() const {
    return d;
  }

  template <class IT2>
  tree_nth_order_iterator(const tree_nth_order_iterator<IT2> x)
    requires is_convertible_v<IT, const IT2 &>
    : root_it(x.root_it), it(x.it), d(x.dd) {}

  bool operator ==(nullptr_t) const {
    return it == nullptr;
  }

  reference operator *() const {
    return static_cast<reference>(*it);
  }
  pointer operator ->() const {
    return static_cast<pointer>(it.operator ->());
  }
  bool operator ==(const this_t &x) const {
    return it == x.it;
  }

private:
  IT first_node_from_valid_tree(IT x) const {
    if (d == 0)
      return x;
    else {
      while (!x->empty())
        x = x->begin();
      return x;
    }
  }
  IT last_node_from_valid_tree(IT x) const {
    IT u = x;
    for (;;) {
      const auto k = ssize(*u);
      if (k <= d)
        return u;
      u = before_end(*u);
    }
    return u;
  }
  IT next_node_after_valid_tree(IT x) const {
    IT parent;
    IT u = x;
    for (;;) {
      parent = u.parent();
      if (parent == nullptr || u == root_it)
        u = IT{};
      else {
        const auto k = distance(begin(*parent), u);
        if (k == d - 1)
          u = parent;
        else if (k > d - 1) {
          ++u;
          if (u == end(*parent)) {
            u = parent;
            continue;
          }
          else
            u = first_node_from_valid_tree(u);
        }
        else {
          ++u;
          u = ((u == end(*parent))
               ? parent: first_node_from_valid_tree(u));
        }
      }
      break;
    }
    return u;
  }
  IT prev_node_before_valid_tree(IT x) const {
    IT parent;
    IT u = x;
    for (;;) {
      parent = u.parent();
      if (parent == nullptr || u == root_it)
        u = IT{};
      else {
        const auto k = distance(begin(*parent), u);
        if (k == d)
          u = parent;
        else if (k > d)
          u = last_node_from_valid_tree(prev(u));
        else {
          if (u == parent->begin()) {
            u = parent;
            continue;
          }
          else
            u = last_node_from_valid_tree(prev(u));
        }
      }
      break;
    }
    return u;
  }

public:
  this_t &operator ++() {
    if (it == nullptr) {
      it = ((root_it != nullptr)
            ? first_node_from_valid_tree(root_it)
            : IT{});
      return *this;
    }
    const auto n = ssize(*it);
    if (d >= n)
      it = next_node_after_valid_tree(it);
    else
      it = first_node_from_valid_tree(re::nth(*it, d));
    return *this;
  }
  this_t operator ++(int) {
    return iter_post_increment(*this);
  }

  this_t &operator --() {
    if (it == nullptr) {
      it = ((root_it != nullptr)
            ? last_node_from_valid_tree(root_it)
            : IT{});
      return *this;
    }
    if (d == 0)
      it = prev_node_before_valid_tree(it);
    else {
      const auto n = ssize(*it);
      if (n == 0)
        it = prev_node_before_valid_tree(it);
      else
        it = last_node_from_valid_tree(prev(next(it->begin(), d, it->end())));
    }
    return *this;
  }
  this_t operator --(int) {
    return iter_post_decrement(*this);
  }
};

template <class I>
class tree_iterator {
  template <class>
  friend class tree_iterator;
  template <class>
  friend class tree_node;
  template <class>
  friend class tree_node_impl;
  template <class>
  friend class re::tree_adaptor;
  template <class>
  friend class re::tree_vector_adaptor;

  using this_t = tree_iterator;
  using traits_t = get_tree_traits_from_iter_t<I>;

  I i{};

public:
  using value_type = typename itr_vt<I>::public_node_type;
  using reference = copy_cvref_t<itr_ref<I>, value_type>;
  using pointer = pointer_rebind_t<itr_ptr<I>,
                                   copy_cv_t<remove_reference_t<reference>,
                                             value_type>>;
  using difference_type = typename I::difference_type;
  using iterator_category = typename I::iterator_category;

  tree_iterator() = default;
  ~tree_iterator() = default;
  tree_iterator(const tree_iterator &) = default;
  tree_iterator &operator =(const tree_iterator &) = default;
  tree_iterator(tree_iterator &&) = default;
  tree_iterator &operator =(tree_iterator &&) = default;
  friend void swap(tree_iterator &x, tree_iterator &y) noexcept {
    adl_swap(x.i, y.i);
  }

  bool operator ==(nullptr_t) const {
    return i == nullptr;
  }

  template <class I2>
  tree_iterator(tree_iterator<I2> x) requires is_convertible_v<const I2 &, I>
    : i(x.i) {}
  template <class I2>
  tree_iterator &operator =(tree_iterator<I2> x)
    requires (is_convertible_v<const I2 &, I>
              && is_assignable_v<I &, const I2 &>) {
    i = x.i;
    return *this;
  }

private:
  explicit tree_iterator(I x) : i(x) {}
  I base() const {
    return i;
  }
  auto node() const {
    return i.node();
  }
  auto to_mutable() const {
    return tree_iterator<decltype(i.to_mutable())>(i.to_mutable());
  }

  template <class I2>
  void parent(tree_iterator<I2> x) const {
    traits_t::tree_parent(i.node(), x.base().node());
  }
public:
  this_t parent() const {
    return this_t(I(traits_t::tree_parent(i.node())));
  }

  reference operator *() const {
    return static_cast<reference>(*i);
  }
  pointer operator ->() const {
    return static_cast<pointer>(i.operator ->());
  }
  this_t &operator ++() {
    ++i;
    return *this;
  }
  this_t operator ++(int) {
    return iter_post_increment(*this);
  }

  this_t &operator --() requires is_bitr<I> {
    --i;
    return *this;
  }
  this_t operator --(int) requires is_bitr<I> {
    return iter_post_decrement(*this);
  }

  this_t &operator +=(difference_type k) requires is_ritr<I> {
    i += k;
    return *this;
  }
  this_t &operator -=(difference_type k) requires is_ritr<I> {
    i -= k;
    return *this;
  }
  this_t operator +(difference_type k) const requires is_ritr<I> {
    return this_t(i + k);
  }
  this_t operator -(difference_type k) const requires is_ritr<I> {
    return this_t(i - k);
  }
  reference operator [](difference_type k) const requires is_ritr<I> {
    return i[k];
  }

  template <class I1, class I2>
  friend bool operator ==(const tree_iterator<I1> &, const tree_iterator<I2> &)
    requires can_apply_equal_to<const I1 &, const I2 &>;
  template <class I1, class I2>
  friend synth_3way_result<I1, I2>
  operator <=>(const tree_iterator<I1> &, const tree_iterator<I2> &);
  template <class I1>
  friend tree_iterator<I1> operator +(itr_dft<I1>, const tree_iterator<I1> &)
    requires is_ritr<I1>;
  template <class I1, class I2>
  friend auto operator -(const tree_iterator<I1> &x,
                         const tree_iterator<I2> &y)->decltype(x.i - y.i);

  using first_order_iterator = inner::tree_first_order_iterator<this_t>;
  using last_order_iterator = inner::tree_last_order_iterator<this_t>;
  using nth_order_iterator = inner::tree_nth_order_iterator<this_t>;

  first_order_iterator first_order_begin() const {
    const this_t p = (*this == nullptr) ? this_t{} : parent();
    return first_order_iterator
      (*this, (p != nullptr && p->end() == *this) ? this_t{} : *this);
  }
  first_order_iterator first_order_end() const {
    return first_order_iterator(*this, this_t{});
  }
  iter_pair<first_order_iterator> first_order() const {
    return rng(first_order_begin(), first_order_end());
  }

  last_order_iterator last_order_begin() const {
    if (const this_t p = (*this == nullptr) ? this_t{} : parent();
        p != nullptr && p->end() == *this)
      return last_order_iterator(*this, this_t{});
    this_t it = *this;
    if (it != nullptr)
      while (!it->empty())
        it = it->begin();
    return last_order_iterator(*this, it);
  }
  last_order_iterator last_order_end() const {
    return last_order_iterator(*this, this_t{});
  }
  iter_pair<last_order_iterator> last_order() const {
    return rng(last_order_begin(), last_order_end());
  }

  nth_order_iterator nth_order_begin(difference_type d) const {
    if (const this_t p = (*this == nullptr) ? this_t{} : parent();
        p != nullptr && p->end() == *this)
      return nth_order_iterator(*this, this_t{}, d);
    if (d == 0)
      return nth_order_iterator(*this, *this, d);
    else {
      this_t j = *this;
      if (j != nullptr)
        while (!j->empty())
          j = j->begin();
      return nth_order_iterator(*this, j, d);
    }
  }
  nth_order_iterator nth_order_end(difference_type d) const {
    this_t it = *this;
    return nth_order_iterator(*this, this_t{}, d);
  }
  iter_pair<nth_order_iterator> nth_order(difference_type d) const {
    return rng(nth_order_begin(d), nth_order_end(d));
  }
};
template <class I1, class I2>
bool operator ==(const tree_iterator<I1> &x, const tree_iterator<I2> &y)
  requires can_apply_equal_to<const I1 &, const I2 &> {
  return x.i == y.i;
}
template <class I1, class I2>
synth_3way_result<I1, I2>
operator <=>(const tree_iterator<I1> &x, const tree_iterator<I2> &y) {
  return synth_3way(x.i, y.i);
}
template <class I1>
tree_iterator<I1> operator +(itr_dft<I1> k, const tree_iterator<I1> &x)
  requires is_ritr<I1> {
  return tree_iterator<I1>(x.i + k);
}
template <class I1, class I2>
auto operator -(const tree_iterator<I1> &x,
                const tree_iterator<I2> &y)->decltype(x.i - y.i) {
  return x.i - y.i;
}

template <class VOID_PTR>
struct tree_base {
  pointer_rebind_t<VOID_PTR, pointer_rebind_t<VOID_PTR, tree_base>> iter{};
  pointer_rebind_t<VOID_PTR, tree_base> p{};

  tree_base() = default;
  ~tree_base() = default;
  tree_base(const tree_base &) = default;
  tree_base &operator =(const tree_base &x) noexcept {
    iter = x.iter;
    return *this;
  }
  tree_base(tree_base &&) = default;
  tree_base &operator =(tree_base &&x) noexcept {
    return operator =(as_const(x));
  }
  friend void swap(tree_base &x, tree_base &y) noexcept {
    adl_swap(x.iter, y.iter);
  }
};
template <class>
struct linked_tree_base;

template <class TRAITS>
class tree_node_impl;
template <class TRAITS>
class tree_node : TRAITS::hook_type {
  template <class>
  friend class tree_node_impl;
  template <class, class, size_t>
  friend struct gtt;
  template <class, class>
  friend struct ltt;
  template <class, class>
  friend struct lgtt;
  template <class>
  friend class re::tree_adaptor;
  template <class>
  friend class re::tree_vector_adaptor;

  using this_t = tree_node;

protected:
  using base_t = typename TRAITS::hook_type;
  using base_t::p;

  using vec_t = typename TRAITS::vector_type;
  using vec_iter_t = typename vec_t::iterator;
  using vec_citer_t = typename vec_t::const_iterator;
  using node_alloc_t = typename TRAITS::allocator_type;
  using key_t = typename TRAITS::key_type;
  using key_alloc_t = alloc_rebind<node_alloc_t, key_t>;

  alignas(key_t) byte data[sizeof(key_t)];
  vec_t v;

  key_t *data_ptr() const noexcept {
    return const_cast<key_t *>
      (reinterpret_cast<const key_t *>(addressof(data)));
  }

  tree_node(allocator_arg_t, const node_alloc_t &a)
    : base_t{}, data{}, v(a) {}

  ~tree_node() = default;
public:
  tree_node() = delete;
  tree_node(const tree_node &) = delete;
  tree_node &operator =(const tree_node &) = delete;
  tree_node(tree_node &&) = delete;
  tree_node &operator =(tree_node &&) = delete;
  friend void swap(tree_node &, tree_node &) noexcept = delete;

  using key_type = key_t;
  using value_type = this_t;
  using reference = this_t &;
  using const_reference = const this_t &;

  using iterator = inner::tree_iterator<typename vec_t::iterator>;
  using const_iterator = inner::tree_iterator<typename vec_t::const_iterator>;
  using difference_type = typename vec_t::difference_type;
  using size_type = typename vec_t::size_type;

  iterator begin() noexcept {
    return iterator(v.begin());
  }
  iterator end() {
    return iterator(v.end());
  }
  const_iterator begin() const noexcept {
    return const_iterator(v.begin());
  }
  const_iterator end() const noexcept {
    return const_iterator(v.end());
  }
  const_iterator cbegin() const noexcept {
    return const_iterator(v.begin());
  }
  const_iterator cend() const noexcept {
    return const_iterator(v.end());
  }

  size_type max_size() const noexcept {
    return v.max_size();
  }
  size_type size() const noexcept requires rng_is_sized<vec_t> {
    return re::size(v);
  }
  bool empty() const noexcept {
    return v.empty();
  }

  using reverse_iterator = re::reverse_iterator<iterator>;
  using const_reverse_iterator = re::reverse_iterator<const_iterator>;

  reverse_iterator rbegin() noexcept {
    return reverse_iterator(end());
  }
  reverse_iterator rend() noexcept {
    return reverse_iterator(begin());
  }
  const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator(begin());
  }
  const_reverse_iterator crbegin() const noexcept {
    return rbegin();
  }
  const_reverse_iterator crend() const noexcept {
    return rend();
  }

  reference front() requires inner::has_mfn_front<vec_t> {
    return v.front();
  }
  reference back() requires inner::has_mfn_back<vec_t> {
    return v.back();
  }
  const_reference front() const requires inner::has_mfn_front<const vec_t> {
    return v.front();
  }
  const_reference back() const requires inner::has_mfn_front<const vec_t> {
    return v.back();
  }

  this_t &operator [](size_type n) {
    return static_cast<this_t &>(v[n]);
  }
  const this_t &operator [](size_type n) const {
    return static_cast<const this_t &>(v[n]);
  }

  iterator nth(difference_type n) {
    return iterator(re::nth(v, n));
  }
  const_iterator nth(difference_type n) const {
    return const_iterator(re::nth(v, n));
  }

  key_t &key() noexcept {
    return *data_ptr();
  }
  const key_t &key() const noexcept {
    return *data_ptr();
  }
  key_t &operator *() noexcept {
    return *data_ptr();
  }
  const key_t &operator *() const noexcept {
    return *data_ptr();
  }
  key_t *operator ->() noexcept {
    return data_ptr();
  }
  const key_t *operator ->() const noexcept {
    return data_ptr();
  }

  iterator parent() noexcept {
    return iterator(vec_iter_t(base_t::p));
  }
  const_iterator parent() const noexcept {
    return const_iterator(vec_citer_t(base_t::p));
  }
protected:
  void parent(const_iterator it) noexcept {
    p = it.node();
  }
public:
  iterator iter() noexcept {
    return iterator
      (vec_iter_t
       (static_cast<typename TRAITS::node_base_pointer>
        (pointer_to<typename TRAITS::public_node_pointer>(*this))));
  }
  const_iterator iter() const noexcept {
    return const_iterator
      (vec_citer_t
       (static_cast<typename TRAITS::node_base_pointer>
        (pointer_to<typename TRAITS::public_node_pointer>
         (const_cast<this_t &>(*this)))));
  }
};
template <class X, class Y>
bool operator ==(const tree_node<X> &xx, const tree_node<Y> &yy) {
  if (!(*xx == *yy && size(xx) == size(yy)))
    return false;
  auto it = xx.begin();
  auto it2 = yy.begin();
  for (; it != xx.end(); ++it, (void)++it2) {
    auto x_parent = it;
    auto x = it->begin();
    auto y_parent = it2;
    auto y = it2->begin();
    for (;;) {
      if (!(**x_parent == **y_parent
            && size(*x_parent) == size(*y_parent)))
        return false;
      while (x == x_parent->end()) {
        if (x_parent == it)
          goto continue_label;
        x = x_parent;
        x_parent = x_parent.parent();
        y = y_parent;
        y_parent = y_parent.parent();
        ++x;
        ++y;
      }
      x_parent = x;
      x = x->begin();
      y_parent = y;
      y = y->begin();
    }
  continue_label:
    ;
  }
  return true;
}

template <class TRAITS>
class tree_node_impl : public tree_node<TRAITS> {
  using this_t = tree_node_impl;
  using base_t = tree_node<TRAITS>;

  using base_t::p;
  using base_t::data_ptr;
  using base_t::v;

  using vec_t = typename base_t::vec_t;
  using vec_iter_t = typename vec_t::iterator;
  using vec_citer_t = typename vec_t::const_iterator;
  using iter_t = tree_iterator<vec_iter_t>;
  using citer_t = tree_iterator<vec_citer_t>;
  using node_alloc_t = typename base_t::node_alloc_t;
  using key_t = typename base_t::key_t;
  using key_alloc_t = typename base_t::key_alloc_t;

public:
  using public_node_type = tree_node<TRAITS>;
  using public_node_pointer = typename TRAITS::public_node_pointer;
  base_t &node_ref() noexcept {
    return static_cast<base_t &>(*this);
  }
  const base_t &node_ref() const noexcept {
    return static_cast<const base_t &>(*this);
  }

  tree_node_impl() = delete;
  ~tree_node_impl() {
    auto a = allocator_wrapper<node_alloc_t>(v.get_allocator())
      .template rebind<key_t>();
    if (!v.empty()) {
      auto it = prev(v.end());
      for (;;) {
        while (!it->v.empty())
          it = prev(it->v.end());
        it = tree_iterator<decltype(it)>(it).parent().base();
        if (it.node() == p)
          break;
        it->v.pop_back();
      }
    }
    a.destroy(data_ptr());
  }
  // vec<tree_node_impl>
  //   copy constructor: WORK for the top row
  //   copy assignment: NOT WORK
  //   move constructor: WORK
  //   move assignment: NOT WORK
  //   swap: WORK for equal allocators or allocator propagating on swap
  tree_node_impl(const tree_node_impl &x)
    : base_t{allocator_arg, x.v.get_allocator()} {
    allocator_wrapper<key_alloc_t>(v.get_allocator()).construct(data_ptr(), *x);
    iter_t(v.end()).parent(base_t::iter());
  }
  tree_node_impl &operator =(const tree_node_impl &x) {
    p = nullptr;
    *data_ptr() = *x.data_ptr();
    v = vec_t(v.get_allocator());
    return *this;
  }
  tree_node_impl(tree_node_impl &&) noexcept
    : base_t(allocator_arg, node_alloc_t{}) {}
  tree_node_impl &operator =(tree_node_impl &&) noexcept {
    return *this;
  }
  friend void swap(tree_node_impl &, tree_node_impl &) noexcept {}

  template <class...S>
  explicit tree_node_impl(const key_alloc_t &a, S &&...s)
    : base_t(allocator_arg, a) {
    allocator_wrapper<key_alloc_t>(v.get_allocator())
      .construct(data_ptr(), forward<S>(s)...);
    iter_t(v.end()).parent(base_t::iter());
  }

  template <class T1>
  explicit tree_node_impl
  (tuple<T1, typename vec_t::const_iterator, node_alloc_t> &&t)
    : tree_node_impl(at<2>(t), at<0>(move(t))) {
    p = at<1>(t).node();
    iter_t(v.end()).parent(base_t::iter());
  }
};

template <class T, class AL, size_t N>
struct gtt {
  static_assert(is_same_v<T, alloc_vt<AL>>);

  using value_type = inner::tree_node_impl<gtt>;
  using allocator_type = alloc_rebind<AL, value_type>;
  using node_type = value_type;
  using node_pointer = alloc_rebind_ptr<AL, node_type>;
  using node_base_type = inner::tree_base<alloc_void_ptr<AL>>;
  using node_base_pointer = alloc_rebind_ptr<AL, node_base_type>;
  using difference_type = alloc_dft<AL>;
  using size_type = alloc_szt<AL>;

  using id = size_constant<0>;
  using store_node_allocator = true_type;
  using store_allocator = true_type;

  using node_base_pointer_pointer = alloc_rebind_ptr<AL, node_base_pointer>;

  static node_base_pointer_pointer index_iter(node_base_pointer p) {
    return p->iter;
  }
  static void index_iter(node_base_pointer p, node_base_pointer_pointer x) {
    p->iter = x;
  }

  static value_type *data(node_base_pointer p) {
    return to_address(static_cast<node_pointer>(p));
  }

  template <class...S>
  static node_base_pointer new_node(allocator_type &al, S &&...s) {
    return allocator_wrapper<allocator_type>(al).new_1
      (forward<S>(s)...);
  }
  static void delete_node(allocator_type &al,
                          node_base_pointer p) noexcept {
    allocator_wrapper<allocator_type>(al)
      .delete_1(static_cast<node_pointer>(p));
  }

  using key_type = T;
  using vector_type = stable_vector_adaptor<gtt, N>;
  using hook_type = node_base_type;
  using public_node_type = inner::tree_node<gtt>;
  using public_node_pointer = alloc_rebind_ptr<AL, public_node_type>;
  static node_base_pointer tree_parent(node_base_pointer p) {
    return p->p;
  }
  static void tree_parent(node_base_pointer p, node_base_pointer pp) {
    p->p = pp;
  }
};


template <class VOID_PTR>
struct linked_tree_base {
  pointer_rebind_t<VOID_PTR, linked_tree_base> prev = nullptr;
  pointer_rebind_t<VOID_PTR, linked_tree_base> next = nullptr;
  pointer_rebind_t<VOID_PTR, linked_tree_base> p = nullptr;

  linked_tree_base() = default;
  ~linked_tree_base() = default;
  linked_tree_base(const linked_tree_base &) = default;
  linked_tree_base &operator =(const linked_tree_base &x) noexcept {
    prev = x.prev;
    next = x.next;
    return *this;
  }
  linked_tree_base(linked_tree_base &&) = default;
  linked_tree_base &operator =(linked_tree_base &&x) noexcept {
    return operator =(as_const(x));
  }
  friend void swap(linked_tree_base &x, linked_tree_base &y) noexcept {
    adl_swap(x.prev, y.prev);
    adl_swap(x.next, y.next);
  }
};
template <class NODE_BASE_TYPE, class SIZE_TYPE>
struct linked_tree_header {
  mutable NODE_BASE_TYPE ed;
  SIZE_TYPE sz;
};

template <class T, class AL>
struct ltt {
  static_assert(is_same_v<T, alloc_vt<AL>>);

  using value_type = inner::tree_node_impl<ltt>;
  using allocator_type = alloc_rebind<AL, value_type>;
  using node_type = value_type;
  using node_pointer = alloc_rebind_ptr<AL, node_type>;
  using node_base_type = inner::linked_tree_base<alloc_void_ptr<AL>>;
  using node_base_pointer = alloc_rebind_ptr<AL, node_base_type>;
  using difference_type = alloc_dft<AL>;
  using size_type = alloc_szt<AL>;

  using id = size_constant<0>;
  using store_node_allocator = true_type;
  using store_allocator = true_type;
  using store_size = true_type;

  using node_base_pointer_pointer = alloc_rebind_ptr<AL, node_base_pointer>;

  static node_base_pointer prev(node_base_pointer p) {
    return p->prev;
  }
  static void prev(node_base_pointer p, node_base_pointer prev_p) {
    p->prev = prev_p;
  }

  static node_base_pointer next(node_base_pointer p) {
    return p->next;
  }
  static void next(node_base_pointer p, node_base_pointer next_p) {
    p->next = next_p;
  }

  static value_type *data(node_base_pointer p) {
    return to_address(static_cast<node_pointer>(p));
  }

  using header_type = inner::linked_tree_header<node_base_type, size_type>;
  static node_base_pointer end_node(const header_type &h) {
    return pointer_traits<node_base_pointer>::pointer_to(h.ed);
  }
  static size_type size(const header_type &h) {
    return h.sz;
  }
  static void size(header_type &h, size_type n) {
    h.sz = n;
  }

  template <class...S>
  static node_base_pointer new_node(allocator_type &a, S &&...s) {
    return allocator_wrapper<allocator_type>(a).new_1(forward<S>(s)...);
  }
  static void delete_node(allocator_type &a, node_base_pointer p) noexcept {
    allocator_wrapper<allocator_type>(a).delete_1(static_cast<node_pointer>(p));
  }

  using key_type = T;
  using vector_type = list_adaptor<ltt>;
  using hook_type = node_base_type;
  using public_node_type = inner::tree_node<ltt>;
  using public_node_pointer = alloc_rebind_ptr<AL, public_node_type>;
  static node_base_pointer tree_parent(node_base_pointer p) {
    return p->p;
  }
  static void tree_parent(node_base_pointer p, node_base_pointer pp) {
    p->p = pp;
  }
};


template <class VOID_PTR>
struct logn_tree_base {
  pointer_rebind_t<VOID_PTR, logn_tree_base> left_child{};
  pointer_rebind_t<VOID_PTR, logn_tree_base> right_child{};
  pointer_rebind_t<VOID_PTR, logn_tree_base> parent{};
  pointer_rebind_t<VOID_PTR, logn_tree_base> p{};

  struct header {
    mutable logn_tree_base ed;
  };

  logn_tree_base() = default;
  ~logn_tree_base() = default;
  logn_tree_base(const logn_tree_base &) = default;
  logn_tree_base &operator =(const logn_tree_base &x) noexcept {
    left_child = x.left_child;
    right_child = x.right_child;
    parent = x.parent;
    return *this;
  }
  logn_tree_base(logn_tree_base &&) = default;
  logn_tree_base &operator =(logn_tree_base &&x) noexcept {
    return operator =(as_const(x));
  }
  friend void swap(logn_tree_base &x, logn_tree_base &y) noexcept {
    adl_swap(x.left_child, y.left_child);
    adl_swap(x.right_child, y.right_child);
    adl_swap(x.parent, y.parent);
  }
};
template <class VOID_PTR>
struct logn_tree_base2 : logn_tree_base<VOID_PTR> {
  ptrdiff_t state;
};

template <class T, class AL>
struct lgtt {
  static_assert(is_same_v<T, alloc_vt<AL>>);

  using value_type = inner::tree_node_impl<lgtt>;
  using allocator_type = alloc_rebind<AL, value_type>;
  using node_type = value_type;
  using node_pointer = alloc_rebind_ptr<AL, node_type>;
  using node_base_type = inner::logn_tree_base<alloc_void_ptr<AL>>;
  using node_base_pointer = alloc_rebind_ptr<AL, node_base_type>;
  using difference_type = alloc_dft<AL>;
  using size_type = alloc_szt<AL>;

  using id = size_constant<0>;
  using store_node_allocator = true_type;
  using store_allocator = true_type;

  static node_base_pointer left_child(node_base_pointer p) {
    return p->left_child;
  }
  static void left_child(node_base_pointer p, node_base_pointer p2) {
    p->left_child = p2;
  }

  static node_base_pointer right_child(node_base_pointer p) {
    return p->right_child;
  }
  static void right_child(node_base_pointer p, node_base_pointer p2) {
    p->right_child = p2;
  }

  static node_base_pointer parent(node_base_pointer p) {
    return p->parent;
  }
  static void parent(node_base_pointer p, node_base_pointer p2) {
    p->parent = p2;
  }

  static ptrdiff_t state(node_base_pointer p) {
    return static_cast<inner::logn_tree_base2<alloc_void_ptr<AL>> &>(*p).state;
  }
  static void state(node_base_pointer p, ptrdiff_t n) {
    static_cast<inner::logn_tree_base2<alloc_void_ptr<AL>> &>(*p).state = n;
  }

  static value_type *data(node_base_pointer p) {
    return to_address(static_cast<node_pointer>(p));
  }

  using header_type = typename node_base_type::header;
  static node_base_pointer end_node(const header_type &h) {
    return pointer_traits<node_base_pointer>::pointer_to(h.ed);
  }

  template <class...S>
  static node_base_pointer new_node(allocator_type &al, S &&...s) {
    return allocator_wrapper<allocator_type>(al).new_1(forward<S>(s)...);
  }
  static void delete_node(allocator_type &al,
                          node_base_pointer p) noexcept {
    allocator_wrapper<allocator_type>(al)
      .delete_1(static_cast<node_pointer>(p));
  }

  using key_type = T;
  using vector_type = ranked_rbtree_adaptor<lgtt>;
  using hook_type = inner::logn_tree_base2<alloc_void_ptr<AL>>;
  using public_node_type = inner::tree_node<lgtt>;
  using public_node_pointer = alloc_rebind_ptr<AL, public_node_type>;
  static node_base_pointer tree_parent(node_base_pointer p) {
    return p->p;
  }
  static void tree_parent(node_base_pointer p, node_base_pointer pp) {
    p->p = pp;
  }
};

}

template <class TRAITS>
class tree_adaptor
  : allocator_wrapper<alloc_rebind<typename TRAITS::allocator_type,
                                   typename TRAITS::key_type>> {
  template <class>
  friend class tree_adaptor;
  template <class>
  friend class tree_vector_adaptor;

  using this_t = tree_adaptor;

  using vec_t = typename TRAITS::vector_type;
  using vec_iter_t = typename vec_t::iterator;
  using vec_citer_t = typename vec_t::const_iterator;

  using node_t = typename TRAITS::node_type;
  using node_alloc_t = typename TRAITS::allocator_type;

  using public_node_t = typename TRAITS::public_node_type;
  using public_node_ptr = typename TRAITS::public_node_pointer;

  using key_t = typename TRAITS::key_type;
  using key_alloc_t = alloc_rebind<typename TRAITS::allocator_type, key_t>;
  using key_alw_t = allocator_wrapper<key_alloc_t>;

  inner::tree_iterator<typename vec_t::iterator> iter;

  using key_alw_t::allocate;
  using key_alw_t::construct;
  using key_alw_t::destroy;
  using key_alw_t::deallocate;
  using key_alw_t::destroy_fn;
  using key_alw_t::new_1;
  using key_alw_t::new_n;
  using key_alw_t::delete_1;
  using key_alw_t::delete_n;
  using key_alw_t::make_temporary;
  using key_alw_t::uninitialized_fill;
  using key_alw_t::uninitialized_copy;
  using key_alw_t::uninitialized_move;
  using key_alw_t::uninitialized_fully_move;
  using key_alw_t::fully_move;

public:
  using tree_type = this_t;
  using vector_type = tree_vector_adaptor<TRAITS>;

  using key_type = key_t;
  using value_type = public_node_t;
  using reference = value_type &;
  using const_reference = const value_type &;

  using iterator = inner::tree_iterator<typename vec_t::iterator>;
  using const_iterator = inner::tree_iterator<typename vec_t::const_iterator>;
  using difference_type = typename vec_t::difference_type;
  using size_type = typename vec_t::size_type;

  iterator root() noexcept {
    return iter;
  }
  const_iterator root() const noexcept {
    return iter;
  }
  const_iterator croot() const noexcept {
    return iter;
  }

  bool empty() const noexcept {
    return iter == nullptr;
  }

private:
  template <class...S>
  iterator new_node(S &&...s) {
    node_alloc_t na(alloc_ref());
    return iterator(vec_iter_t(TRAITS::new_node
                               (na, alloc_ref(), forward<S>(s)...)));
  }
  void delete_node(const_iterator i) noexcept {
    node_alloc_t na(alloc_ref());
    TRAITS::delete_node(na, i.node());
  }

  iterator release() noexcept {
    return re::exchange(iter, iterator{});
  }

  iterator link(const_iterator i, const_iterator x) {
    const iterator p = i.parent().to_mutable();
    p->v.link(i.base(), x.base());
    x.parent(p);
    return x.to_mutable();
  }
  iterator link_front(const_iterator p, const_iterator x) {
    p.to_mutable()->v.link_front(x.base());
    x.parent(p);
    return x.to_mutable();
  }
  iterator link_back(const_iterator p, const_iterator x) {
    p.to_mutable()->v.link_back(x.base());
    x.parent(p);
    return x.to_mutable();
  }
  iterator unlink(const_iterator x) noexcept {
    return (x != iter)
      ? iterator(x.to_mutable().parent()->v.unlink(x.base()))
      : (iter = iterator{});
  }
  iterator unlink(const_iterator i1, const_iterator i2) noexcept {
    return (i1 != i2)
      ? iterator(i1.parent().to_mutable()->v.unlink(i1.base(), i2.base()))
      : i1.to_mutable();
  }
  iterator unlink_front(const_iterator p) noexcept {
    return iterator(p.to_mutable()->v.unlink_front());
  }
  iterator unlink_back(const_iterator p) noexcept {
    return iterator(p.to_mutable()->v.unlink_back());
  }
  void unlink() noexcept {
    iter = iterator{};
  }

  template <class IT>
  void reserve_cond(iterator target, IT p) {}
  template <class IT>
  void reserve_cond(iterator target, IT p)
    requires requires {target->v.reserve(0u);} {
    const auto n = size(*p);
    if (n > target->v.max_size())
      throw_or_terminate<length_error>
        ("re::tree_adaptor::reserve(x, p): size overflow\n");
    target->v.reserve(static_cast<decltype(target->v.size())>(n));
  }
  template <class IT, class GET_KEY>
  iterator clone_node(IT p, GET_KEY get_key) {
    IT it = p;
    const iterator ret = new_node(get_key(*it));
    iterator x = ret;
#ifndef RE_NOEXCEPT
    try {
#endif
      for (;;) {
        if (it->empty()) {
          for (;;) {
            for (;;) {
              if (it == p)
                return ret;
              ++it;
              ++x;
              if (it == it.parent()->end()) {
                it = it.parent();
                x = x.parent();
              }
              else
                goto continue_label;
            }
          }
        }
        else {
          {
            const auto guard = exit_fn([x]() {
              for (auto &i : iters(x->v))
                iterator(i).parent(x);
            });
            reserve_cond(x, it);
            for (auto &u : *it)
              emplace_back(x, get_key(u));
          }
          it = it->begin();
          x = x->begin();
        }
      continue_label:
        ;
      }
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      delete_node(ret);
      throw;
    }
#endif
    return ret;
  }
  template <class IT>
  iterator clone_node(IT p) {
    return clone_node(p, deref);
  }

  friend class allocator_aware_container_ownership<this_t>;
  const auto &alloc_ref() const noexcept {
    return key_alw_t::get();
  }
  auto &alloc_ref() noexcept {
    return key_alw_t::get();
  }
  void new_data() noexcept {
    iter = iterator{};
  }
  void delete_data() noexcept {
    if (iter != nullptr) {
      delete_node(iter);
      iter = iterator{};
    }
  }
  void new_data(const this_t &v) {
    iter = ((v.iter != nullptr) ? clone_node(v.iter, deref) : iterator{});
  }
  void new_data(this_t &&v) noexcept {
    iter = v.iter;
    v.iter = iterator{};
  }
  void new_data_individually(this_t &&v) {
    if (v.iter != nullptr) {
      iter = clone_node(v.iter, [](auto &x)->auto && {return move(*x);});
      v.delete_node(v.iter);
      v.iter = iterator{};
    }
    else
      iter = iterator{};
  }
  void swap_data(this_t &v) noexcept {
    adl_swap(iter, v.iter);
  }

public:
  tree_adaptor() {
    new_data();
  }
  ~tree_adaptor() {
    delete_data();
  }
  tree_adaptor(const tree_adaptor &t) : key_alw_t(t.alloc_ref()) {
    new_data(t);
  }
  tree_adaptor &operator =(const tree_adaptor &t) {
    allocator_aware_container_ownership<this_t>::copy_assign(*this, t);
    return *this;
  }
  tree_adaptor(tree_adaptor &&t) noexcept : key_alw_t(move(t.alloc_ref())) {
    new_data(move(t));
  }
  tree_adaptor &operator =(tree_adaptor &&t)
    noexcept(alloc_move_prpg<key_alloc_t>
             || alloc_always_equal<key_alloc_t>) {
    allocator_aware_container_ownership<this_t>::move_assign(*this, t);
    return *this;
  }
  friend void swap(tree_adaptor &x, tree_adaptor &y)
    noexcept(alloc_swap_prpg<key_alloc_t>
             || alloc_always_equal<key_alloc_t>) {
    allocator_aware_container_ownership<this_t>::swap(x, y);
  }

  using allocator_type = key_alloc_t;
  allocator_type get_allocator() const noexcept {
    return key_alw_t::get();
  }

  explicit tree_adaptor(const allocator_type &al) noexcept
    : key_alw_t(al), iter{} {}
  tree_adaptor(const tree_adaptor &v, const allocator_type &al)
    : key_alw_t(al) {
    new_data(v);
  }
  tree_adaptor(tree_adaptor &&v, const allocator_type &al) : key_alw_t(al) {
    allocator_aware_container_ownership<this_t>::move_construct(*this, v);
  }

  template <class TRAITS2,
            class = enable_if_t
            <!is_same_v<TRAITS, TRAITS2>
             && is_constructible_v<key_type,
                                   const typename TRAITS2::key_type &>>>
  explicit tree_adaptor(const tree_adaptor<TRAITS2> &x,
                        const allocator_type &al = allocator_type{})
    : key_alw_t(al) {
    iter = ((x.root() != nullptr) ? clone_node(x.root()) : iterator{});
  }
  template <class TRAITS2>
  enable_if_t<!is_same_v<TRAITS, TRAITS2>
              && is_assignable_v<key_type &,
                                 const typename TRAITS2::key_type &>,
              tree_adaptor &>
  operator =(const tree_adaptor<TRAITS2> &x) {
    const iterator tmp = ((x.iter != nullptr)
                          ? clone_node(x.root()) : iterator{});
    clear();
    iter = tmp;
    return *this;
  }

  template <class TRAITS2,
            class = enable_if_t
            <!is_same_v<TRAITS, TRAITS2>
             && is_constructible_v<key_type,
                                   typename TRAITS2::key_type &&>>>
  explicit tree_adaptor(tree_adaptor<TRAITS2> &&x,
                        const allocator_type &al = allocator_type{})
    : key_alw_t(al) {
    iter = ((x.root() != nullptr)
            ? clone_node(x.root(), [](auto &x)->auto && {return move(*x);})
            : iterator{});
    x.delete_data();
    x.new_data();
  }
  template <class TRAITS2>
  enable_if_t<!is_same_v<TRAITS, TRAITS2>
              && is_assignable_v<key_type &,
                                 typename TRAITS2::key_type &&>,
              tree_adaptor &>
  operator =(tree_adaptor<TRAITS2> &&x) {
    const iterator tmp
      = ((x.iter != nullptr)
         ? clone_node(x.iter, [](auto &x)->auto && {return move(*x);})
         : iterator{});
    clear();
    iter = tmp;
    x.delete_data();
    x.new_data();
    return *this;
  }

  template <class...S>
  explicit tree_adaptor(in_place_t, S &&...s) {
    iter = new_node(forward<S>(s)...);
    iter.parent(iterator{});
  }
  template <class...S>
  explicit tree_adaptor(allocator_arg_t, const allocator_type &al,
                        in_place_t, S &&...s) : key_alw_t(al) {
    iter = new_node(forward<S>(s)...);
    iter.parent(iterator{});
  }

private:
  void cat_impl() {}
  template <class...S>
  void cat_impl(this_t &&x, S &&...s) {
    insert(root()->end(), this_t(move(x), get_allocator()));
    cat_impl(forward<S>(s)...);
  }
public:
  template <class...S>
  explicit tree_adaptor(const key_type &key, S &&...s) {
    iter = new_node(key);
    iter.parent(iterator{});
    cat_impl(forward<S>(s)...);
  }
  template <class...S>
  explicit tree_adaptor(key_type &&key, S &&...s) {
    iter = new_node(move(key));
    iter.parent(iterator{});
    cat_impl(forward<S>(s)...);
  }
  explicit tree_adaptor(allocator_arg_t, const allocator_type &al)
    : key_alw_t(al) {
    new_data();
  }
  template <class...S>
  explicit tree_adaptor(allocator_arg_t, const allocator_type &al,
                        const key_type &key, S &&...s) : key_alw_t(al) {
    iter = new_node(key);
    iter.parent(iterator{});
    cat_impl(forward<S>(s)...);
  }
  template <class...S>
  explicit tree_adaptor(allocator_arg_t, const allocator_type &al,
                        key_type &&key, S &&...s) : key_alw_t(al) {
    iter = new_node(move(key));
    iter.parent(iterator{});
    cat_impl(forward<S>(s)...);
  }
  static auto maker() {
    return []<class T, class...S>(T &&x, S &&...s)->this_t {
      return this_t(forward<T>(x), forward<S>(s)...);
    };
  }
  static auto maker_with_allocator(const allocator_type &al) {
    return [a = al]<class T, class...S>(T &&x, S &&...s)->this_t {
      return this_t(allocator_arg, a, forward<T>(x), forward<S>(s)...);
    };
  }

  template <class GET_KEY>
  this_t copy(const_iterator p, GET_KEY get_key) {
    this_t ret(get_allocator());
    ret.iter = clone_node(p, get_key);
    return ret;
  }
  template <class GET_KEY>
  this_t copy(iterator p, GET_KEY get_key) {
    this_t ret(get_allocator());
    ret.iter = clone_node(p, get_key);
    return ret;
  }
  this_t copy(const_iterator p) {
    return copy(p, deref);
  }
  this_t copy(iterator p) {
    return copy(p, deref);
  }
  template <class U, class IT, class GET_KEY>
  this_t copy(U &u, IT i, GET_KEY get_key) {
    this_t ret(get_allocator());
    ret.iter = clone_node(i, get_key);
    return ret;
  }

  template <class...S>
  value_type &emplace(S &&...s)
    requires (sizeof...(s) == 0u
              || (!is_convertible_v<nth_type_t<0, S &&...>, const_iterator>
                  && !is_convertible_v<nth_type_t<0, S &&...>, iterator>)) {
    clear();
    iter = new_node(forward<S>(s)...);
    iter.parent(iterator{});
    return *root();
  }
  void clear() noexcept {
    delete_data();
  }

  void swap(const_iterator i, const_iterator j) {
    if (i != iter) {
      const auto i_p = i.to_mutable().parent();
      const auto j_p = j.to_mutable().parent();
      i_p->v.swap(i.base(), j_p->v, j.base());
      i.parent(j_p);
      j.parent(i_p);
    }
  }
  void swap(const_iterator i, this_t &l, const_iterator j) {
    if (i == iter) {
      if (j == l.iter)
        adl_swap(iter, l.iter);
      else {
        const auto j_p = j.to_mutable().parent();
        iter = iterator(j_p->v.exchange_node(j.base(), i.base()));
        iter.parent(iterator{});
        i.parent(j_p);
      }
    }
    else {
      if (j == l.iter) {
        const auto i_p = i.to_mutable().parent();
        l.iter = iterator(i_p->v.exchange_node(i.base(), j.base()));
        l.iter.parent(iterator{});
        j.parent(i_p);
      }
      else {
        const auto i_p = i.to_mutable().parent();
        const auto j_p = j.to_mutable().parent();
        i_p->v.swap(i.base(), j_p->v, j.base());
        j.parent(i_p);
        i.parent(j_p);
      }
    }
  }
  void swap(const_iterator i, this_t &&l, const_iterator j) {
    return swap(i, l, j);
  }
  void swap(const_iterator i, vector_type &l, const_iterator j) {
    l.swap(j, *this, i);
  }
  void swap(const_iterator i, vector_type &&l, const_iterator j) {
    swap(i, l, j);
  }

  this_t extract(const_iterator i) noexcept {
    this_t ret(get_allocator());
    unlink(i);
    i.parent(const_iterator{});
    ret.iter = i.to_mutable();
    return ret;
  }
  iterator insert(const_iterator next, this_t &&x) {
    if (!x.empty()) {
      const iterator p = next.to_mutable().parent();
      const iterator i(p->v.link(next.base(), x.iter.base()));
      i.parent(p);
      return x.release();
    }
    else
      return next.to_mutable();
  }
  this_t exchange(const_iterator i, this_t &&x) noexcept {
    this_t ret(get_allocator());
    if (i == iter) {
      ret.iter = iter;
      iter = x.iter;
    }
    else {
      if (!x.empty()) {
        const auto i_p = i.to_mutable().parent();
        ret.iter = iterator(i_p->v.exchange_node(i.base(), x.iter.base()));
        ret.iter.parent(iterator{});
        x.iter.parent(i_p);
      }
      else {
        unlink(i);
        ret.iter = i.to_mutable();
        i.parent(iterator{});
      }
    }
    x.iter = iterator{};
    return ret;
  }
  iterator replace(const_iterator i, this_t &&x) noexcept {
    if (i == iter) {
      if (iter != nullptr)
        delete_node(iter);
      iter = x.iter;
      x.iter = iterator{};
      return iter;
    }
    else {
      if (!x.empty()) {
        const auto i_p = i.to_mutable().parent();
        delete_node(iterator(i_p->v.exchange_node(i.base(), x.iter.base())));
        x.iter.parent(i_p);
        return re::exchange(x.iter, iterator{});
      }
      else
        return erase(i);
    }
  }

  vector_type extract(const_iterator i1, const_iterator i2) {
    vector_type ret(get_allocator());
    if (i1 != i2) {
      const iterator p = i1.to_mutable().parent();
      auto &vv = p->v;
      ret.v.splice(ret.v.end(), vv, i1.base(), i2.base());
      for (auto &i : iters(ret.v))
        iterator(i).parent(iterator{});
    }
    return ret;
  }
  iterator insert(const_iterator next, vector_type &&x) {
    const iterator p = next.to_mutable().parent();
    auto &vv = p->v;
    const iterator ret(vv.insert(next.base(), move(x.v)));
    for (auto &i : iters(ret, next.to_mutable()))
      i.parent(p);
    return ret;
  }
  vector_type exchange(const_iterator i1, const_iterator i2,
                       vector_type &&x) {
    const iterator p = i1.to_mutable().parent();
    auto &vv = p->v;
    vector_type ret(get_allocator());
    auto it = x.v.begin();
    ret.v = vv.exchange(i1.base(), i2.base(), move(x.v));
    for (; it != i2.base(); ++it)
      iterator(it).parent(p);
    for (auto &it2 : iters(ret))
      it2.parent(iterator{});
    return ret;
  }
  iterator replace(const_iterator i1, const_iterator i2, vector_type &&x) {
    const iterator p = i1.to_mutable().parent();
    auto &vv = p->v;
    auto it = vv.replace(i1.base(), i2.base(), move(x.v));
    for (auto &it2 : iters(it, i2.to_mutable().base()))
      iterator(it2).parent(p);
    return iterator(it);
  }

  vector_type extract_children(const_iterator i) noexcept {
    vector_type ret(get_allocator());
    vec_t &vv = i.to_mutable()->v;
    ret.v = move(vv);
    for (auto &it : iters(ret.v))
      iterator(it).parent(iterator{});
    return ret;
  }
  vector_type exchange_children(const_iterator i, vector_type &&x) {
    vector_type ret(get_allocator());
    vec_t &vv = i.to_mutable()->v;
    ret.v = move(vv);
    vv = move(x.v);
    for (auto &it : iters(vv))
      iterator(it).parent(i);
    for (auto &it : iters(ret.v))
      iterator(it).parent(iterator{});
    return ret;
  }
  iterator replace_children(const_iterator i, vector_type &&x) {
    vec_t &vv = i.to_mutable()->v;
    vv = move(x.v);
    for (auto &it : iters(vv))
      iterator(it).parent(i);
    return iterator(vv.begin());
  }

  void splice(const_iterator next, this_t &l, const_iterator i) {
    if (next != i)
      insert(next, l.extract(i));
  }
  void splice(const_iterator next, this_t &&l, const_iterator i) {
    splice(next, l, i);
  }
  void splice(const_iterator next,
              this_t &l, const_iterator from, const_iterator to) {
    if (from != to) {
      next.to_mutable().parent()->v
        .splice(next.base(),
                from.to_mutable().parent()->v, from.base(), to.base());
      const const_iterator p = next.parent();
      for (auto i = from; i != next; ++i)
        i.parent(p);
    }
  }
  void splice(const_iterator next,
              this_t &&l, const_iterator from, const_iterator to) {
    splice(next, l, from, to);
  }

  void splice(const_iterator next, vector_type &l, const_iterator i) {
    if (next != i)
      insert(next, l.extract(i));
  }
  void splice(const_iterator next, vector_type &&l, const_iterator i) {
    splice(next, l, i);
  }
  void splice(const_iterator next,
              vector_type &l, const_iterator from, const_iterator to) {
    if (from != to) {
      const auto p = next.to_mutable().parent();
      auto &vv = p->v;

      const auto pp = from.to_mutable().parent();
      auto &vvv = ((pp == nullptr) ? l.v : pp->v);

      vv.splice(next.base(), vvv, from.base(), to.base());
      for (auto &i : iters(from, next))
        i.parent(p);
    }
  }
  void splice(const_iterator next,
              vector_type &&l, const_iterator from, const_iterator to) {
    splice(next, l, from, to);
  }

  void splice(const_iterator next, vector_type &l) {
    if (!l.empty()) {
      const auto p = next.to_mutable().parent();
      auto &vv = p->v;
      const iterator it = l.begin();
      vv.splice(next.base(), l.v);
      for (auto &it2 : iters(it, next.to_mutable()))
        it2.parent(p);
    }
  }
  void splice(const_iterator next, vector_type &&l) {
    splice(next, l);
  }

  template <class...S>
  iterator emplace(const_iterator i, S &&...s) {
    const iterator p = i.parent().to_mutable();
    const iterator it(p->v.emplace(i.base(), alloc_ref(), forward<S>(s)...));
    it.parent(p);
    return it;
  }
  iterator insert(const_iterator i, const key_type &x) {
    return emplace(i, x);
  }
  iterator insert(const_iterator i, key_type &&x) {
    return emplace(i, move(x));
  }
  iterator insert(const_iterator i, size_type n, const key_type &x) {
    return insert_range(i, rng(n, ref(x)));
  }
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  iterator insert(const_iterator i, IITR from, IITR to) {
    return insert_range(i, rng(from, to));
  }
  iterator insert(const_iterator i, initializer_list<key_type> l) {
    return insert_range(i, l);
  }
  template <class R>
  iterator insert_range(const_iterator i, R &&r) {
    const iterator p(i.to_mutable().parent());
    const auto it = p->v.insert_range
      (i.base(), bind_rng(irng(r), [&](auto it) {
        return tuple<decltype(*it), typename vec_t::const_iterator,
                     node_alloc_t>(*it, p.base(), alloc_ref());
      }));
    return iterator(it);
  }
  template <class R>
  enable_if_t<!is_convertible_v<R &&, key_type &&>
              && !is_convertible_v<R &&, const key_type &>
              && !is_convertible_v<R &&, this_t &&>
              && !is_convertible_v<R &&, vector_type &&>
              && is_rng<R>
              && is_constructible_v<key_type, rng_ref<R>>,
              iterator>
  insert(const_iterator i, R &&r) {
    return insert_range(i, r);
  }

  iterator erase(const_iterator i) {
    if (i != iter)
      return iterator(i.to_mutable().parent()->v.erase(i.base()));
    else {
      delete_node(iter);
      return iter = iterator{};
    }
  }
  iterator erase(const_iterator i1, const_iterator i2) {
    return (i1 != i2)
      ? iterator(i1.to_mutable().parent()->v.erase(i1.base(), i2.base()))
      : i1.to_mutable();
  }
  void clear(const_iterator i) {
    i.to_mutable()->v.clear();
  }

  template <class...S>
  reference emplace_back(const_iterator ci, S &&...s) {
    const iterator p = ci.to_mutable();
    const iterator it = p->v.emplace_back(alloc_ref(), forward<S>(s)...)
      .iter();
    it.parent(p);
    return *it;
  }
  void push_back(const_iterator ci, const key_type &x) {
    emplace_back(ci, x);
  }
  void push_back(const_iterator ci, key_type &&x) {
    emplace_back(ci, move(x));
  }
  void push_back(const_iterator ci, this_t &&x) {
    if (!x.empty()) {
      const iterator p = ci.to_mutable();
      const iterator i(p->v.link_back(x.root().base()));
      x.release();
      i.parent(p);
    }
  }
  void push_back(const_iterator i, vector_type &&x) {
    if (!x.empty()) {
      vec_t &vv = i.to_mutable()->v;
      auto it = x.v.begin();
      vv.splice(vv.end(), x.v);
      for (auto &it2 : iters(it, vv.end()))
        it2.parent(i);
    }
  }
  template <class R>
  enable_if_t<!is_convertible_v<R &&, const key_type &>
              && !is_convertible_v<R &&, key_type &&>
              && !is_convertible_v<R &&, this_t &&>
              && !is_convertible_v<R &&, vector_type &&>>
  push_back(const_iterator ci, R &&r) {
    append_range(ci, r);
  }
  template <class R>
  void append_range(const_iterator ci, R &&r) {
    const iterator p = ci.to_mutable();
    p->v.append_range(bind_rng(irng(r), [&](auto it) {
      return tuple<decltype(*it), typename vec_t::const_iterator, node_alloc_t>
        (*it, ci.base(), alloc_ref());
    }));
  }
  void append(const_iterator ci) {}
  template <class X, class...S>
  void append(const_iterator ci, X &&x, S &&...s) {
    push_back(ci, forward<X>(x));
    append(ci, forward<S>(s)...);
  }
  void pop_back(const_iterator ci) {
    const iterator p = ci.to_mutable();
    p->v.pop_back();
  }
  void pop_back(const_iterator ci, size_type n) {
    const iterator p = ci.to_mutable();
    p->v.pop_back(n);
  }

  template <class...S>
  reference emplace_front(const_iterator ci, S &&...s) {
    const iterator p = ci.to_mutable();
    const iterator it = p->v.emplace_front(alloc_ref(), forward<S>(s)...)
      .iter();
    it.parent(p);
    return *it;
  }
  void push_front(const_iterator ci, const key_type &x) {
    emplace_front(ci, x);
  }
  void push_front(const_iterator ci, key_type &&x) {
    emplace_front(ci, move(x));
  }
  void push_front(const_iterator ci, this_t &&x) {
    if (!x.empty()) {
      const iterator p = ci.to_mutable();
      const iterator i(p->v.link_front(x.root().base()));
      x.release();
      i.parent(p);
    }
  }
  void push_front(const_iterator i, vector_type &&x) {
    if (!x.empty()) {
      vec_t &vv = i.to_mutable()->v;
      auto it = vv.begin();
      vv.splice(vv.begin(), x.v);
      for (auto &it2 : iters(vv.begin(), it))
        it2.parent(i);
    }
  }
  template <class R>
  enable_if_t<!is_convertible_v<R &&, const key_type &>
              && !is_convertible_v<R &&, key_type &&>
              && !is_convertible_v<R &&, this_t &&>
              && !is_convertible_v<R &&, vector_type &&>>
  push_front(const_iterator ci, R &&r) {
    prepend_range(ci, r);
  }
  template <class R>
  void prepend_range(const_iterator ci, R &&r) {
    const iterator p = ci.to_mutable();
    p->v.prepend_range(bind_rng(irng(r), [&](auto it) {
      return tuple<decltype(*it), typename vec_t::const_iterator, node_alloc_t>
        (*it, ci.base(), alloc_ref());
    }));
  }
  void prepend(const_iterator ci) {}
  template <class X, class...S>
  void prepend(const_iterator ci, X &&x, S &&...s) {
    prepend(ci, forward<S>(s)...);
    push_front(ci, forward<X>(x));
  }
  void pop_front(const_iterator ci) {
    const iterator p = ci.to_mutable();
    p->v.pop_front();
  }
  void pop_front(const_iterator ci, size_type n) {
    const iterator p = ci.to_mutable();
    p->v.pop_front(n);
  }

  size_type capacity(const_iterator i) const {
    return i.to_mutable()->v.capacity();
  }
  bool full(const_iterator i) const {
    return i.to_mutable()->v.full();
  }

  void reserve(const_iterator i, size_type n) {
    i.to_mutable()->v.reserve(n);
  }
  void first_order_reserve(const_iterator i, size_type n) {
    for (auto &x : i.to_mutable().first_order())
      x.v.reserve(n);
  }

  void reserve_more(const_iterator i, size_type n) {
    i.to_mutable()->v.reserve_more(n);
  }
  void first_order_reserve_more(const_iterator i, size_type n) {
    for (auto &x : i.to_mutable().first_order())
      x.v.reserve_more(n);
  }

  void resize(const_iterator i, size_type n) {
    const auto it = i.to_mutable();
    if (n <= it->size())
      erase(prev(it->end(), it->size() - n), it->end());
    else
      for (auto c = n - it->size(); c != 0;) {
        --c;
        emplace_back(it);
      }
  }
  void resize(const_iterator i, size_type n, const key_type &k) {
    const auto it = i.to_mutable();
    if (n <= it->size())
      erase(prev(it->end(), it->size() - n), it->end());
    else
      for (auto c = n - it->size(); c != 0;) {
        --c;
        emplace_back(it, k);
      }
  }
  void first_order_resize(const_iterator i, size_type n) {
    for (auto &x : i.to_mutable().first_order()) {
      if (x.size() != 0)
        resize(x.iter(), n);
    }
  }
  void first_order_resize(const_iterator i, size_type n,
                          const key_type &k) {
    for (auto &x : i.first_order()) {
      if (x.size() != 0)
        resize(x.iter(), n, k);
    }
  }

  void shrink_to_fit(const_iterator i) {
    i.to_mutable()->v.shrink_to_fit();
  }
  void first_order_shrink_to_fit(const_iterator i) {
    for (auto &x : i.first_order())
      shrink_to_fit(x.iter());
  }

  template <class UPRED>
  size_type remove_if(const_iterator p, UPRED eq) {
    return p.to_mutable()->v.remove_if([=](reference x) {return eq(x);});
  }
  template <class UPRED>
  void first_order_remove_if(const_iterator p, UPRED eq) {
    for (auto &x : p.first_order())
      remove_if(x.iter(), eq);
  }

  template <class BPRED>
  void unique(const_iterator c_parent, BPRED eq) {
    const iterator parent = c_parent.to_mutable();
    parent->v.unique([=](reference x, reference y) {return eq(x, y);});
  }
  template <class BPRED>
  void first_order_unique(const_iterator parent, BPRED eq) {
    for (auto &u : parent.first_order())
      unique(u.iter(), eq);
  }

  template <class BPRED>
  void merge(const_iterator i, this_t &l, const_iterator i2,
             BPRED less) {
    const iterator p1 = i.to_mutable();
    const iterator p2 = i2.to_mutable();
    vec_t &v1 = p1->v;
    vec_t &v2 = p2->v;
    for (auto &it : iters(v2))
      iterator(it).parent(p1);
#ifndef RE_NOEXCEPT
    try {
#endif
      v1.merge(v2, [=](reference x, reference y) {return less(x, y);});
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      for (auto &it : iters(v2))
        iterator(it).parent(p2);
      throw;
    }
#endif
  }
  template <class BPRED>
  void merge(const_iterator i, this_t &&l, const_iterator i2,
             BPRED less) {
    merge(i, l, i2, less);
  }

  template <class BPRED>
  void merge(const_iterator p, vector_type &l, const_iterator i,
             BPRED less) {
    const iterator p1 = p.to_mutable();
    const iterator p2 = i.to_mutable();
    vec_t &v1 = p1->v;
    vec_t &v2 = (p2 == nullptr ? l.v : p2->v);
    for (auto &it : iters(v2))
      iterator(it).parent(p1);
#ifndef RE_NOEXCEPT
    try {
#endif
      v1.merge(v2, [=](reference x, reference y) {return less(x, y);});
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      for (auto &it : iters(v2))
        iterator(it).parent(p2);
      throw;
    }
#endif
  }
  template <class BPRED>
  void merge(const_iterator p, vector_type &&l, const_iterator i,
             BPRED less) {
    merge(p, l, i, less);
  }

  template <class BPRED>
  void merge(const_iterator p, vector_type &l, BPRED less) {
    vec_t &vv = p.to_mutable()->v;
    for (auto &it : iters(l))
      it.parent(p);
#ifndef RE_NOEXCEPT
    try {
#endif
      vv.merge(l.v, [=](reference x, reference y) {return less(x, y);});
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      for (auto &it : iters(l))
        it.parent(iterator{});
      throw;
    }
#endif
  }
  template <class BPRED>
  void merge(const_iterator p, vector_type &&l, BPRED less) {
    merge(p, l, less);
  }

  template <class BPRED>
  void sort(const_iterator c_parent, BPRED less) {
    const iterator parent = c_parent.to_mutable();
    parent->v.sort([=](reference x, reference y) {return less(x, y);});
  }
  template <class BPRED>
  void first_order_sort(const_iterator parent, BPRED less) {
    for (auto &x : parent.to_mutable().first_order())
      sort(x.iter(), less);
  }

private:
  friend struct inner::fo_good;
  static bool good(const vec_t &) {
    return true;
  }
  static bool good(const vec_t &v)
    requires requires (const vec_t &vv) {inner::good(vv);} {
    return inner::good(v);
  }
  template <class FN>
  bool good_impl(const_iterator p, FN f) const {
    if (p == nullptr)
      return true;
    if (f(*p) == false)
      return false;
    const_iterator x = p->begin();
    const_iterator x_parent = p;
    for (;;) {
      while (x == x_parent->end()) {
        if (x_parent == p)
          return true;
        x = x_parent;
        x_parent = x_parent.parent();
        ++x;
      }
      if (!f(*x))
        return false;
      x_parent = x;
      x = x->begin();
    }
  }
  bool good() const {
    return iter == nullptr
      || (iter.parent() == nullptr
          && good_impl(root(), [&](const auto &x) {
            return allocator_type(x.v.get_allocator()) == get_allocator()
              && good(x.v)
              && const_iterator(x.v.end()).parent() == x.iter()
              && all_of(x.v, [&](auto &y) {
                return y.parent() == x.iter();
              });
          }));
  }
};
template <class X, class Y>
bool operator ==(const tree_adaptor<X> &x, const tree_adaptor<Y> &y)
  requires equality_comparable_with<typename X::key_type,
                                    typename Y::key_type> {
  if (x.root() == nullptr)
    return y == nullptr;
  else {
    if (y.root() == nullptr)
      return false;
    else
      return *x.root() == *y.root();
  }
}
template <class TRAITS>
bool operator ==(const tree_adaptor<TRAITS> &x, nullptr_t) {
  return x.root() == nullptr;
}

template <class TRAITS>
class tree_vector_adaptor {
  template <class>
  friend class tree_adaptor;
  template <class>
  friend class tree_vector_adaptor;

  using this_t = tree_vector_adaptor;

  using vec_t = typename TRAITS::vector_type;
  using vec_iter_t = typename vec_t::iterator;
  using vec_citer_t = typename vec_t::const_iterator;

  using node_t = typename TRAITS::node_type;
  using node_alloc_t = typename TRAITS::allocator_type;

  using public_node_t = typename TRAITS::public_node_type;
  using public_node_ptr = typename TRAITS::public_node_pointer;

  using key_t = typename TRAITS::key_type;
  using key_alloc_t = alloc_rebind<typename TRAITS::allocator_type, key_t>;
  using key_alw_t = allocator_wrapper<key_alloc_t>;

  vec_t v;

public:
  using tree_type = tree_adaptor<TRAITS>;
  using vector_type = this_t;

  using key_type = key_t;
  using value_type = public_node_t;
  using reference = value_type &;
  using const_reference = const value_type &;

  using iterator = inner::tree_iterator<typename vec_t::iterator>;
  using const_iterator = inner::tree_iterator<typename vec_t::const_iterator>;
  using difference_type = typename vec_t::difference_type;
  using size_type = typename vec_t::size_type;

  iterator begin() noexcept {
    return iterator(v.begin());
  }
  const_iterator begin() const noexcept {
    return const_iterator(v.begin());
  }
  iterator end() noexcept {
    return iterator(v.end());
  }
  const_iterator end() const noexcept {
    return const_iterator(v.end());
  }
  const_iterator cbegin() const noexcept {
    return const_iterator(v.cbegin());
  }
  const_iterator cend() const noexcept {
    return const_iterator(v.cend());
  }

  size_type max_size() const noexcept {
    return v.max_size();
  }
  size_type size() const noexcept {
    return v.size();
  }
  bool empty() const noexcept {
    return v.empty();
  }

  value_type &operator [](size_type n) requires is_ritr<iterator> {
    return v[n];
  }
  const value_type &operator [](size_type n)
    const requires is_ritr<iterator> {
    return v[n];
  }

  iterator nth(difference_type n) {
    return iterator(re::nth(v, n));
  }
  const_iterator nth(difference_type n) const {
    return const_iterator(re::nth(v, n));
  }

  using reverse_iterator = re::reverse_iterator<iterator>;
  using const_reverse_iterator = re::reverse_iterator<const_iterator>;

  reverse_iterator rbegin() noexcept {
    return reverse_iterator(end());
  }
  reverse_iterator rend() noexcept {
    return reverse_iterator(begin());
  }
  const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator(begin());
  }
  const_reverse_iterator crbegin() const noexcept {
    return rbegin();
  }
  const_reverse_iterator crend() const noexcept {
    return rend();
  }

private:
  template <class...S>
  iterator new_node(S &&...s) {
    const key_alloc_t ka(v.get_allocator());
    node_alloc_t na(v.get_allocator());
    return iterator(vec_iter_t(TRAITS::new_node(na, ka, forward<S>(s)...)));
  }
  void delete_node(const_iterator i) noexcept {
    node_alloc_t na(v.get_allocator());
    TRAITS::delete_node(na, i.node());
  }

  iterator link(const_iterator i, const_iterator x) {
    const iterator p = i.parent().to_mutable();
    ((p == nullptr) ? v : p->v).link(i.base(), x.base());
    x.parent(p);
    return x.to_mutable();
  }
  iterator link_front(const_iterator i, const_iterator x) {
    vec_t &vv = ((i == nullptr) ? v : i.to_mutable()->v);
    vv.link_front(x.base());
    x.parent(i);
    return x.to_mutable();
  }
  iterator link_back(const_iterator i, const_iterator x) {
    vec_t &vv = ((i == nullptr) ? v : i.to_mutable()->v);
    vv.link_back(x.base());
    x.parent(i);
    return x.to_mutable();
  }
  iterator unlink(const_iterator x) noexcept {
    const iterator p = x.parent().to_mutable();
    return iterator(((p == nullptr) ? v : p->v).unlink(x.base()));
  }
  iterator unlink(const_iterator i1, const_iterator i2) noexcept {
    const iterator p = i1.parent().to_mutable();
    return (i1 != i2)
      ? ((p == nullptr) ? v : p->v).unlink(i1.base(), i2.base())
      : i1.to_mutable();
  }
  iterator unlink_front(const_iterator i) noexcept {
    vec_t &vv = ((i == nullptr) ? v : i.to_mutable()->v);
    return iterator(vv.unlink_front(i.base()));
  }
  iterator unlink_back(const_iterator i) noexcept {
    vec_t &vv = ((i == nullptr) ? v : i.to_mutable()->v);
    return iterator(vv.unlink_back(i.base()));
  }
  void unlink() noexcept {
    v.unlink();
  }

  template <class IT>
  void reserve_cond(iterator target, IT p) {}
  template <class IT>
  void reserve_cond(iterator target, IT p)
    requires requires {target->v.reserve(0u);} {
    const auto n = re::size(*p);
    if (n > target->v.max_size())
      throw_or_terminate<length_error>
        ("re::tree_adaptor::reserve(x, p): size overflow\n");
    target->v.reserve(static_cast<decltype(target->v.size())>(n));
  }
  template <class VV>
  void reserve_cond(VV &vv) {}
  template <class VV>
  void reserve_cond(VV &vv) requires requires {vv.reserve(0u);} {
    v.reserve(vv.size());
  }
  void do_reserve(size_type) {}
  void do_reserve(size_type n) requires requires {v.reserve(0u);} {
    v.reserve(n);
  }
  template <class IT, class GET_KEY>
  iterator clone_node(IT p, GET_KEY get_key) {
    IT it = p;
    const iterator ret = new_node(get_key(*it));
    iterator x = ret;
#ifndef RE_NOEXCEPT
    try {
#endif
      for (;;) {
        if (it->empty()) {
          for (;;) {
            for (;;) {
              if (it == p)
                return ret;
              ++it;
              ++x;
              if (it == it.parent()->end()) {
                it = it.parent();
                x = x.parent();
              }
              else
                goto continue_label;
            }
          }
        }
        else {
          {
            const auto guard = exit_fn([x]() {
              for (auto &i : iters(x->v))
                iterator(i).parent(x);
            });
            reserve_cond(x, it);
            for (auto &u : *it)
              emplace_back(x, get_key(u));
          }
          it = it->begin();
          x = x->begin();
        }
      continue_label:
        ;
      }
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      delete_node(ret);
      throw;
    }
#endif
    return ret;
  }
  template <class IT>
  iterator clone_node(IT p) {
    return clone_node(p, deref);
  }

  template <class TREE_VEC_T>
  void append_data(const TREE_VEC_T &x) {
    reserve_cond(x.v);
    for (auto &it : iters(x)) {
      const auto n = clone_node(it, deref);
      auto guard = exit_fn([&]() {delete_node(n);}, true);
      link_back(const_iterator{}, n);
      guard.unset();
    }
  }
  template <class TREE_VEC_T>
  void append_data_from_rv(TREE_VEC_T &x) {
    reserve_cond(x.v);
    for (auto &it : iters(x)) {
      const auto n = clone_node(it, [](auto &u)->auto && {return move(*u);});
      auto guard = exit_fn([&]() {delete_node(n);}, true);
      link_back(const_iterator{}, n);
      guard.unset();
    }
  }

public:
  tree_vector_adaptor() noexcept(noexcept(vec_t{})) : v{} {}
  ~tree_vector_adaptor() = default;
  tree_vector_adaptor(const tree_vector_adaptor &x)
    : v(x.v.get_allocator()) {
    append_data(x);
  }
  tree_vector_adaptor &operator =(const tree_vector_adaptor &x) {
    if (this != addressof(x)) {
      const vec_t tmp(x.v.get_allocator());
      v = tmp;
      append_data(x);
    }
    return *this;
  }
  tree_vector_adaptor(tree_vector_adaptor &&x) noexcept : v(move(x.v)) {}
  tree_vector_adaptor &operator =(tree_vector_adaptor &&x)
    noexcept(alloc_move_prpg<key_alloc_t>
             || alloc_always_equal<key_alloc_t>) {
    if (!alloc_move_prpg<key_alloc_t>
        && v.get_allocator() != x.v.get_allocator()) {
      if (this != addressof(x)) {
        v = vec_t(x.v.get_allocator());
        append_data_from_rv(x);
        x.v.clear();
      }
    }
    else
      v = move(x.v);
    return *this;
  }
  friend void swap(this_t &x, this_t &y)
    noexcept(alloc_swap_prpg<key_alloc_t>
             || alloc_always_equal<key_alloc_t>) {
    if (!alloc_swap_prpg<key_alloc_t>
        && x.v.get_allocator() != y.v.get_allocator()) {
      this_t tmp(x.get_allocator());
      tmp.append_data_from_rv(y);
      y.clear();
      y.append_data_from_rv(x);
      adl_swap(x.v, tmp.v);
    }
    else
      adl_swap(x.v, y.v);
  }

  using allocator_type = key_alloc_t;
  allocator_type get_allocator() const noexcept {
    return v.get_allocator();
  }

  explicit tree_vector_adaptor(const allocator_type &a) noexcept : v(a) {}
  tree_vector_adaptor(const this_t &x, const allocator_type &a) : v(a) {
    append_data(x);
  }
  tree_vector_adaptor(this_t &&x, const allocator_type &a) : v(a) {
    if (a == x.get_allocator())
      v = move(x.v);
    else {
      append_data_from_rv(x);
      x.clear();
    }
  }

  template <class TRAITS2,
            class = enable_if_t
            <!is_same_v<TRAITS, TRAITS2>
             && is_constructible_v<key_type,
                                   const typename TRAITS2::key_type &>>>
  explicit tree_vector_adaptor(const tree_vector_adaptor<TRAITS2> &x,
                               const allocator_type &a = allocator_type{})
    : v(a) {
    append_data(x);
  }
  template <class TRAITS2>
  enable_if_t<!is_same_v<TRAITS, TRAITS2>
              && is_assignable_v<key_type &,
                                 const typename TRAITS2::key_type &>,
              this_t &>
  operator =(const tree_vector_adaptor<TRAITS2> &x) {
    clear();
    append_data(x);
    return *this;
  }

  template <class TRAITS2,
            class = enable_if_t
            <!is_same_v<TRAITS, TRAITS2>
             && is_constructible_v<key_type, typename TRAITS2::key_type &&>>>
  explicit tree_vector_adaptor(tree_vector_adaptor<TRAITS2> &&x,
                               const allocator_type &a = allocator_type{})
    : v(a) {
    append_data_from_rv(x);
    x.clear();
  }
  template <class TRAITS2>
  enable_if_t<!is_same_v<TRAITS, TRAITS2>
              && is_assignable_v<key_type &, typename TRAITS2::key_type &&>,
              this_t &>
  operator =(tree_vector_adaptor<TRAITS2> &&x) {
    clear();
    append_data_from_rv(x);
    x.clear();
    return *this;
  }

  explicit tree_vector_adaptor(size_type n,
                               const allocator_type &a = allocator_type{})
    : v(a) {
    for (auto c = n; c != 0; --c)
      emplace_back();
  }
  tree_vector_adaptor(size_type n, const key_type &k,
                      const allocator_type &a = allocator_type{})
    : v(a) {
    append_range(rng(n, k));
  }
  void assign(size_type n, const key_type &k) {
    assign_range(rng(n, k));
  }

  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  tree_vector_adaptor(IITR from, IITR to,
                      const allocator_type &a = allocator_type{})
    : v(a) {
    append_range(rng(from, to));
  }
  template <class IITR>
  enable_if_t<is_itr<IITR>> assign(IITR from, IITR to) {
    assign_range(rng(from, to));
  }

  tree_vector_adaptor(initializer_list<key_type> l,
                      const allocator_type &a = allocator_type{})
    : v(a) {
    append_range(l);
  }
  this_t &operator =(initializer_list<key_type> l) {
    assign_range(l);
    return *this;
  }
  void assign(initializer_list<key_type> l) {
    assign_range(l);
  }

  template <class R>
  explicit tree_vector_adaptor(R &&r,
                               const allocator_type &a = allocator_type{})
    requires (is_rng<R> && is_constructible_v<key_type, rng_ref<R>>)
    : v(a) {
    append_range(r);
  }
  template <class R>
  tree_vector_adaptor(from_range_t, R &&r,
                      const allocator_type &a = allocator_type{})
    requires (is_rng<R> && is_constructible_v<key_type, rng_ref<R>>)
    : v(a) {
    append_range(r);
  }
  template <class R>
  void assign(R &&r) {
    assign_range(r);
  }
  template <class R>
  void assign_range(R &&r) {
    auto rr = rng(r);
    iterator it = begin();
    for (;;) {
      if (re::empty(rr)) {
        erase(it, end());
        return;
      }
      if (it == end()) {
        append_range(rr);
        return;
      }
      clear(it);
      **it = *rr.first;
      ++it;
      ++rr.first;
    }
  }

private:
  void cat_impl() {}
  template <class...S>
  void cat_impl(tree_type &&x, S &&...s) {
    push_back(tree_type(move(x), get_allocator()));
    cat_impl(forward<S>(s)...);
  }
public:
  template <class...S>
  explicit tree_vector_adaptor(tree_type &&x, S &&...s)
    requires (is_convertible_v<S &&, tree_type &&> && ...) {
    cat_impl(move(x), forward<S>(s)...);
  }
  template <class...S>
  explicit tree_vector_adaptor(allocator_arg_t, const allocator_type &a,
                               tree_type &&x, S &&...s)
    requires (is_convertible_v<S &&, tree_type &&> && ...)
    : v(a) {
    cat_impl(move(x), forward<S>(s)...);
  }
  explicit tree_vector_adaptor(allocator_arg_t, const allocator_type &a)
    : v(a) {}

  template <class GET_KEY>
  tree_type copy(const_iterator p, GET_KEY get_key) {
    tree_type ret(get_allocator());
    ret.iter = clone_node(p, get_key);
    return ret;
  }
  template <class GET_KEY>
  tree_type copy(iterator p, GET_KEY get_key) {
    tree_type ret(get_allocator());
    ret.iter = clone_node(p, get_key);
    return ret;
  }
  tree_type copy(const_iterator p) {
    return copy(p, deref);
  }
  tree_type copy(iterator p) {
    return copy(p, deref);
  }
  template <class U, class IT, class GET_KEY>
  tree_type copy(U &u, IT i, GET_KEY get_key) {
    tree_type ret(get_allocator());
    ret.iter = clone_node(i, get_key);
    return ret;
  }

  void clear() noexcept {
    v.clear();
  }

  void swap(const_iterator i, const_iterator j) {
    const auto i_p = i.to_mutable().parent();
    const auto j_p = j.to_mutable().parent();
    (i_p == nullptr ? v : i_p->v)
      .swap(i.base(), (j_p == nullptr ? v : j_p->v), j.base());
    i.parent(j_p);
    j.parent(i_p);
  }
  void swap(const_iterator i, this_t &l, const_iterator j) {
    const auto i_p = i.to_mutable().parent();
    const auto j_p = j.to_mutable().parent();
    (i_p == nullptr ? v : i_p->v)
      .swap(i.base(), (j_p == nullptr ? l.v : j_p->v), j.base());
    i.parent(j_p);
    j.parent(i_p);
  }
  void swap(const_iterator i, this_t &&l, const_iterator j) {
    return swap(i, l, j);
  }
  void swap(const_iterator i, tree_type &l, const_iterator j) {
    if (j == l.iter) {
      const auto i_p = i.to_mutable().parent();
      const iterator x((i_p == nullptr ? v : i_p->v)
                       .exchange_node(i.base(), j.base()));
      l.iter = x;
      x.parent(iterator{});
      j.parent(i_p);
    }
    else {
      const auto i_p = i.to_mutable().parent();
      const auto j_p = j.to_mutable().parent();
      (i_p == nullptr ? v : i_p->v).swap(i.base(), j_p->v, j.base());
      i.parent(j_p);
      j.parent(i_p);
    }
  }
  void swap(const_iterator i, tree_type &&l, const_iterator j) {
    swap(i, l, j);
  }

  tree_type extract(const_iterator i) noexcept {
    tree_type ret(get_allocator());
    unlink(i);
    i.parent(const_iterator{});
    ret.iter = i.to_mutable();
    return ret;
  }
  iterator insert(const_iterator next, tree_type &&x) {
    if (!x.empty()) {
      const iterator p = next.to_mutable().parent();
      const iterator i((p == nullptr ? v : p->v)
                       .link(next.base(), x.iter.base()));
      i.parent(p);
      return x.release();
    }
    else
      return next.to_mutable();
  }
  tree_type exchange(const_iterator i, tree_type &&x) noexcept {
    tree_type ret(get_allocator());
    if (!x.empty()) {
      const auto i_p = i.to_mutable().parent();
      vec_t &vv = (i_p == nullptr ? v : i_p->v);
      ret.iter = iterator(vv.exchange_node(i.base(), x.iter.base()));
      ret.iter.parent(iterator{});
      x.iter.parent(i_p);
      x.iter = iterator{};
    }
    else {
      unlink(i);
      ret.iter = i.to_mutable();
      i.parent(iterator{});
    }
    return ret;
  }
  iterator replace(const_iterator i, tree_type &&x) noexcept {
    const auto i_p = i.to_mutable().parent();
    auto &vv = (i_p == nullptr ? v : i_p->v);
    if (!x.empty()) {
      vv.delete_node(vv.exchange_node(i.base(), x.iter.base()));
      x.iter.parent(i_p);
      return re::exchange(x.iter, iterator{});
    }
    else
      return iterator(vv.erase(i.base()));
  }

  this_t extract(const_iterator i1, const_iterator i2) {
    this_t ret(get_allocator());
    if (i1 != i2) {
      const iterator p = i1.to_mutable().parent();
      auto &vv = ((p == nullptr) ? v : p->v);
      ret.v.splice(ret.v.end(), vv, i1.base(), i2.base());
      for (auto &i : iters(ret.v))
        iterator(i).parent(iterator{});
    }
    return ret;
  }
  iterator insert(const_iterator next, this_t &&x) {
    const iterator p = next.to_mutable().parent();
    auto &vv = ((p == nullptr) ? v : p->v);
    const iterator ret(vv.insert(next.base(), move(x.v)));
    for (auto &i : iters(ret, next.to_mutable()))
      i.parent(p);
    return ret;
  }
  this_t exchange(const_iterator i1, const_iterator i2, this_t &&x) {
    const iterator p = i1.to_mutable().parent();
    auto &vv = ((p == nullptr) ? v : p->v);
    this_t ret(get_allocator());
    auto it = x.v.begin();
    ret.v = vv.exchange(i1.base(), i2.base(), move(x.v));
    for (; it != i2.base(); ++it)
      iterator(it).parent(p);
    for (auto &it2 : iters(ret))
      it2.parent(iterator{});
    return ret;
  }
  iterator replace(const_iterator i1, const_iterator i2, this_t &&x) {
    const iterator p = i1.to_mutable().parent();
    auto &vv = ((p == nullptr) ? v : p->v);
    auto it = vv.replace(i1.base(), i2.base(), move(x.v));
    for (auto &it2 : iters(it, i2.to_mutable().base()))
      iterator(it2).parent(p);
    return iterator(it);
  }

  this_t extract_children(const_iterator i) noexcept {
    this_t ret(get_allocator());
    vec_t &vv = ((i == nullptr) ? v : i.to_mutable()->v);
    ret.v = move(vv);
    for (auto &it : iters(ret.v))
      iterator(it).parent(iterator{});
    return ret;
  }
  this_t exchange_children(const_iterator i, this_t &&x) {
    this_t ret(get_allocator());
    vec_t &vv = ((i == nullptr) ? v : i.to_mutable()->v);
    ret.v = move(vv);
    vv = move(x.v);
    for (auto &it : iters(vv))
      iterator(it).parent(i);
    for (auto &it : iters(ret.v))
      iterator(it).parent(iterator{});
    return ret;
  }
  iterator replace_children(const_iterator i, this_t &&x) {
    vec_t &vv = ((i == nullptr) ? v : i.to_mutable()->v);
    vv = move(x.v);
    for (auto &it : iters(vv))
      iterator(it).parent(i);
    return iterator(vv.begin());
  }

  void splice(const_iterator next, tree_type &l, const_iterator i) {
    insert(next, l.extract(i));
  }
  void splice(const_iterator next, tree_type &&l, const_iterator i) {
    splice(next, l, i);
  }
  void splice(const_iterator next,
              tree_type &l, const_iterator from, const_iterator to) {
    if (from != to) {
      const auto p = next.to_mutable().parent();
      auto &vv = ((p == nullptr) ? v : p->v);
      vv.splice(next.base(),
                from.to_mutable().parent()->v, from.base(), to.base());
      for (auto &i : iters(from, next))
        i.parent(p);
    }
  }
  void splice(const_iterator next,
              tree_type &&l, const_iterator from, const_iterator to) {
    splice(next, l, from, to);
  }

  void splice(const_iterator next, this_t &l, const_iterator i) {
    if (next != i)
      insert(next, l.extract(i));
  }
  void splice(const_iterator next, this_t &&l, const_iterator i) {
    splice(next, l, i);
  }
  void splice(const_iterator next,
              this_t &l, const_iterator from, const_iterator to) {
    if (from != to) {
      const auto p = next.to_mutable().parent();
      auto &vv = ((p == nullptr) ? v : p->v);

      const auto pp = from.to_mutable().parent();
      auto &vvv = ((pp == nullptr) ? l.v : pp->v);

      vv.splice(next.base(), vvv, from.base(), to.base());
      for (auto &i : iters(from, next))
        i.parent(p);
    }
  }
  void splice(const_iterator next,
              this_t &&l, const_iterator from, const_iterator to) {
    splice(next, l, from, to);
  }

  void splice(const_iterator next, this_t &l) {
    if (!l.empty()) {
      const auto p = next.to_mutable().parent();
      auto &vv = ((p == nullptr) ? v : p->v);
      const iterator it = l.begin();
      vv.splice(next.base(), l.v);
      for (auto &it2 : iters(it, next.to_mutable()))
        it2.parent(p);
    }
  }
  void splice(const_iterator next, this_t &&l) {
    splice(next, l);
  }

  template <class...S>
  iterator emplace(const_iterator i, S &&...s) {
    const iterator p = i.parent().to_mutable();
    vec_t &vv = ((p == nullptr) ? v : p->v);
    const iterator it(vv.emplace(i.base(), get_allocator(), forward<S>(s)...));
    it.parent(p);
    return it;
  }
  iterator insert(const_iterator i, const key_type &x) {
    return emplace(i, x);
  }
  iterator insert(const_iterator i, key_type &&x) {
    return emplace(i, move(x));
  }
  iterator insert(const_iterator i, size_type n, const key_type &x) {
    return insert_range(i, rng(n, ref(x)));
  }
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  iterator insert(const_iterator i, IITR from, IITR to) {
    return insert_range(i, rng(from, to));
  }
  iterator insert(const_iterator i, initializer_list<key_type> l) {
    return insert_range(i, l);
  }
  template <class R>
  iterator insert_range(const_iterator i, R &&r) {
    const iterator p = i.to_mutable().parent();
    vec_t &vv = ((p == nullptr) ? v : p->v);
    const auto it = vv.insert_range
      (i.base(), bind_rng(irng(r), [=, this](auto it) {
        return tuple<decltype(*it), typename vec_t::const_iterator,
                     node_alloc_t>(*it, p.base(), get_allocator());
      }));
    return iterator(it);
  }
  template <class R>
  enable_if_t<!is_convertible_v<R &&, key_type &&>
              && !is_convertible_v<R &&, const key_type &>
              && !is_convertible_v<R &&, this_t &&>
              && !is_convertible_v<R &&, vector_type &&>,
              iterator>
  insert(const_iterator i, R &&r) {
    return insert_range(i, r);
  }

  iterator erase(const_iterator i) {
    const iterator p = i.to_mutable().parent();
    vec_t &vv = ((p == nullptr) ? v : p->v);
    return iterator(vv.erase(i.base()));
  }
  iterator erase(const_iterator i1, const_iterator i2) {
    if (i1 != i2) {
      const iterator p = i1.to_mutable().parent();
      vec_t &vv = ((p == nullptr) ? v : p->v);
      return iterator(vv.erase(i1.base(), i2.base()));
    }
    else
      return i1.to_mutable();
  }
  void clear(const_iterator i) {
    ((i == nullptr) ? v : i.to_mutable()->v).clear();
  }

  template <class...S>
  reference emplace_back(S &&...s)
    requires (sizeof...(s) == 0u
              || (!is_convertible_v<nth_type_t<0, S &&...>, const_iterator>
                  && !is_convertible_v<nth_type_t<0, S &&...>, iterator>)) {
    return v.emplace_back(get_allocator(), forward<S>(s)...);
  }
  void push_back(const key_type &x) {
    emplace_back(x);
  }
  void push_back(key_type &&x) {
    emplace_back(move(x));
  }
  void push_back(tree_type &&x) {
    if (!x.empty()) {
      iterator(v.link_back(x.root().base())).parent(iterator{});
      x.release();
    }
  }
  void push_back(this_t &&x) {
    if (!x.empty()) {
      auto it = x.v.begin();
      v.splice(v.end(), x.v);
      for (auto &it2 : iters(it, v.end()))
        iterator(it2).parent(iterator{});
    }
  }
  template <class R>
  enable_if_t<!is_convertible_v<R &&, const key_type &>
              && !is_convertible_v<R &&, key_type &&>
              && !is_convertible_v<R &&, tree_type &&>
              && !is_convertible_v<R &&, this_t &&>>
  push_back(R &&r) {
    append_range(r);
  }
  template <class R>
  void append_range(R &&r) {
    v.append_range(bind_rng(irng(r), [this](auto it) {
      return tuple<decltype(*it), typename vec_t::const_iterator, node_alloc_t>
        (*it, iterator{}.base(), get_allocator());
    }));
  }
  this_t &append() {
    return *this;
  }
  template <class X, class...S>
  this_t &append(X &&x, S &&...s)
    requires (!is_convertible_v<X &&, iterator>
              && !is_convertible_v<X &&, const_iterator>) {
    push_back(forward<X>(x));
    append(forward<S>(s)...);
    return *this;
  }
  void pop_back() {
    v.pop_back();
  }
  void pop_back(size_type n) {
    v.pop_back(n);
  }

  template <class...S>
  reference emplace_back(const_iterator i, S &&...s) {
    vec_t &vv = ((i == nullptr) ? v : i.to_mutable()->v);
    auto &x = vv.emplace_back(get_allocator(), forward<S>(s)...);
    x.parent(i);
    return x;
  }
  void push_back(const_iterator i, const key_type &x) {
    emplace_back(i, x);
  }
  void push_back(const_iterator i, key_type &&x) {
    emplace_back(i, move(x));
  }
  void push_back(const_iterator i, tree_type &&x) {
    if (!x.empty()) {
      vec_t &vv = ((i == nullptr) ? v : i.to_mutable()->v);
      iterator(vv.link_back(x.root().base())).parent(i);
      x.release();
    }
  }
  void push_back(const_iterator i, this_t &&x) {
    if (!x.empty()) {
      vec_t &vv = ((i == nullptr) ? v : i.to_mutable()->v);
      auto it = x.v.begin();
      vv.splice(vv.end(), x.v);
      for (auto &it2 : iters(it, vv.end()))
        iterator(it2).parent(i);
    }
  }
  template <class R>
  enable_if_t<!is_convertible_v<R &&, const key_type &>
              && !is_convertible_v<R &&, key_type &&>
              && !is_convertible_v<R &&, tree_type &&>
              && !is_convertible_v<R &&, this_t &&>>
  push_back(const_iterator i, R &&r) {
    append_range(i, r);
  }
  template <class R>
  void append_range(const_iterator i, R &&r) {
    const iterator p = i.to_mutable();
    vec_t &vv = ((i == nullptr) ? v : i.to_mutable()->v);
    vv.append_range(bind_rng(irng(r), [i, this](auto it) {
      return tuple<decltype(*it), typename vec_t::const_iterator, node_alloc_t>
        (*it, i.base(), get_allocator());
    }));
  }
  void append(const_iterator i) {}
  template <class X, class...S>
  void append(const_iterator i, X &&x, S &&...s) {
    push_back(i, forward<X>(x));
    append(i, forward<S>(s)...);
  }
  void pop_back(const_iterator i) {
    vec_t &vv = ((i == nullptr) ? v : i.to_mutable()->v);
    vv.pop_back();
  }
  void pop_back(const_iterator i, size_type n) {
    vec_t &vv = ((i == nullptr) ? v : i.to_mutable()->v);
    vv.pop_back(n);
  }

  template <class...S>
  reference emplace_front(S &&...s)
    requires (sizeof...(s) > 0u
              && !is_convertible_v<nth_type_t<0, S &&...>, const_iterator>
              && !is_convertible_v<nth_type_t<0, S &&...>, iterator>) {
    return v.emplace_front(get_allocator(), forward<S>(s)...);
  }
  void push_front(const key_type &x) {
    emplace_front(x);
  }
  void push_front(key_type &&x) {
    emplace_front(move(x));
  }
  void push_front(tree_type &&x) {
    if (!x.empty()) {
      iterator(v.link_front(x.root().base())).parent(iterator{});
      x.release();
    }
  }
  void push_front(this_t &&x) {
    if (!x.empty()) {
      auto it = v.begin();
      v.splice(v.begin(), x.v);
      for (auto &it2 : iters(v.begin(), it))
        iterator(it2).parent(iterator{});
    }
  }
  template <class R>
  enable_if_t<!is_convertible_v<R &&, const key_type &>
              && !is_convertible_v<R &&, key_type &&>
              && !is_convertible_v<R &&, tree_type &&>
              && !is_convertible_v<R &&, this_t &&>>
  push_front(R &&r) {
    prepend_range(r);
  }
  template <class R>
  void prepend_range(R &&r) {
    v.prepend_range(bind_rng(irng(r), [this](auto it) {
      return tuple<decltype(*it), typename vec_t::const_iterator, node_alloc_t>
        (*it, iterator{}.base(), get_allocator());
    }));
  }
  this_t &prepend() {
    return *this;
  }
  template <class X, class...S>
  this_t &prepend(X &&x, S &&...s)
    requires (!is_convertible_v<X &&, iterator>
              && !is_convertible_v<X &&, const_iterator>) {
    prepend(forward<S>(s)...);
    push_front(forward<X>(x));
    return *this;
  }
  void pop_front() {
    v.pop_front();
  }
  void pop_front(size_type n) {
    v.pop_front(n);
  }

  template <class...S>
  reference emplace_front(const_iterator i, S &&...s) {
    vec_t &vv = ((i == nullptr) ? v : i.to_mutable()->v);
    auto &x = vv.emplace_front(get_allocator(), forward<S>(s)...);
    x.parent(i);
    return x;
  }
  void push_front(const_iterator i, const key_type &x) {
    emplace_front(i, x);
  }
  void push_front(const_iterator i, key_type &&x) {
    emplace_front(i, move(x));
  }
  void push_front(const_iterator i, tree_type &&x) {
    if (!x.empty()) {
      vec_t &vv = ((i == nullptr) ? v : i.to_mutable()->v);
      iterator(vv.link_front(x.root().base())).parent(i);
      x.release();
    }
  }
  void push_front(const_iterator i, this_t &&x) {
    if (!x.empty()) {
      vec_t &vv = ((i == nullptr) ? v : i.to_mutable()->v);
      auto it = vv.begin();
      vv.splice(vv.begin(), x.v);
      for (auto &it2 : iters(vv.begin(), it))
        iterator(it2).parent(i);
    }
  }  
  template <class R>
  enable_if_t<!is_convertible_v<R &&, const key_type &>
              && !is_convertible_v<R &&, key_type &&>
              && !is_convertible_v<R &&, tree_type &&>
              && !is_convertible_v<R &&, this_t &&>>
  push_front(const_iterator i, R &&r) {
    prepend_range(i, r);
  }
  template <class R>
  void prepend_range(const_iterator i, R &&r) {
    const iterator p = i.to_mutable();
    vec_t &vv = ((i == nullptr) ? v : i.to_mutable()->v);
    vv.prepend_range(bind_rng(irng(r), [i, this](auto it) {
      return tuple<decltype(*it), typename vec_t::const_iterator, node_alloc_t>
        (*it, i.base(), get_allocator());
    }));
  }
  void prepend(const_iterator i) {}
  template <class X, class...S>
  void prepend(const_iterator i, X &&x, S &&...s) {
    prepend(i, forward<S>(s)...);
    push_front(i, forward<X>(x));
  }
  void pop_front(const_iterator i) {
    vec_t &vv = ((i == nullptr) ? v : i.to_mutable()->v);
    vv.pop_front();
  }
  void pop_front(const_iterator i, size_type n) {
    vec_t &vv = ((i == nullptr) ? v : i.to_mutable()->v);
    vv.pop_front(n);
  }

  size_type capacity() const {
    return v.capacity();
  }
  size_type capacity(const_iterator i) const {
    const vec_t &vv = ((i == nullptr) ? v : i->v);
    return vv.capacity();
  }
  bool full() const {
    return v.full();
  }
  bool full(const_iterator i) const {
    const vec_t &vv = ((i == nullptr) ? v : i->v);
    return vv.full();
  }

  void reserve(size_type n) {
    v.reserve(n);
  }
  void reserve(const_iterator i, size_type n) {
    vec_t &vv = ((i == nullptr) ? v : i.to_mutable()->v);
    vv.reserve(n);
  }
  void first_order_reserve(size_type n) {
    first_order_reserve(const_iterator{}, n);
  }
  void first_order_reserve(const_iterator i, size_type n) {
    vec_t &vv = ((i == nullptr) ? v : i.to_mutable()->v);
    vv.reserve(n);
    for (auto &it : iters(vv))
      for (auto &x : iterator(it).first_order())
        x.v.reserve(n);
  }

  void reserve_more(size_type n) {
    v.reserve_more(n);
  }
  void reserve_more(const_iterator i, size_type n) {
    vec_t &vv = ((i == nullptr) ? v : i.to_mutable()->v);
    vv.reserve_more(n);
  }
  void first_order_reserve_more(size_type n) {
    first_order_reserve_more(const_iterator{}, n);
  }
  void first_order_reserve_more(const_iterator i, size_type n) {
    vec_t &vv = ((i == nullptr) ? v : i.to_mutable()->v);
    vv.reserve_more(n);
    for (auto &it : iters(vv))
      for (auto &x : iterator(it).first_order())
        x.v.reserve_more(n);
  }

  void resize(size_type n) {
    resize(const_iterator{}, n);
  }
  void resize(size_type n, const key_type &k) {
    resize(const_iterator{}, n, k);
  }
  void resize(const_iterator i, size_type n) {
    vec_t &vv = ((i == nullptr) ? v : i.to_mutable()->v);
    if (n <= vv.size())
      vv.erase(prev(vv.end(), vv.size() - n), vv.end());
    else
      for (auto c = n - vv.size(); c != 0;) {
        --c;
        emplace_back(i);
      }
  }
  void resize(const_iterator i, size_type n, const key_type &k) {
    vec_t &vv = ((i == nullptr) ? v : i.to_mutable()->v);
    if (n <= vv.size())
      vv.erase(prev(vv.end(), vv.size() - n), vv.end());
    else
      for (auto c = n - vv.size(); c != 0;) {
        --c;
        emplace_back(i, k);
      }
  }
  void first_order_resize(size_type n) {
    first_order_resize(const_iterator{}, n);
  }
  void first_order_resize(size_type n, const key_type &k) {
    first_order_resize(const_iterator{}, n, k);
  }
  void first_order_resize(const_iterator i, size_type n) {
    resize(i, n);
    vec_t &vv = ((i == nullptr) ? v : i.to_mutable()->v);
    for (auto &it : iters(vv))
      for (auto &x : iterator(it).first_order()) {
        if (x.size() != 0)
          resize(x.iter(), n);
      }
  }
  void first_order_resize(const_iterator i, size_type n,
                          const key_type &k) {
    resize(i, n, k);
    vec_t &&vv = ((i == nullptr) ? v : i.to_mutable()->v);
    for (auto &it : iters(vv))
      for (auto &x : it.first_order())
        resize(x.iter(), n, k);
  }

  void shrink_to_fit() {
    v.shrink_to_fit();
  }
  void shrink_to_fit(const_iterator i) {
    vec_t &vv = ((i == nullptr) ? v : i.to_mutable()->v);
    vv.shrink_to_fit();
  }
  void first_order_shrink_to_fit() {
    first_order_shrink_to_fit(const_iterator{});
  }
  void first_order_shrink_to_fit(const_iterator i) {
    shrink_to_fit(i);
    vec_t &vv = ((i == nullptr) ? v : i.to_mutable()->v);
    for (auto &it : iters(vv))
      for (auto &x : iterator(it).first_order())
        shrink_to_fit(x.iter());
  }

  template <class UPRED>
  size_type remove_if(UPRED eq) {
    return v.remove_if([=](reference x) {return eq(x);});
  }
  template <class UPRED>
  size_type remove_if(const_iterator i, UPRED eq) {
    vec_t &vv = ((i == nullptr) ? v : i.to_mutable()->v);
    return vv.remove_if([=](reference x) {return eq(x);});
  }
  template <class UPRED>
  void first_order_remove_if(UPRED eq) {
    first_order_remove_if(const_iterator{}, eq);
  }
  template <class UPRED>
  void first_order_remove_if(const_iterator i, UPRED eq) {
    remove_if(i, eq);
    vec_t &vv = ((i == nullptr) ? v : i.to_mutable()->v);
    for (auto &it : iters(vv))
      for (auto &x : iterator(it).first_order())
        remove_if(x.iter(), eq);
  }

  template <class BPRED>
  void unique(BPRED eq) {
    v.unique([=](reference x, reference y) {return eq(x, y);});
  }
  template <class BPRED>
  void unique(const_iterator i, BPRED eq) {
    vec_t &vv = ((i == nullptr) ? v : i.to_mutable()->v);
    vv.unique([=](reference x, reference y) {return eq(x, y);});
  }
  template <class BPRED>
  void first_order_unique(BPRED eq) {
    first_order_unique(const_iterator{}, eq);
  }
  template <class BPRED>
  void first_order_unique(const_iterator i, BPRED eq) {
    unique(i, eq);
    vec_t &vv = ((i == nullptr) ? v : i.to_mutable()->v);
    for (auto &it : iters(vv))
      for (auto &x : iterator(it).first_order())
        unique(x.iter(), eq);
  }

  template <class BPRED>
  void merge(const_iterator i, tree_type &l, const_iterator i2,
             BPRED less) {
    const iterator p1 = i.to_mutable();
    const iterator p2 = i2.to_mutable();
    vec_t &v1 = ((p1 == nullptr) ? v : p1->v);
    vec_t &v2 = p2->v;
    for (auto &it : iters(v2))
      iterator(it).parent(p1);
#ifndef RE_NOEXCEPT
    try {
#endif
      v1.merge(v2, [=](reference x, reference y) {return less(x, y);});
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      for (auto &it : iters(v2))
        iterator(it).parent(p2);
      throw;
    }
#endif
  }
  template <class BPRED>
  void merge(const_iterator i, tree_type &&l, const_iterator i2,
             BPRED less) {
    merge(i, l, i2, less);
  }
  template <class BPRED>
  void merge(tree_type &l, const_iterator i2, BPRED less) {
    merge(const_iterator{}, l, i2, less);
  }
  template <class BPRED>
  void merge(tree_type &&l, const_iterator i2, BPRED less) {
    merge(l, i2, less);
  }

  template <class BPRED>
  void merge(const_iterator i, this_t &l, const_iterator i2, BPRED less) {
    const iterator p1 = i.to_mutable();
    const iterator p2 = i2.to_mutable();
    vec_t &v1 = ((p1 == nullptr) ? v : p1->v);
    vec_t &v2 = ((p2 == nullptr) ? l.v : p2->v);
    for (auto &it : iters(v2))
      iterator(it).parent(p1);
#ifndef RE_NOEXCEPT
    try {
#endif
      v1.merge(v2, [=](reference x, reference y) {return less(x, y);});
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      for (auto &it : iters(v2))
        iterator(it).parent(p2);
      throw;
    }
#endif
  }
  template <class BPRED>
  void merge(const_iterator i, this_t &&l, const_iterator i2, BPRED less) {
    merge(i, l, i2, less);
  }
  template <class BPRED>
  void merge(this_t &l, const_iterator i2, BPRED less) {
    merge(const_iterator{}, l, i2, less);
  }
  template <class BPRED>
  void merge(this_t &&l, const_iterator i2, BPRED less) {
    merge(l, i2, less);
  }

  template <class BPRED>
  void merge(const_iterator p, vector_type &l, BPRED less) {
    vec_t &vv = ((p == nullptr) ? v : p.to_mutable()->v);
    for (auto &it : iters(l))
      it.parent(p);
#ifndef RE_NOEXCEPT
    try {
#endif
      vv.merge(l.v, [=](reference x, reference y) {return less(x, y);});
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      for (auto &it : iters(l))
        it.parent(iterator{});
      throw;
    }
#endif
  }
  template <class BPRED>
  void merge(const_iterator p, vector_type &&l, BPRED less) {
    merge(p, l, less);
  }
  template <class BPRED>
  void merge(vector_type &l, BPRED less) {
    merge(const_iterator{}, l, less);
  }
  template <class BPRED>
  void merge(vector_type &&l, BPRED less) {
    merge(l, less);
  }

  template <class BPRED>
  void sort(BPRED less) {
    v.sort([=](reference x, reference y) {return less(x, y);});
  }
  template <class BPRED>
  void sort(const_iterator i, BPRED less) {
    vec_t &vv = ((i == nullptr) ? v : i.to_mutable()->v);
    vv.sort([=](reference x, reference y) {return less(x, y);});
  }
  template <class BPRED>
  void first_order_sort(const_iterator i, BPRED less) {
    sort(i, less);
    vec_t &vv = ((i == nullptr) ? v : i.to_mutable()->v);
    for (auto &it : iters(vv))
      for (auto &x : iterator(it).first_order())
        sort(x.iter(), less);
  }
  template <class BPRED>
  void first_order_sort(BPRED less) {
    first_order_sort(const_iterator{}, less);
  }

private:
  friend struct inner::fo_good;
  static bool good(const vec_t &) {
    return true;
  }
  static bool good(const vec_t &v)
    requires requires (const vec_t &vv) {inner::good(vv);} {
    return inner::good(v);
  }
  bool good() const {
    if (!good(v))
      return false;
    if (const_iterator(v.end()).parent() != nullptr)
      return false;
    for (auto &i : iters(v)) {
      const iterator it(i.to_mutable());
      if (it.parent() != nullptr)
        return false;
      for (auto &x : it.first_order()) {
        if (!good(x.v))
          return false;
        if (x.v.get_allocator() != get_allocator())
          return false;
        if (const_iterator(x.v.end()).parent() != x.iter())
          return false;
        if (any_of(x.v, [&x](auto &y) {return y.parent() != x.iter();}))
          return false;
      }
    }
    return true;
  }
};
template <class X, class Y>
bool operator ==(const tree_vector_adaptor<X> &x,
                 const tree_vector_adaptor<Y> &y)
  requires equality_comparable_with<typename X::key_type,
                                    typename Y::key_type> {
  return equal(x, y);
}

template <class T, class AL = default_allocator<T>>
using tree = tree_adaptor<inner::gtt<T, AL>>;
template <class T, class AL = default_allocator<T>>
using tree_vector = tree_vector_adaptor<inner::gtt<T, AL>>;

template <class T, size_t N, class AL = default_allocator<T>>
using limited_tree = tree_adaptor<inner::gtt<T, AL, N>>;
template <class T, size_t N, class AL = default_allocator<T>>
using limited_tree_vector = tree_vector_adaptor<inner::gtt<T, AL, N>>;

template <class T, class AL = default_allocator<T>>
using linked_tree = tree_adaptor<inner::ltt<T, AL>>;
template <class T, class AL = default_allocator<T>>
using linked_tree_vector = tree_vector_adaptor<inner::ltt<T, AL>>;

template <class T, class AL = default_allocator<T>>
using logn_tree = tree_adaptor<inner::lgtt<T, AL>>;
template <class T, class AL = default_allocator<T>>
using logn_tree_vector = tree_vector_adaptor<inner::lgtt<T, AL>>;

}

// matrix
namespace re {

template <class T, class C = vector<T>>
class matrix;

namespace inner {

template <class T>
struct is_matrix_impl : false_type {};
template <class T, class C>
struct is_matrix_impl<matrix<T, C>> : true_type {};
template <class T, class C>
struct is_matrix_impl<const matrix<T, C>> : true_type {};
template <class T, class C>
struct is_matrix_impl<volatile matrix<T, C>> : true_type {};
template <class T, class C>
struct is_matrix_impl<const volatile matrix<T, C>> : true_type {};

}
template <class T>
concept is_matrix = inner::is_matrix_impl<T>::value;

template <class T, class C>
class matrix : public conditional_allocator_type<C> {
  template <class, class>
  friend class matrix;

  C c;
  size_t w = 0;
  size_t h = 0;

  using base_t = C;
  base_t &base() noexcept {
    return c;
  }
  const base_t &base() const noexcept {
    return c;
  }
  static default_allocator<T> alloc_val() noexcept {
    return default_allocator<T>{};
  }
  static auto alloc_val() noexcept requires has_allocator_type<base_t> {
    return typename base_t::allocator_type{};
  }
  using alloc_t = decltype(alloc_val());

  matrix(C &&cc, size_t ww, size_t hh) : c(move(cc)), w(ww), h(hh) {}

public:
  using value_type = typename C::value_type;
  using reference = typename C::reference;
  using const_reference = typename C::const_reference;
  using iterator = typename C::iterator;
  using const_iterator = typename C::const_iterator;
  using difference_type = typename C::difference_type;
  using size_type = typename C::size_type;

  iterator begin() noexcept {
    return c.begin();
  }
  iterator end() noexcept {
    return c.end();
  }
  const_iterator begin() const noexcept {
    return c.begin();
  }
  const_iterator end() const noexcept {
    return c.end();
  }
  const_iterator cbegin() const noexcept {
    return c.begin();
  }
  const_iterator cend() const noexcept {
    return c.end();
  }

  size_type max_size() const noexcept {
    return c.max_size();
  }
  size_type size() const noexcept {
    return c.size();
  }
  bool empty() const noexcept {
    return c.empty();
  }

  size_type width() const noexcept {
    return w;
  }
  size_type height() const noexcept {
    return h;
  }

  using reverse_iterator = typename C::reverse_iterator;
  using const_reverse_iterator = typename C::const_reverse_iterator;
  reverse_iterator rbegin() noexcept {
    return c.rbegin();
  }
  reverse_iterator rend() noexcept {
    return c.rend();
  }
  const_reverse_iterator rbegin() const noexcept {
    return c.rbegin();
  }
  const_reverse_iterator rend() const noexcept {
    return c.rend();
  }
  const_reverse_iterator crbegin() const noexcept {
    return c.rbegin();
  }
  const_reverse_iterator crend() const noexcept {
    return c.rend();
  }

  matrix() = default;
  ~matrix() = default;
  matrix(const matrix &) = default;
  matrix &operator =(const matrix &x) {
#ifndef RE_NOEXCEPT
    try {
#endif
      c = x.c;
      w = x.w;
      h = x.h;
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      clear();
      throw;
    }
#endif
    return *this;
  }
  matrix(matrix &&x) noexcept : c(move(x.c)), w(x.w), h(x.h) {
    x.clear();
  }
  matrix(matrix &&x) requires (!is_nothrow_move_constructible_v<base_t>)
#ifndef RE_NOEXCEPT
    try : c(move(x.c)), w(x.w), h(x.h) {
      x.clear();
    }
    catch (...) {
      x.clear();
      throw;
    }
#else
    : c(move(x.c)), w(x.w), h(x.h) {
    x.clear();
  }
#endif
  matrix &operator =(matrix &&x) noexcept {
    c = move(x.c);
    w = x.w;
    h = x.h;
    x.clear();
    return *this;
  }
  matrix &operator =(matrix &&x)
    requires (!is_nothrow_move_assignable_v<base_t>) {
#ifndef RE_NOEXCEPT
    try {
#endif
      c = move(x.c);
      w = x.w;
      h = x.h;
      x.clear();
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      clear();
      x.clear();
      throw;
    }
#endif
    return *this;
  }
  void swap(matrix &x, matrix &y) noexcept(is_nothrow_swappable_v<base_t>)
    requires is_swappable_v<base_t> {
#ifndef RE_NOEXCEPT
    try {
#endif
      adl_swap(x.c, y.c);
      adl_swap(x.w, y.w);
      adl_swap(x.h, y.h);
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      x.clear();
      y.clear();
    }
#endif
  }

  bool operator ==(const matrix &m) const {
    return w == m.w && h == m.h && c == m.c;
  }

  auto get_allocator() const noexcept
    requires has_allocator_type<base_t> {
    return base().get_allocator();
  }

  explicit matrix(const alloc_t &a) requires has_allocator_type<base_t>
    : c(a) {}
  matrix(const matrix &x, const alloc_t &a)
    requires has_allocator_type<base_t> : c(x.c, a), w(x.w), h(x.h) {}
  matrix(matrix &&x, const alloc_t &a)
    requires has_allocator_type<base_t>
#ifndef RE_NOEXCEPT
    try : c(move(x.c), a), w(x.w), h(x.h) {
      x.clear();
    }
    catch (...) {
      x.clear();
      throw;
    }
#else
    : c(move(x.c), a), w(x.w), h(x.h) {
    x.clear();
  }
#endif

private:
  static bool check_wh(size_type ww, size_type hh) noexcept {
    if (hh == 0u)
      return true;
    return numeric_limits<size_type>::max() / hh >= ww;
  }
public:
  matrix(size_type ww, size_type hh) : c(ww * hh), w(ww), h(hh) {
    if (!check_wh(ww, hh))
      throw_or_terminate<length_error>
        ("re::matrix::matrix(w, h): size error\n");
  }
  matrix(size_type ww, size_type hh, const alloc_t &a)
    requires has_allocator_type<base_t> : c(ww * hh, a), w(ww), h(hh) {
    if (!check_wh(ww, hh))
      throw_or_terminate<length_error>
        ("re::matrix::matrix(w, h, a): size error\n");
  }

  matrix(size_type ww, size_type hh, const value_type &v)
    : c(ww * hh, v), w(ww), h(hh) {
    if (!check_wh(ww, hh))
      throw_or_terminate<length_error>
        ("re::matrix::matrix(w, h, v): size error\n");
  }
  matrix(size_type ww, size_type hh, const value_type &v, const alloc_t &a)
    requires has_allocator_type<base_t> : c(ww * hh, v, a), w(ww), h(hh) {
    if (!check_wh(ww, hh))
      throw_or_terminate<length_error>
        ("re::matrix::matrix(w, h, v, a): size error\n");
  }

private:
  template <class R>
  void assign_range(R &&r) {
    if constexpr (rng_is_sized<R>) {
      const auto sz = w * h;
      const auto r_sz = re::size(r);
      if (sz <= r_sz)
        copy_from(c, re::begin(r));
      else
        copy(r, c.begin());
    }
    else {
      auto r_it = re::begin(r);
      const auto r_ed = re::end(r);
      for (auto &it : c) {
        if (r_it == r_ed)
          break;
        *it = *r_it;
        ++r_it;
      }
    }
  }
public:
  template <class R>
  matrix(size_type ww, size_type hh, R &&r)
    requires (!is_matrix<remove_reference_t<R>>
              && is_rng<R> && is_constructible_v<value_type, rng_ref<R>>
              && !is_convertible_v<R &&, const value_type &>)
    : c(ww * hh), w(ww), h(hh) {
    assign_range(r);
  }
  template <class R>
  matrix(size_type ww, size_type hh, R &&r, const alloc_t &a)
    requires (has_allocator_type<base_t>
              && !is_matrix<remove_reference_t<R>>
              && is_rng<R> && is_constructible_v<value_type, rng_ref<R>>
              && !is_convertible_v<R &&, const value_type &>)
    : c(ww * hh, a), w(ww), h(hh) {
    assign_range(r);
  }

  template <class T2, class C2>
  explicit matrix(const matrix<T2, C2> &x)
    requires (!(is_same_v<T2, T> && is_same_v<C2, C>
                && is_constructible_v<value_type, const T2 &>))
    : c(x.c), w(x.w), h(x.h) {}
  template <class T2, class C2>
  matrix(const matrix<T2, C2> &x, const alloc_t &a)
    requires (has_allocator_type<base_t>
              && !(is_same_v<T2, T> && is_same_v<C2, C>
                   && is_constructible_v<value_type, const T2 &>))
    : c(x.c, a), w(x.w), h(x.h) {}
  template <class T2, class C2>
  matrix &operator =(const matrix<T2, C2> &x)
    requires (!(is_same_v<T2, T> && is_same_v<C2, C>
                && is_assignable_v<value_type &, const T2 &>)) {
#ifndef RE_NOEXCEPT
    try {
#endif
      c = x.c;
      w = x.w;
      h = x.h;
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      clear();
      throw;
    }
#endif
    return *this;
  }

  template <class T2, class C2>
  explicit matrix(matrix<T2, C2> &&x)
    requires (!(is_same_v<T2, T> && is_same_v<C2, C>))
#ifndef RE_NOEXCEPT
    try : c(from_range, move(x.c)), w(x.w), h(x.h) {
      x.clear();
    }
    catch (...) {
      x.clear();
      throw;
    }
#else
    : c(from_range, move(x.c)), w(x.w), h(x.h) {
    x.clear();
  }
#endif
  template <class T2, class C2>
  matrix(matrix<T2, C2> &&x, const alloc_t &a)
    requires (has_allocator_type<base_t>
              && !(is_same_v<T2, T> && is_same_v<C2, C>))
#ifndef RE_NOEXCEPT
    try : c(from_range, move(x.c), a), w(x.w), h(x.h) {
      x.clear();
    }
    catch (...) {
      x.clear();
      throw;
    }
#else
    : c(from_range, move(x.c), a), w(x.w), h(x.h) {
    x.clear();
  }
#endif
  template <class T2, class C2>
  matrix &operator =(matrix<T2, C2> &&x)
    requires (!(is_same_v<T2, T> && is_same_v<C2, C>
                && is_assignable_v<value_type &, const T2 &>)) {
#ifndef RE_NOEXCEPT
    try {
#endif
      c = move(x.c);
      w = x.w;
      h = x.h;
      x.clear();
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      clear();
      x.clear();
      throw;
    }
#endif
    return *this;    
  }

private:
  template <class T2, class C2>
  void keep_size_assign(const matrix<T2, C2> &x) {
    for (size_type i : irng(0u, min(w, x.width())))
      for (size_type j : irng(0u, min(h, x.height())))
        (*this)(i, j) = x(i, j);
  }
  template <class T2, class C2>
  void keep_size_assign(matrix<T2, C2> &&x) {
#ifndef RE_NOEXCEPT
    try {
#endif
      for (size_type i : irng(0u, min(w, x.width())))
        for (size_type j : irng(0u, min(h, x.height())))
          (*this)(i, j) = move(x(i, j));
      if (reinterpret_cast<const void *>(addressof(x))
          != reinterpret_cast<const void *>(this))
        x.clear();
#ifndef RE_NOEXCEPT
    }
    catch (...) {
      clear();
      x.clear();
      throw;
    }
#endif
  }

public:
  template <class T2, class C2>
  matrix(size_type ww, size_type hh,
         const matrix<T2, C2> &x) : matrix(ww, hh) {
    keep_size_assign(x);
  }
  template <class T2, class C2>
  matrix(size_type ww, size_type hh,
         const matrix<T2, C2> &x, const value_type &fll)
    : matrix(ww, hh, fll) {
    keep_size_assign(x);
  }
  template <class T2, class C2>
  matrix(size_type ww, size_type hh,
         const matrix<T2, C2> &x, const alloc_t &a)
    requires has_allocator_type<base_t>
    : matrix(ww, hh, a) {
    keep_size_assign(x);
  }
  template <class T2, class C2>
  matrix(size_type ww, size_type hh,
         const matrix<T2, C2> &x, const value_type &fll, const alloc_t &a)
    requires has_allocator_type<base_t>
    : matrix(ww, hh, fll, a) {
    keep_size_assign(x);
  }
  template <class T2, class C2>
  void assign(size_type ww, size_type hh,
              const matrix<T2, C2> &x,
              const value_type &fll = value_type{}) {
    resize(ww, hh, fll);
    keep_size_assign(x);
  }

  template <class T2, class C2>
  matrix(size_type ww, size_type hh,
         matrix<T2, C2> &&x) : matrix(ww, hh) {
    keep_size_assign(move(x));
  }
  template <class T2, class C2>
  matrix(size_type ww, size_type hh,
         matrix<T2, C2> &&x, const value_type &fll)
    : matrix(ww, hh, fll) {
    keep_size_assign(move(x));
  }
  template <class T2, class C2>
  matrix(size_type ww, size_type hh,
         matrix<T2, C2> &&x, const alloc_t &a)
    requires has_allocator_type<base_t>
    : matrix(ww, hh, a) {
    keep_size_assign(move(x));
  }
  template <class T2, class C2>
  matrix(size_type ww, size_type hh,
         matrix<T2, C2> &&x, const value_type &fll, const alloc_t &a)
    requires has_allocator_type<base_t>
    : matrix(ww, hh, fll, a) {
    keep_size_assign(move(x));
  }
  template <class T2, class C2>
  void assign(size_type ww, size_type hh,
              matrix<T2, C2> &&x,
              const value_type &fll = value_type{}) {
    resize(ww, hh, fll);
    keep_size_assign(move(x));
  }

  void clear() noexcept {
    c.clear();
    w = 0;
    h = 0;
  }
  void resize(size_type ww, size_type hh,
              const value_type &fll = value_type{}) {
    if constexpr (has_allocator_type<base_t>) {
      if (!(ww == w && hh == h)) {
        matrix tmp(ww, hh, fll, get_allocator());
        tmp.keep_size_assign(move(*this));
        *this = move(tmp);
      }
    }
    else {
      if (!(ww == w && hh == h)) {
        matrix tmp(ww, hh, fll);
        tmp.keep_size_assign(move(*this));
        *this = move(tmp);
      }
    }
  }

private:
  template <class M, class F>
  pair<size_type, size_type>
  cover_impl(size_type x, size_type y, M &&m, F mix_f) {
    if (x > width() || y > height()) {
      x = width();
      y = height();
    }
    const size_type h_cap = width() - x;
    const size_type v_cap = height() - y;
    const size_type wid = min(h_cap, m.width());
    const size_type hei = min(v_cap, m.height());
    for (size_type &j : iters(y, y + hei)) {
      auto it = iter(x, j);
      for (auto &a : rng(m.begin() + (j - y) * m.width(), wid)) {
        *it = mix_f(*it, static_cast<copy_cvref_t<M &, value_type>>(a));
        ++it;
      }
    }
    return pair(wid, hei);
  }
public:
  template <class F>
  pair<size_type, size_type>
  cover(size_type x, size_type y, const matrix &m, F mix_f) {
    return cover_impl(x, y, m, mix_f);
  }
  template <class F>
  pair<size_type, size_type>
  cover(size_type x, size_type y, matrix &&m, F mix_f) {
    return cover_impl(x, y, move(m), mix_f);
  }
  template <class F>
  pair<size_type, size_type>
  cover(size_type x, size_type y, matrix &m, F mix_f) {
    return cover_impl(x, y, m, mix_f);
  }
  pair<size_type, size_type>
  cover(size_type x, size_type y, const matrix &m) {
    return cover_impl(x, y, m,
                      [](value_type &,
                         const value_type &z)->const value_type & {return z;});
  }
  pair<size_type, size_type>
  cover(size_type x, size_type y, matrix &&m) {
    return cover_impl(x, y, move(m),
                      [](value_type &,
                         value_type &z)->value_type && {return move(z);});
  }
  pair<size_type, size_type>
  cover(size_type x, size_type y, matrix &m) {
    return cover_impl(x, y, move(m),
                      [](value_type &,
                         value_type &z)->value_type & {return z;});
  }

private:
  template <class M, class F>
  pair<size_type, size_type>
  cover_impl(size_type x, size_type y,
             M &&m, size_type x2, size_type y2, size_type ww, size_type hh,
             F mix_f) {
    if (x > width() || y > height()) {
      x = width();
      y = height();
    }
    if (x2 > m.width() || y2 > m.height()) {
      x2 = m.width();
      y2 = m.height();
    }
    const size_type h_cap = width() - x;
    const size_type v_cap = height() - y;
    const size_type h_cap2 = m.width() - x2;
    const size_type v_cap2 = m.height() - y2;
    const size_type wid = min({h_cap, h_cap2, ww});
    const size_type hei = min({v_cap, v_cap2, hh});

    const auto m_begin = m.iter(x2, y2);
    for (size_type &j : iters(y, y + hei)) {
      auto it = iter(x, j);
      for (auto &z : rng(m_begin + (j - y) * m.width(), wid)) {
        *it = mix_f(*it, static_cast<copy_cvref_t<M &, value_type>>(z));
        ++it;
      }
    }
    return pair(wid, hei);
  }
public:
  template <class F>
  pair<size_type, size_type>
  cover(size_type x, size_type y,
        const matrix &m, size_type x2, size_type y2,
        size_type ww, size_type hh,
        F mix_f) {
    return cover_impl(x, y, m, x2, y2, ww, hh, mix_f);
  }
  template <class F>
  pair<size_type, size_type>
  cover(size_type x, size_type y,
        matrix &&m,
        size_type x2, size_type y2, size_type ww, size_type hh,
        F mix_f) {
    return cover_impl(x, y, m, x2, y2, ww, hh, mix_f);
  }
  template <class F>
  pair<size_type, size_type>
  cover(size_type x, size_type y,
        matrix &m,
        size_type x2, size_type y2, size_type ww, size_type hh,
        F mix_f) {
    return cover_impl(x, y, m, x2, y2, ww, hh, mix_f);
  }
  pair<size_type, size_type>
  cover(size_type x, size_type y,
        const matrix &m, size_type x2, size_type y2,
        size_type ww, size_type hh) {
    return cover_impl(x, y, m, x2, y2, ww, hh,
                      [](value_type &,
                         const value_type &b)->const value_type & {return b;});
  }
  pair<size_type, size_type>
  cover(size_type x, size_type y,
        matrix &&m,
        size_type x2, size_type y2, size_type ww, size_type hh) {
    return cover_impl(x, y, m, x2, y2, ww, hh,
                      [](value_type &,
                         value_type &b)->value_type && {return move(b);});
  }
  pair<size_type, size_type>
  cover(size_type x, size_type y,
        matrix &m,
        size_type x2, size_type y2, size_type ww, size_type hh) {
    return cover_impl(x, y, m, x2, y2, ww, hh,
                      [](value_type &,
                         value_type &b)->value_type & {return b;});
  }

  auto row(size_type n) {
    return rng(c.begin() + n * w, w);
  }
  auto row(size_type n) const {
    return rng(c.begin() + n * w, w);
  }
  auto rows() {
    return bind_rng(irng(0u, h),
                    [this](auto n) {return this->row(n);});
  }
  auto rows() const {
    return bind_rng(irng(0u, h),
                    [this](auto n) {return this->row(n);});
  }

  auto column(size_type n) {
    return bind_rng(irng(0u, h),
                    [this, n](auto i)->auto & {
                      return *(begin() + to_signed(n + i * w));
                    });
  }
  auto column(size_type n) const {
    return bind_rng(irng(0u, h),
                    [this, n](auto i)->const auto & {
                      return *(begin() + to_signed(n + i * w));
                    });
  }
  auto columns() {
    return bind_rng(irng(0u, w),
                    [this](auto n) {return this->column(n);});
  }
  auto columns() const {
    return bind_rng(irng(0u, w),
                    [this](auto n) {return this->column(n);});
  }

  auto sub_range(size_type x, size_type y,
                 size_type wid, size_type hei) {
    if (!(x < width() && y < height())) {
      x = 0;
      y = 0;
      wid = 0;
      hei = 0;
    }
    x = min(x, width());
    y = min(y, width());
    const auto it = iter(x, y);
    wid = min(wid, width() - x);
    hei = min(hei, height() - y);
    return join_rng(bind_rng(irng(0u, hei),
                             [it, ww = width(), wid](size_type k) {
                               return rng(it + k * ww, wid);
                             }));
  }
  auto sub_range(size_type x, size_type y,
                 size_type wid, size_type hei) const {
    if (!(x < width() && y < height())) {
      x = 0;
      y = 0;
      wid = 0;
      hei = 0;
    }
    const auto it = iter(x, y);
    wid = min(wid, width() - x);
    hei = min(hei, height() - y);
    return join_rng(bind_rng(irng(0u, hei),
                             [it, ww = width(), wid](size_type k) {
                               return rng(it + k * ww, wid);
                             }));
  }

  void fill(size_type x, size_type y,
            size_type wid, size_type hei,
            const value_type &z) {
    x = min(x, width());
    y = min(y, height());
    const auto it = iter(x, y);
    wid = min(wid, width() - x);
    hei = min(hei, height() - y);
    for (size_type k : irng(0u, hei))
      re::fill(rng(it + k * width(), wid), z);
  }

  value_type &front() {
    return c.front();
  }
  const value_type &front() const {
    return c.front();
  }
  value_type &back() {
    return c.back();
  }
  const value_type &back() const {
    return c.back();
  }
  value_type &operator [](size_type n) {
    return c[n];
  }
  const value_type &operator [](size_type n) const {
    return c[n];
  }

  value_type &left_top() {
    return c.front();
  }
  const value_type &left_top() const {
    return c.front();
  }
  value_type &left_bottom() {
    return *prev(c.end(), to_signed(w));
  }
  const value_type &left_bottom() const {
    return *prev(c.end(), to_signed(w));
  }
  value_type &right_bottom() {
    return c.back();
  }
  const value_type &right_bottom() const {
    return c.back();
  }
  value_type &right_top() {
    return *next(c.begin(), to_signed(w - 1u));
  }
  const value_type &right_top() const {
    return *next(c.begin(), to_signed(w - 1u));
  }
  value_type &operator ()(size_type x, size_type y) {
    return operator [](y * w + x);
  }
  const value_type &operator ()(size_type x, size_type y) const {
    return operator [](y * w + x);
  }
  iterator iter(size_type x, size_type y) {
    return nth(c, y * w + x);
  }
  const_iterator iter(size_type x, size_type y) const {
    return nth(c, y * w + x);
  }
  bool includes_point(size_type x, size_type y) const noexcept {
    return x < width() && y < height();
  }

  size_type capacity() const noexcept {
    return c.capacity();
  }
  void reserve(size_type n) {
    c.reserve(n);
  }
  void reserve_more(size_type n) {
    c.reserve_more(n);
  }
  void shrink_to_fit() {
    c.shrink_to_fit();
  }

  void swap(const_iterator it, const_iterator it2) noexcept {
    c.swap(it, it2);
  }
  void swap(const_iterator it, matrix &x, const_iterator it2) noexcept {
    c.swap(it, x.c, it2);
  }
  void swap(const_iterator it, matrix &&x, const_iterator it2) noexcept {
    c.swap(it, x.c, it2);
  }
  void replace(const_iterator it, const_iterator it2, matrix &&x) {
    const auto sz = c.size();
    c.replace(it, it2, move(x.c));
    if (c.size() != sz)
      throw_or_terminate<logic_error>
        ("re::matrix::replace(it, it2, this_rref): size changed\n");
    x.clear();
  }
  matrix exchange(const_iterator it, const_iterator it2, matrix &&x) {
    const auto sz = c.size();
    const auto x_sz = x.size();
    matrix ret(c.exchange(it, it2, move(x.c)), x_sz, 1u);
    if (c.size() != sz)
      throw_or_terminate<logic_error>
        ("re::matrix::exchange(it, it2, this_rref): size changed\n");
    x.clear();
    return ret;
  }

  matrix operator +() const {
    return *this;
  }
  matrix operator -() const {
    matrix ret = *this;
    for (auto &x : ret)
      x = -x;
    return ret;
  }

  matrix &operator +=(const matrix &x) {
    if (!(w == x.w && h == x.h))
      throw_or_terminate<logic_error>
        ("re::matrix::operator +=(const matrix &): different size\n");
    for_each(x, begin(), [](const value_type &a, value_type &b) {b += a;});
    return *this;
  }
  matrix &operator -=(const matrix &x) {
    if (!(w == x.w && h == x.h))
      throw_or_terminate<logic_error>
        ("re::matrix::operator -=(const matrix &): different size\n");
    for_each(x, begin(), [](const value_type &a, value_type &b) {b -= a;});
    return *this;
  }
  matrix operator +(const matrix &x) const {
    if (!(w == x.w && h == x.h))
      throw_or_terminate<logic_error>
        ("re::matrix::operator +(const matrix &): different size\n");
    matrix ret(w, h);
    auto it = ret.begin();
    for_each(*this, x, [&it](const auto &a, const auto &b) {
      *it = a + b;
      ++it;
    });
    return ret;
  }
  matrix operator -(const matrix &x) const {
    if (!(w == x.w && h == x.h))
      throw_or_terminate<logic_error>
        ("re::matrix::operator -(const matrix &): different size\n");
    matrix ret(w, h);
    auto it = ret.begin();
    for_each(*this, x, [&it](const auto &a, const auto &b) {
      *it = a - b;
      ++it;
    });
    return ret;
  }
  matrix operator *(const value_type &k) const {
    matrix ret = *this;
    for (auto &x : ret)
      x = x * k;
    return ret;
  }
  matrix &operator *=(const value_type &k) {
    for (auto &x : *this)
      x *= k;
    return *this;
  }
  friend matrix operator *(const value_type &k, const matrix &x) {
    return x * k;
  }
  matrix operator /(const value_type &k) const {
    matrix ret = *this;
    for (auto &x : ret)
      x = x / k;
    return ret;
  }
  matrix &operator /=(const value_type &k) {
    for (auto &x : *this)
      x /= k;
    return *this;
  }

  matrix operator *(const matrix &x) const {
    if (empty() || x.empty() || !(w == x.h))
      throw_or_terminate<logic_error>
        ("re::matrix::operator *(const matrix &): unmatched\n");
    matrix ret(x.w, h);
    for (size_type i : irng(0u, x.w))
      for (size_type j : irng(0u, h)) {
        auto &z = ret(i, j);
        for_each(row(j), x.column(i),
                 [&z](const value_type &a, const value_type &b) {
                   z += (a * b);
                 });
      }
    return ret;
  }
};

}

// dup_compressed_array
namespace re {

template <class T, class AL = default_allocator<T>>
class dup_compressed_array;
namespace inner {

template <class T, class AL>
class dup_compressed_array_iterator {
  using this_t = dup_compressed_array_iterator;

  template <class, class>
  friend class dup_compressed_array_iterator;
  template <class, class>
  friend class re::dup_compressed_array;

  using count_t = max_uint_of_max_size<sizeof(T)>;
  using stored_t = pair<T, count_t>;
  using container_t = vector<stored_t, alloc_rebind<AL, stored_t>>;
  using iter_t = typename container_t::const_iterator;
  iter_t p = iter_t{};
  count_t n = count_t{};

public:
  using value_type = remove_const_t<T>;
  using pointer = void;
  using reference = T;
  using difference_type = typename container_t::difference_type;
  using iterator_category = bidirectional_iterator_tag;

  dup_compressed_array_iterator() = default;
  ~dup_compressed_array_iterator() = default;
  dup_compressed_array_iterator(const this_t &) = default;
  this_t &operator =(const this_t &) = default;
  dup_compressed_array_iterator(this_t &&) = default;
  this_t &operator =(this_t &&) = default;
  friend void swap(this_t &x, this_t &y) noexcept {
    adl_swap(x.p, y.p);
    adl_swap(x.n, y.n);
  }

private:
  explicit dup_compressed_array_iterator(iter_t pp, count_t nn)
    : p(pp), n(nn) {}
  typename container_t::iterator base() const {
    return const_cast<typename container_t::iterator>(p);
  }
  count_t nth_dup() const {
    return n;
  }

public:
  bool operator ==(const this_t &) const = default;
  strong_ordering operator <=>(const this_t &x) const {
    const strong_ordering o = (p <=> x.p);
    if (o == strong_eq)
      return n <=> x.n;
    return o;
  }

  reference operator *() const {
    return p->first;
  }

  this_t &operator ++() {
    ++n;
    if (n == p->second) {
      ++p;
      n = 0;
    }
    return *this;
  }
  this_t operator ++(int) {
    return iter_post_increment(*this);
  }

  this_t &operator --() {
    if (n != 0u)
      --n;
    else {
      --p;
      n = p->second;
      --n;
    }
    return *this;
  }
  this_t operator --(int) {
    return iter_post_decrement(*this);
  }
};

}
template <class T, class AL>
class dup_compressed_array {
  using this_t = dup_compressed_array;

  using count_t = max_uint_of_max_size<sizeof(T)>;
  using stored_t = pair<T, count_t>;
  using container_t = vector<stored_t, alloc_rebind<AL, stored_t>>;
  using container_alloc_t = typename container_t::allocator_type;
  container_t v;

  static count_t count_max() noexcept {
    return numeric_limits<count_t>::max();
  }

public:
  using value_type = T;
  using reference = value_type;
  using const_reference = value_type;

  using iterator = inner::dup_compressed_array_iterator<T, AL>;
  using const_iterator = iterator;
  using difference_type = typename container_t::difference_type;
  using size_type = typename container_t::size_type;

  iterator begin() const noexcept {
    return iterator(v.begin(), 0u);
  }
  iterator end() const noexcept {
    return iterator(v.end(), 0u);
  }
  iterator cbegin() const noexcept {
    return begin();
  }
  iterator cend() const noexcept {
    return end();
  }

  size_type max_size() const noexcept {
    return v.max_size();
  }
  bool empty() const noexcept {
    return v.empty();
  }

  dup_compressed_array() = default;
  ~dup_compressed_array() = default;
  dup_compressed_array(const this_t &) = default;
  this_t &operator =(const this_t &) = default;
  dup_compressed_array(this_t &&) = default;
  this_t &operator =(this_t &&) = default;
  friend void swap(this_t &a, this_t &b)
    noexcept(is_nothrow_swappable_v<container_t>) {
    adl_swap(a.v, b.v);
  }

  bool operator ==(const this_t &) const = default;
  synth_3way_result<T> operator <=>(const this_t &x) const {
    return lexicographical_synth_3way(*this, x);
  }

  using reverse_iterator = re::reverse_iterator<iterator>;
  using const_reverse_iterator = reverse_iterator;
  reverse_iterator rbegin() const noexcept {
    return reverse_iterator(end());
  }
  reverse_iterator rend() const noexcept {
    return reverse_iterator(begin());
  }
  reverse_iterator crbegin() const noexcept {
    return rbegin();
  }
  reverse_iterator crend() const noexcept {
    return rend();
  }

  using allocator_type = AL;
  allocator_type get_allocator() const noexcept {
    return allocator_type(v.get_allocator());
  }
  explicit dup_compressed_array(const AL &a)
    : v(container_alloc_t(a)) {}
  dup_compressed_array(const this_t &x, const AL &a)
    : v(x.v, container_alloc_t(a)) {}
  dup_compressed_array(this_t &&x, const AL &a)
    : v(move(x.v), container_alloc_t(a)) {}

private:
  void append_single_impl(const value_type &x) {
    if (v.empty()
        || x != v.back().first
        || v.back().second == count_max())
      v.emplace_back(x, 1u);
    else
      ++v.back().second;
  }
  void append_n_impl(size_type n, const value_type &x = value_type{}) {
    if (n == 0u)
      return;

    if (!v.empty() && before_end(v)->first == x) {
      const auto base_it = before_end(v);
      const auto nn = base_it->second;
      if (size_type rest_n = static_cast<size_type>(count_max() - nn);
          n > rest_n) {
        base_it->second = count_max();
        n -= rest_n;
      }
      else {
        base_it->second += n;
        return;
      }
    }

    if (n <= count_max())
      v.emplace_back(x, n);
    else {
      const size_type max2(count_max());
      const size_type q = n / max2;
      const size_type rem = n % max2;
      v.append_range(rng(q, stored_t(x, count_max())));
      if (rem != 0u)
        v.emplace_back(x, rem);
    }
  }

  template <class R>
  void append_range_impl(R &&r) {
    for (auto &it : iters(r))
      append_single_impl(*it);
  }
  template <class R>
  void append_range_impl(R &&r) requires rng_is_n_value<R> {
    if (!r.empty()) {
      if (r.size() > numeric_limits<size_type>::max())
        throw_or_terminate<length_error>
          ("re::dup_compressed_array::append_range_impl(r)\n");
      append_n_impl(r.size(), *r.begin());
    }
  }

public:
  explicit dup_compressed_array(size_type n, const AL &al = AL{})
    : v(container_alloc_t(al)) {
    append_n_impl(n);
  }
  dup_compressed_array(size_type n, value_type x, const AL &al = AL{})
    : v(container_alloc_t(al)) {
    append_n_impl(n, x);
  }
  void assign(size_type n, value_type x) {
    v.clear();
    append_n_impl(n, x);
  }

  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  dup_compressed_array(IITR from, IITR to, const AL &al = AL{})
    : v(container_alloc_t(al)) {
    append_range_impl(rng(from, to));
  }
  template <class IITR>
  enable_if_t<is_itr<IITR>> assign(IITR from, IITR to) {
    v.clear();
    append_range_impl(rng(from, to));
  }

  dup_compressed_array(initializer_list<value_type> l, const AL &al = AL{})
    : v(container_alloc_t(al)) {
    append_range_impl(l);
  }
  dup_compressed_array &operator =(initializer_list<value_type> l) {
    v.clear();
    append_range_impl(l);
    return *this;
  }
  void assign(initializer_list<value_type> l) {
    v.clear();
    append_range_impl(l);
  }

private:
  iterator insert_single_impl(iterator pos, const value_type &x) {
    if (pos.base() == v.end()) {
      append_single_impl(x);
      const auto base_it = before_end(v);
      return iterator(base_it, base_it->second - 1u);
    }
    else {
      const auto base_it = pos.base();
      const count_t nn = pos.nth_dup();
      if (nn != 0u) {
        if (pos.base()->first == x && base_it->second < count_max()) {
          ++(base_it->second);
          return pos;
        }
        else {
          base_it->second -= nn;
          const auto it = v.insert_range(base_it,
                                         seq(stored_t(base_it->first, nn),
                                             stored_t(x, 1u)));
          return iterator(next(it), 0u);
        }
      }
      else {
        if (base_it->first == x) {
          if (base_it->second < count_max()) {
            ++(base_it->second);
            return iterator(base_it, 0u);
          }
        }
        else if (prev(base_it)->first == x) {
          if (prev(base_it)->second < count_max()) {
            ++prev(base_it)->second;
            return iterator(prev(base_it), prev(base_it)->second - 1u);
          }
        }
        return iterator(v.emplace(base_it, x, 1u), 0u);
      }
    }
  }
public:
  iterator insert(iterator pos, value_type x) {
    return insert_single_impl(pos, x);
  }

private:
  iterator erase_impl(iterator pos) {
    const auto base_it = pos.base();
    const count_t nn = pos.nth_dup();
    if (base_it->second == 1u)
      return iterator(v.erase(base_it), 0u);
    else {
      --(base_it->second);
      return (nn != base_it->second) ? pos : iterator(next(base_it), 0u);
    }
  }
  iterator erase_impl(iterator it1, iterator it2) {
    if (it1 == it2)
      return it1;
    const auto base_it1 = it1.base();
    const auto nn1 = it1.nth_dup();
    const auto base_it2 = it2.base();
    const auto nn2 = it2.nth_dup();
    if (base_it1 == base_it2) {
      base_it1->second -= (nn2 - nn1);
      return it1;
    }
    else {
      if (nn1 == 0u) {
        if (base_it2 == v.end()) {
          v.erase(base_it1, base_it2);
          return iterator(v.end(), 0u);
        }
        else {
          const auto it = v.erase(base_it1, base_it2);
          it->second -= nn2;
          return iterator(it, 0u);
        }
      }
      else {
        if (base_it2 == v.end()) {
          base_it1->second = nn1;
          v.erase(next(base_it1), base_it2);
          return iterator(v.end(), 0u);
        }
        else {
          base_it1->second = nn1;
          base_it2->second -= nn2;
          const auto it = v.erase(next(base_it1), base_it2);
          return iterator(it, 0u);
        }
      }
    }
  }

  iterator insert_n_impl(iterator pos, size_type n, const value_type &x) {
    const auto base_it = pos.base();
    const auto nn = pos.nth_dup();
    const auto base_dif = base_it - v.begin();

    this_t tmp(pos, end(), get_allocator());
    erase(pos, end());
    append_n_impl(n, x);
    append_range_impl(tmp);

    return iterator(v.begin() + base_dif, nn);
  }
  template <class R>
  iterator insert_range_impl(iterator pos, R &&r) {
    const auto base_it = pos.base();
    const auto nn = pos.nth_dup();
    const auto base_dif = base_it - v.begin();

    this_t tmp(pos, end(), get_allocator());
    erase(pos, end());
    append_range_impl(r);
    append_range_impl(tmp);

    return iterator(v.begin() + base_dif, nn);
  }
  template <class R>
  iterator insert_range_impl(iterator pos, R &&r)
    requires rng_is_n_value<R> {
    if (r.empty())
      return pos;
    return insert_n_impl(pos, r.size(), *r.begin());
  }

public:
  iterator insert(iterator pos, size_type n, value_type x) {
    return insert_n_impl(pos, n, x);
  }
  template <class IITR, class = enable_if_t<is_itr<IITR>>>
  iterator insert(iterator pos, IITR from, IITR to) {
    return insert_range_impl(pos, rng(from, to));
  }
  iterator insert(iterator pos, initializer_list<value_type> l) {
    return insert_range_impl(pos, l);
  }

  iterator erase(iterator pos) {
    return erase_impl(pos);
  }
  iterator erase(iterator from, iterator to) {
    return erase_impl(from, to);
  }

  void clear() noexcept {
    v.clear();
  }

  // optional sequence container operations

  value_type front() const {
    return v.begin()->first;
  }
  value_type back() const {
    return before_end(v)->first;
  }
  void push_back(value_type x) {
    append_single_impl(x);
  }
  void pop_back() noexcept {
    const auto base_it = before_end(v);
    const auto nn = base_it->second;
    if (nn == 1u)
      v.pop_back();
    else
      --(base_it->second);
  }

  // extensions

  size_type compressed_size() const noexcept {
    return v.size();
  }
  size_type capacity() const noexcept {
    return v.capacity();
  }
  bool full() const noexcept {
    return v.full();
  }
  void reserve(size_type n) {
    v.reserve(n);
  }
  void reserve_more(size_type n) {
    v.reserve_more(n);
  }
  void shrink_to_fit() {
    v.shrink_to_fit();
  }
  void reallocate(size_type n = 0) {
    v.reallocate(n);
  }
  template <class R>
  iterator replace(iterator i1, iterator i2, R &&r) {
    return insert_range(erase(i1, i2), r);
  }

  template <class R>
  dup_compressed_array(from_range_t,
                       R &&r, const AL &al = AL{})
    requires (is_rng<R> && is_convertible_v<rng_ref<R>, const value_type &>)
    : v(container_alloc_t(al)) {
    append_range_impl(r);
  }
  template <class R, class = enable_if_t
            <!is_same_v<decay_t<R>, this_t>
             && !is_convertible_v<R &&, const AL &>
             && is_rng<R> && is_convertible_v<rng_ref<R>, const value_type &>>>
  explicit dup_compressed_array(R &&r) {
    append_range_impl(r);
  }
  template <class R, class = enable_if_t
            <!is_same_v<decay_t<R>, this_t>
             && !is_convertible_v<R &&, const AL &>
             && is_rng<R> && is_convertible_v<rng_ref<R>, const value_type &>>>
  dup_compressed_array(R &&r, const AL &al)
    : v(container_alloc_t(al)) {
    construct_from_range_impl(r);
  }
  template <class R>
  enable_if_t<!is_same_v<decay_t<R>, this_t>
              && !is_convertible_v<R &&, const AL &>
              && is_rng<R> && is_convertible_v<rng_ref<R>, const value_type &>,
              this_t &>
  operator =(R &&r) {
    v.clear();
    append_range_impl(r);
    return *this;
  }
  template <class IITR_RANGE>
  void assign(IITR_RANGE &&r) {
    v.clear();
    append_range_impl(r);
  }
  template <class IITR_RANGE>
  void assign_range(IITR_RANGE &&r) {
    v.clear();
    append_range_impl(r);
  }

  template <class IITR_RANGE>
  enable_if_t<!is_convertible_v<IITR_RANGE &&, value_type>, iterator>
  insert(iterator pos, IITR_RANGE &&r) {
    return insert_range_impl(pos, r);
  }
  template <class IITR_RANGE>
  iterator insert_range(iterator pos, IITR_RANGE &&r) {
    return insert_range_impl(pos, r);
  }

  template <class IITR_RANGE>
  enable_if_t<!is_convertible_v<IITR_RANGE &&, value_type>>
  push_back(IITR_RANGE &&r) {
    append_range_impl(r);
  }
  template <class IITR_RANGE>
  void append_range(IITR_RANGE &&r) {
    append_range_impl(r);
  }
  void pop_back(size_type n) {
    for (;;) {
      const auto base_it = before_end(v);
      const auto nn = base_it->second;
      if (nn == n) {
        v.pop_back();
        return;
      }
      else if (nn > n) {
        base_it->second -= n;
        return;
      }
      else {
        v.pop_back();
        n -= nn;
      }
    }
  }

  this_t &append() {
    return *this;
  }
  template <class X, class...S>
  this_t &append(X &&x, S &&...s) {
    push_back(forward<X>(x));
    return append(forward<S>(s)...);
  }
};

}

#endif
